Algoritmen en Complexiteit

Leen Torenvliet

1 december 2021

c(cid:13) Alle rechten zijn voorbehouden aan de auteur. Verspreiding door middel van druk, e-mail, ftp,

http, of andere media is toegestaan mits de volledige onveranderde tekst wordt overgedragen.
Aan de tekst kan verder geen enkel recht worden ontleend en geen enkele impliciete of explicite

garantie wordt gegeven voor de correctheid en/of volledigheid van de tekst. Commentaar en
correctievoorstellen zijn uiteraard van harte welkom op mijn e-mailadres l.torenvliet@uva.nl.

1 december 2021

Inhoudsopgave

Voorwoord

I Algoritmen

1 Voorspel

1.1
Inleiding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Analyse van Algoritmen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.1 Meten is weten . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.2 Voorspellen is beter
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.3
1.3 Asymptotische Grenzen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3.1 Notatie voor de Complexiteit van Algoritmen . . . . . . . . . . . . . . . . . .
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3.2
1.4 Wiskundige Hulpmiddelen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.1
Inductie en Recursie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.2 Recurrente betrekkingen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.3 Reeksen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.4 Reeksen en Integralen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.5
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Technieken

2.1 Gulzige Algoritmen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 Geld Wisselen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.2 Knapsack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.3 Grafen: kortste paden . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.4 Grafen: opspannende bomen . . . . . . . . . . . . . . . . . . . . . . . . . . .
Scheduling
2.1.5
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.6
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.1 Matrixvermenigvuldiging . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.2 Zoeken en sorteren . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.3
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Dynamisch Programmeren . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.1 Dynamisch programmeren en Knapsack . . . . . . . . . . . . . . . . . . . . .

2.2 Verdeel en Heers

3

7

9

13
13
15
15
16
22
22
26
28
29
29
30
34
36
36

39
39
40
41
42
43
45
49
50
51
52
57
57
58

2.3.2 Tekstwijzigen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.3 Kortste paden 2: Floyd-Warshall
. . . . . . . . . . . . . . . . . . . . . . . . .
2.3.4 Matrixvermenigvuldiging . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.5

3 Grafenalgoritmen

3.1 Zoeken in Grafen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1 Depth First Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.2 Breadth First Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Kortste paden 3: De A(cid:3) algoritme
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Netwerken en Stromen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.1 Min Cut Max Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.2 Gelaagde Netwerken . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Toepassingen van Network Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4.1 Perfect Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4.2 Connectivity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4.3 Matrixsommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4.4
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

59
61
62
64

67
67
67
70
71
73
73
76
79
79
79
79
80

4 Numerieke Algoritmen

83
83
4.1 De Euclidische Algoritme en Uitbreidingen . . . . . . . . . . . . . . . . . . . . . . .
84
4.1.1 De Uitgebreide Euclidische Algoritme en Inversen . . . . . . . . . . . . . . . .
85
4.1.2
sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
4.2 Vermenigvuldiging van Grote Getallen, DFT . . . . . . . . . . . . . . . . . . . . . .
85
4.2.1
Inleiding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
4.2.2 De eerste algoritmen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
4.3 Betere algoritmen voor vermenigvuldiging . . . . . . . . . . . . . . . . . . . . . . . .
88
4.3.1 De kampioen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
4.3.2 Getallen als polynomen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
4.3.3 Complexe n-de machts eenheidswortels . . . . . . . . . . . . . . . . . . . . . .
91
4.3.4 De Fast-Fourier transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
4.3.5 De inverse Fourier transform . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
4.4 Snelle Machtsverhe(cid:14)ng . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98
sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
4.5 Cryptogra(cid:12)e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
4.5.1 Private Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.5.2
Sleutel Delen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
4.5.3 Public Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.5.4 Priemgetallen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
4.5.5
4.6 Beveiliging van gegevens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
4.6.1
Identi(cid:12)catie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
4.6.2 Commitment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
4.6.3

4.4.1

4

II Complexiteitstheorie

107

5 Modellen voor Berekening

111
5.1 Redelijke Machinemodellen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
5.1.1 De Random Access Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.1.2 De Turing Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
5.1.3
Simulaties tussen RAMS en Turingmachines . . . . . . . . . . . . . . . . . . . 118
5.2 Onredelijke Machinemodellen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
5.2.1 Onbegrensd Parallellisme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
5.2.2 Oneerlijk tellen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
5.2.3
Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

6 Centrale Complexiteitsklassen

123
6.1 Polynomiale en Exponenti(cid:127)ele Tijd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
6.1.1 De Universele Turing Machine
. . . . . . . . . . . . . . . . . . . . . . . . . . 125
6.1.2 Het Padding Lemma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.1.3 P 6= EXP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.1.4
6.2 NP Problemen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.3 Het Nondeterministische Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.4 Reductie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.5 NP-volledigheid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
6.5.1 Meer NP-volledige problemen . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
6.5.2 Beslissen, Optimalisatie en Zelfreduceerbaarheid . . . . . . . . . . . . . . . . 153
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
6.5.3
6.6 Sommen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
6.7 NP-problemen en de Praktijk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
SAT, KNAPSACK, en VC . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
6.7.1
6.7.2 Een benadering voor TSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
6.7.3 Branch en Bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162

Isomor(cid:12)e

III Extra Onderwerpen

165

7 Meer Complexiteitsklassen

169
7.1 Geheugenbegrensde Klassen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
7.2 PSPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
7.2.1 Volledige Problemen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
7.2.2 Andere PSPACE Volledige Problemen . . . . . . . . . . . . . . . . . . . . . . 172
7.3 LOGSPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
7.3.1 Complete Problemen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
7.4
Interactieve Bewijzen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
7.5 Zero Knowledge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
IP=PSPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
7.6
IP (cid:18) PSPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
7.6.1
7.6.2 PSPACE (cid:18) IP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181

5

A Begrippenlijst

185

6

Voorwoord

Sinds 1983 geef ik jaarlijks het vak Complexiteitstheorie aan de Universiteit van Amsterdam. Soms
in combinatie met Automatentheorie, soms in combinatie met Algoritmen, en de laatste tijd ook als
rechtstreeks vervolg op het college Datastructuren. Er zijn vele, vele boeken over algoritmen, goede
en minder goede. Zo nu en dan vraagt een student mij of er niet een goed boek over algoritmen
in het Nederlands geschreven is en mijn antwoord is dan: \Voorzover ik weet niet." Natuurlijk
is de \markt" voor Nederlandse boeken over wetenschappelijke onderwerpen sowieso klein en is
de neiging om een boek te schrijven in het Nederlands over een onderwerp waarover zoveel goede
boeken al beschikbaar zijn niet erg groot. Toch is het idee niet zo bijzonder. Als we naar onze
oosterburen kijken dan zien we dat het daar heel gebruikelijk is om colleges in boekvorm te noteren
en vervolgens uit te brengen zodat deze boeken door de studenten gebruikt kunnen worden. Nu de
druk op studenten om snel door de studie heen te komen ook in ons land steeds groter wordt en
bovendien is afgesproken dat in de bachelorfase van de studie het Nederlands de voertaal is, lijkt het
geen grote stap om ook het studiemateriaal in het Nederlands aan te bieden. Vandaar deze tekst.
Of het een \goed" boek wordt, of is geworden, zoals door de student in kwestie werd gevraagd laat
ik graag aan de lezer. Het boek is in grote lijnen de neerslag van een college algoritmiek en bespreekt
de onderwerpen die ik graag in zo’n college voorbij laat komen. Ik gebruik de tekst voortdurend
tijdens het college en de tekst wordt ook aangepast naar aanleiding van kritische opmerkingen van
de studenten.

De tekst bestaat uit drie delen.

In het eerste deel bespreken we het onderwerp Algoritmen.
Een algoritme is, zoals de lezer wellicht bekend is, een methode om een bepaald probleem door
een machine te doen oplossen. Het gaat hier in het bijzonder om problemen die op een stap-voor-
stap manier kunnen worden uitgevoerd, waarbij herhaling van een aantal opeenvolgende stappen
is toegestaan, maar waarbij toepassing van intelligentie bij het uitvoeren van de stappen of bij
het beslissen of een serie stappen herhaald moet worden niet is toegestaan. Een algoritme moet
een begin en een eind hebben en de Algoritmiek is de wetenschap die probeert voor soorten van
problemen algoritmen te maken die zo snel mogelijk van dat begin naar dat eind komen. Ook in
deze tijd, waarin computers steeds sneller lijken te worden is het sneller maken van algoritmen nog
steeds een bedrijvigheid die zinvol is. We zullen daarvan enkele overtuigende voorbeelden voor-
bij zien komen. Om te kunnen bepalen of de ene algoritme sneller is dan de andere hebben we
wiskundige hulpmiddelen nodig die we zullen bespreken voordat we voorbeelden van algoritmische
methoden gaan bekijken. Deze methoden bestaan uit een aantal truken die in het verleden nuttig
zijn gebleken om problemen van een bepaalde soort van algoritmen te voorzien. We bespreken hier
achtereenvolgens de Gulzige Algoritmen, de Verdeel-en-Heersstrategie, en het Dynamisch Program-
meren. Met de ontwerpmethoden en analytische methoden in de hand bekijken we verschillende
toepassingsgebieden van de algoritmiek, in het bijzonder de algoritmen op grafen en de getaltheore-

7

tische algoritmen. Het laatste onderwerp mondt uit in de tegenwoordig in de belangstelling staande
public key cryptosystemen en toepassingen daarvan voor de beveiliging van gegevens.

Het tweede deel wordt door studenten doorgaans als moelijker ervaren. We beschouwen de
problemen op zich en generaliseren over alle mogelijke algoritmen die voor een probleem kunnen
worden bedacht. We proberen hier aan te geven waarom het voor sommige, schijnbaar eenvoudige,
problemen onmogelijk lijkt een e(cid:14)ci(cid:127)ente algoritme te bedenken, en ontwikkelen technieken die ons
in staat stellen zulke problemen te herkennen en te bewijzen dat het op z’n minst onwaarschijnlijk
is dat e(cid:14)ci(cid:127)ente algoritmen voor zo’n probleem bestaan. De motivatie hiervoor is uiterst praktisch.
Aangezien deze problemen in allerlei vormen in de praktijk vaak voorkomen, is het aannemelijk
dat een opdrachtgever een algoritme voor zo’n probleem zou willen hebben. Het is waarschijnlijk
beter om in dat geval een sterk verhaal te hebben en om vooral van tevoren te kunnen beslissen
dat een e(cid:14)ci(cid:127)ente algoritme voor zo’n probleem onwaarschijnlijk is. Afhankelijk van hoe erg de
ondoenlijkheid van die problemen is, kunnen ze ondergebracht worden in bepaalde klassen en de
bestudering van deze klassen is een centraal onderwerp in de complexiteitstheorie. Tenslotte is er
nog het onderwerp benadering. Als we hebben vastgesteld dat het geen zin heeft voor een probleem
een algoritme te vinden die in alle gevallen e(cid:14)ci(cid:127)ent is, dan kunnen we nog zoeken naar algoritmen
die in de \meeste" gevallen e(cid:14)cient zijn. Hierbij kan meeste gevallen betekenen dat de algoritme
e(cid:14)cient is voor de meeste inputs van dezelfde lengte, of dat de meeste paden die een algoritme volgt
als onderweg een randomgenerator gevolgd wordt, e(cid:14)cient zijn, dwz. dat de verwachte rekentijd
klein is.

De eerste twee delen van dit boek bevatten een serie onderwerpen die in twaalf tot vijftien
colleges van twee uur gemakkelijk behandeld kunnen worden, en is ongeveer gericht op tweedejaars
informaticastudenten, waarbij het deel Algoritmen ongeveer tweederde van de tijd in beslag neemt.
In geval minder tijd beschikbaar is, of als bijvoorbeeld de studenten een ruimere wiskundige achter-
grond hebben dan hier wordt aangenomen, zou de wiskunde-inleiding kunnen worden overgeslagen
en zou een keuze gemaakt kunnen worden uit de onderwerpen uit het gedeelte Algoritmen. Ook
zou een gedeelte van het derde deel van het boek behandeld kunnen worden, waarin onderwerpen
besproken worden die niet noodzakelijk tot basiskennis algoritmiek gerekend worden.

Nagenoeg alle stellingen, algoritmen en bewijzen kunnen wel ergens teruggevonden worden in
de literatuur, vaak in tekstboeken. Slechts wanneer beschikking over de volledige originele tekst|
voorzover nog terug te vinden|kan leiden tot dieper inzicht of anderszins vermeldenswaardig is,
heb ik de bron vermeld in deze tekst. Voor het overige verwijs ik slechts naar de volgende, naar
mijn idee lezenswaardige, boeken en de verwijzingen daarin [Har92, JS04, Wil86, Meh85, BB96,
Ski98, GT02, GJ79]. In het studiejaar 2007{2008 heb ik deze tekst voor het eerst als syllabus bij
het college gebruikt, in plaats van een boek. Florian Speelman en Jannis Teunissen hebben uit de
eerste tekst een aantal fouten gehaald. In het collegejaar 2008-2009 heeft Koos van Strien de tekst
nogmaals geheel doorgewerkt, en zijn er opnieuw veranderingen aangebracht. In 2010 heeft Jeroen
Zuiddam een aantal nuttige verbeteringen gesuggereerd en heeft Inge Bethke het college over snelle
Fouriertransformatie gegeven en uit dat hoofdstuk een aantal fouten gehaald.

8

Deel I

Algoritmen

9

Het eerste deel van de tekst behandelt algoritmen en hun complexiteit. We bespreken de be-
langrijkste complexiteitsmaten en hoe deze maten toe te passen op algoritmen. Vervolgens bekijken
we een aantal algoritmische methoden en een aantal voorbeelden van hun toepassingen. Aparte
hoofdstukken vormen de toepassingsgebieden grafen en numerieke algoritmen.

11

12

Hoofdstuk 1

Voorspel

1.1 Inleiding

Problemen, algoritmen en oplossingen vormen een drie(cid:127)eenheid in de informatica. Elke vraag die
men in (cid:19)e(cid:19)en of andere taal kan stellen is een probleem, maar zo’n probleem is voor de informaticus
niet noodzakelijk interessant. Een probleem wordt pas interessant voor de informaticus als er sprake
is van een|doorgaans oneindige|verzameling van soortgelijke vragen die op dezelfde manier naar
een oplossing gebracht kunnen worden. In zo’n geval is deze verzameling van problemen te vangen
met eenzelfde methode, en we spreken dan al snel van een algoritme om het probleem op te lossen.
Naar een formele invulling van het begrip algoritme is lang gezocht. Algoritmen om problemen
op te lossen zijn al zo oud als de wereld. De algoritme die we in paragraaf 4.4 bespreken bijvoorbeeld
stamt uit India en is zeker 5000 jaar oud. Toch wordt, zeker in Europa, pas zo’n 100 jaar nagedacht
over het begrip algoritme. Als aanleiding voor deze ontwikkeling kunnen we de feestrede noemen die
David Hilbert in het jaar 1900 in Parijs voor de verzamelde wiskundige gemenschap hield noemen.
In deze rede presenteerde Hilbert 23 open problemen waarvan hij dacht dat het urgent was dat de
wiskundigen die in de komende eeuw zouden oplossen.

Een aantal van deze problemen heeft aanleiding gegeven tot revolutionair werk in de wiskunde
en de informatica, en een aantal heeft natuurlijk ook minder belangstelling1 gekregen. Van de
interessante problemen noemen we bijvoorbeeld het eerste, en volgens Hilbert ook belangrijkste,
probleem van het bepalen van het cardinaalgetal van het continuum, dat aan G. Cantor werd toege-
schreven. Cantor had namelijk bewezen dat er meer re(cid:127)ele getallen dan natuurlijke getallen bestaan
(zie 6.1) maar de vraag of er misschien een verzameling met meer elementen dan de natuurlijke
getallen, maar minder elementen dan de re(cid:127)ele getallen zou kunnen bestaan bleef open. De aanname
dat er niet zo’n verzameling bestaat werd bekend onder de naam continu(cid:127)umhypothese Later in die
eeuw bleek dat deze vraag onafhankelijk is van de axioma’s van de verzamelingenleer. G(cid:127)odel be-
wees in 1938 dat je niet het tegendeel kunt bewijzen, en Cohen bewees in 1963 dat je de hypothese
zelf niet kunt bewijzen. Je kunt deze hypothese dus aannemen (of niet) en een consistente ver-

1Als zijn vijftiende probleem presenteerde Hilbert het vinden van een

rigorous foundation of Schubert’s enu-
"
meration calculus". Schubert was een negentiende eeuwse Duitse wiskundige die een veelheid aan constanten vond
verbonden met bepaalde meetkundige objecten. Bijvoorbeeld: het aantal lijnen dat vier gegeven lijnen in drie di-
mensies snijdt is twee, en het aantal kwadratische oppervlakken dat negen kwadratische oppervlakken in de ruimte
raakt is 666.841.048. De Nederlandse wiskundige van der Waerden heeft tussen 1920 en 1930 hier enig werk aan
besteed, als onderdeel van het onderzoek in de algebra(cid:127)(cid:16)sche meetkunde.

13

zamelingentheorie overhouden, ongeveer net als het evenwijdige lijnen axioma van de Euclidische
meetkunde.

Het tweede probleem dat Hilbert presenteerde was dat van de consistentie van de axioma’s van
de rekenkunde. Hilbert, als formalist, geloofde stellig dat de hele wiskunde geautomatiseerd zou
kunnen worden en dat elke stelling met behulp van mechanische middelen geproduceerd zou kunnen
worden door een ijverige wiskundige (computers waren in die tijd onbekend). Deze gedachte dreef
Principia Mathematica", een lijvig
onder andere Whitehead en Russel tot het produceren van de
"
stuk dat helaas altijd tot vier delen beperkt is gebleven waarin zo’n formalisering van de wiskunde
werd ondernomen. In 1931 bewees G(cid:127)odel de onvolledigheid van de rekenkunde. Elk eindig consistent
stelsel van axioma’s voor de rekenkunde zal altijd ware stellingen hebben die geen bewijs binnen dit
stelsel hebben. Dit probleem inspireerde ook het nadenken over wat nu eigenlijk zo’n mechanisch
rekenkundig proces is en leidde in de dertiger jaren ongeveer tegelijkertijd tot een aantal formalismen
voor het begrip berekenbaarheid. Turing presenteerde in 1936 zijn Turingmachine [Tur36]. Dit
model gebruiken we nog steeds om de uitdrukking te geven aan de complexiteit van problemen
(zie Hoofdstuk 5). Ook omstreeks die tijd presenteerde A. Church zijn lambda calculus|hoewel de
publicatie van de lambda caluculus pas rond 1940 geschiedde gaf Church er zeker in 1936 al college
over in Princeton, en zijn artikel A note on the Entscheidungsproblem verscheen in 1936 in het
eerste deel van de Journal on Symbolic Logic. Overigens werden beide benaderingen al in minder
toegankelijke teksten rond 1920 door Emil Post neergeschreven, die ook rond die tijd een versie
van de onvolledigheidsstelling van G(cid:127)odel in een brief aan Church neerschreef. Post was echter niet
tevreden over dit enkele, op zichzelf staande resultaat, en wilde eerst een meer algemene theorie
maken.

Wanneer een voorschrift om met een reeks eenvoudige stappen van probleemstelling naar op-
algoritme" kreeg is onbekend. Wel leeft het sterke
lossing te komen in het algemeen de naam
"
vermoeden dat het woord afkomstig is van het Engelse
algorism" dat de aanduiding is voor het
"
systeem arithmetische berekening in het decimale systeem. Dit woord is weer een verbastering van
het Latijnse woord Algoritmi dat de latinizering is van de naam van Abu Ja’afar Abdullah Mu-
hammad Ibn M(cid:22)us(cid:22)a al-Khaw(cid:22)arizm(cid:22)(cid:16), auteur van het boek Al-(cid:20)gabr, een verzameling van truuks om
met het Hindu getallensysteem om te gaan, vertaald in het latijn als Algoritmi de numero Indorum.
algoritme"
Al-(cid:20)gabr heeft overigens de weg naar onze taal gevonden in de vorm Algebra. Omdat
"
oorspronkelijk dus de naam van een man is, zullen we in deze tekst consequent spreken van
de
"
algoritme", in tegenstelling tot van Dale die het wegens gebrek aan historisch besef heeft over
het
"
algoritme".

Voor problemen zijn er algoritmen die tot een oplossing leiden. Soms zijn dit eenvoudige algorit-
men die op de achterkant van een sigarendoos kunnen worden uitgevoerd, soms zijn alle computers
in de wereld [CDRH+96] nodig om de berekening uit te voeren. Soms kunnen algoritmen binnen
enkele ogenblikken tot resultaat leiden|bijvoorbeeld bij het traceren van subatomaire deeltjes.
Soms kan een algoritme jaren nodig hebben voordat het resultaat bereikt wordt|bijvoorbeeld bij
het ontcijferen van geheim- of onbekend [Par99] schrift. Ook is er voor hetzelfde probleem een
grote, vaak oneindige verzameling algoritmen, waarvan de meeste onbekend zijn. Als er een algo-
ritme voor een probleem gevonden is, is niet altijd met zekerheid te zeggen of er niet een e(cid:14)ci(cid:127)ente,
betere algoritme voor hetzelfde probleem bestaat. De complexiteit van een algoritme kunnen we
onderzoeken. Een probleem ontleent zijn complexiteit aan alle algoritmen die voor dat probleem
bestaan, en dus is de complexiteit van een probleem een lastiger onderwerp. We beginnen daarom
met de complexiteit van algoritmen.

14

1.2 Analyse van Algoritmen

In dit boek zijn we ge(cid:127)(cid:16)nteresseerd in algoritmen waarmee problemen kunnen worden opgelost. Als
we een algoritme hebben bedacht, dan willen we graag weten hoe duur het uitvoeren van zo’n
algoritme is. Hoeveel tijd en geheugen kost het uitvoeren van zo een algoritme. Voordat we daar
iets over kunnen zeggen, moeten we eerst afspreken wat een algoritme is, en hoe we de kosten van
een algoritme gaan berekenen.

Een algoritme is een plan waarmee een computer een probleem kan oplossen. Je kunt een
algoritme zien als een programma. Het verschil is dat een programma meestal expliciet in (cid:19)e(cid:19)en of
andere programmeertaal zegt wat een machine moet doen, terwijl een algoritme een veel globalere
beschrijving is van de stappen die moeten worden uitgevoerd. In deze tekst beperken we ons wel tot
beschrijvingen die inderdaad gaan over de stappen die moeten worden uitgevoerd. Elke algoritme die
hier gepresenteerd wordt is een recept dat stap voor stap naar een oplossing van het probleem leidt.
De algoritmen kunnen nader gespeci(cid:12)ceerd worden in (cid:19)e(cid:19)en of andere programmeertaal en worden
dan programma’s, die stap voor stap tot een oplossing leiden. Er zijn in de informatica ook andere
manieren om tegen problemen die door computers worden opgelost aan te kijken. Voorbeelden
hiervan zijn, onder toepassing van enige simpli(cid:12)catie:

Descriptieve programmering. Je geeft de speci(cid:12)catie van het probleem en het systeem zoekt
naar een oplossing. Voorbeelden hiervan zijn logisch programmeren en constraint program-
ming.

Functionele programmering. Je geeft de beschrijving van het probleem in termen van functies
en het systeem zoekt naar de juiste waarden.

Parallel programmeren. Er worden verschillende algoritmen (of dezelfde algoritme meerdere
keren) tegelijkertijd uitgevoerd, al dan niet met onderlinge communicatie.

Quantum computing. Verschillende stromen van de een algoritme worden in superpositie
uitgevoerd. Door interferentie en state collapse wordt de juiste oplossing overgehouden.

Deze alternatieve vormen zullen we hier niet bespreken. Ons gaat het alleen om de klassieke vorm
van de algoritme die stap voor stap wordt uitgevoerd, waarbij soms beslissingen worden genomen
door het systeem, maar waarbij het systeem nooit over zo’n beslissing hoeft na te denken. Elke
stap kan dus zonder , al dan niet kunstmatige, intelligentie worden uitgevoerd.

1.2.1 Meten is weten

De eenvoudigste vorm van het onderzoeken hoe duur een bepaalde algoritme is, is natuurlijk het
gebruik van de stopwatch. We schrijven een programma voor het oplossen van een bepaald probleem
voor een bepaalde computer, en drukken vervolgens voor en na het uitvoeren van het programma de
stopwatch in en kijken dan hoeveel tijd er is verstreken. De meeste operating systems hebben hier
wel een speciale functie voor en ook in de meeste programmeertalen kan direct naar de systeemklok
worden gekeken. Om een indruk te krijgen van de e(cid:14)cientie van een algoritme is deze methode zeer
bruikbaar. We kunnen de gebruikte tijd op een aantal vraagstellingen, ook wel instanties van een
probleem genoemd, meten en vervolgens uitzetten in een gra(cid:12)ek. Door zo’n gra(cid:12)ek door te trekken,
kunnen we vaak ook voorspellingen doen over hoe de algoritme zich zal gedragen op andere, niet
geteste instanties. Dat heet extrapolatie.

15

Een voordeel van deze methode is dat ze eenvoudig uit te voeren is en direct resultaat geeft.
Een nadeel is dat je meestal veel instanties moet bekijken om zinnige voorspellingen over het gedrag
van de algoritme te doen en dat deze testmethode dus tijdrovend is. Een ander nadeel is dat bij
gebleken ongeschiktheid (de algoritme is te traag) helemaal niet duidelijk is wat de oorzaak van die
ongeschiktheid is. Deugt de hele aanpak niet, of is een bepaald onderdeel van het programma veel
te lang bezig? Tenslotte zijn extrapolaties natuurlijk altijd onzeker.

1.2.2 Voorspellen is beter

Als je toch een beschrijving van de algoritme hebt voordat je begint, kun je misschien eens kijken
of je vantevoren een schatting kunt maken van het aantal stappen dat die algoritme gaat doen om
je probleem op te lossen. Als je dan weet hoeveel tijd een enkele stap duurt, kun je het aantal
stappen gewoon met de stapduur vermenigvuldigen om een tijdsduur voor de hele uitvoering te
krijgen. Laten we dit eens verduidelijken aan de hand van een overbekend voorbeeld.

Stel ik wil het telefoonnumer van een vriend opzoeken in een telefoonboek. Het telefoonboek
bevat ongeveer 25000 namen, gesorteerd op alfabet. Er zijn verschillende manieren om dat te doen.
Als ik geen ervaring heb met zoeken, zal ik mogelijk op bladzijde 1 beginnen en dan net zolang
de bladzijden omslaan totdat ik de naam van mijn vriend gevonden heb. Deze methode heet in
de algoritmiek linear search en wordt door vrijwel niemand voor het opzoeken van een naam in
een telefoonboek gebruikt (waarom?). Toch zijn er situaties denkbaar waarin linear search de best
mogelijke algoritme is.

We zien onmiddelijk dat het aantal namen dat zo de revue passeert zeer afhankelijk is van de
naam van onze vriend. Als deze naam met een A begint, zullen we zeer veel minder tijd kwijt zijn
dan wanneer deze naam met een Z begint. Erger nog is het als de naam niet in het boek voorkomt
(geheim nummer). We zullen dan alle 25000 namen voorbij zien komen om uiteindelijk gefrustreerd
te worden. Gemiddeld zullen wel ergens in het midden eindigen, dwz ongeveer 12000 namen moeten
onderzoeken. Toch is er maar 1 naam waarvoor we precies 12000 namen moeten bekijken voordat
de algoritme" los
we hem gevonden hebben. De vraag is nu: wat beschouwen we als kosten van
"
van de precieze naam die we zoeken. De algoritme is tenslotte de methode
begin bij bladzijde 1
"
en zoek in volgorde totdat je de naam vindt" en van die algoritme willen we graag de kosten weten
zonder te hoeven zeggen om welke naam het precies gaat.

Verschillende Gevallen van Analyse

Uit het bovenstaande blijkt al dat er een aantal verschillende antwoorden op de vraag
hoeveel kost
"
de algoritme" mogelijk is. Drie antwoorden worden vaak onderscheiden: de worst case, de best case
en de average case.

We kunnen antwoorden:
heet worst case analyse

25000 stappen". In het ergste geval lopen we de hele lijst door. Dit
"

We kunnen antwoorden:
1 stap". In het gunstigste geval vinden we de naam onmiddellijk.
"
Dat heet best case analyse

We kunnen antwoorden:
12500 stappen". Er zijn net zoveel namen die minder dan 12500
"
stappen kosten als namen die meer kosten (aangenomen dat alle namen in het telefoonboek
staan). Dit heet average case analyse

16

De best case analyse komt niet zo vaak voor, omdat deze voorspelling niet zoveel waarde heeft. De
average case analyse komt ook niet zo vaak voor omdat deze vorm van analyseren vaak moelijker
is en bovendien ook afhankelijk van wat voor kansverdeling er voor onze invoer geldt. Namen die
beginnen met ‘A’ komen in de praktijk veel vaker voor dan namen die beginnen met ‘Q’ en het is
helemaal niet waar dat alle namen in het telefoonboek voorkomen. We zullen ons dus voornamelijk
bezighouden met worst case analyse. In de worst case doet onze aanpak dus net zoveel stappen als
er namen in het telefoonboek staan. Als elke vergelijking 0,025 seconden kost, dan betekent dat
dus in dit geval de de algoritme 625 seconden doet over het vinden van een willekeurige naam.

Wat is een Stap?

25.000 stappen", en we bedoelen met (cid:19)e(cid:19)en stap (cid:19)e(cid:19)en vergelijking
In onze analyse hebben we het over
"
van de gezochte naam met een naam in het telefoonboek. In werkelijkheid gebeurt er natuurlijk
veel meer. De (cid:12)le met namen moet worden geopend en gesloten, de namen worden niet in (cid:19)e(cid:19)en
stap vergeleken, maar letter voor letter, er moet een teller bijgehouden worden die zegt of we al
aan het einde van het telefoonboek zijn gekomen en nog veel meer. Toch is het zinvol om voor de
complexiteit van de algoritme te tellen hoeveel keer twee namen met elkaar worden vergeleken en de
rest te verwaarlozen. Dat komt omdat het vergelijken van twee namen in deze algoritme het vaakst
voorkomt. Elke andere operatie komt minder vaak voor. Verder is het aantal lettervergelijking dat
per naamvergelijking wordt uitgevoerd begrensd door de lengte van de naam die we zoeken. Als we
dus alle operaties bij elkaar zouden optellen, dan is er een (constant) getal zodat de totaal aantal
operaties begrensd wordt door dit constante getal keer het aantal naamvergelijkingen. Verder is
elke individuele operatie te vergelijken met elke andere individuele operatie doordat er een ander
constant getal is dat het verschil in tijd nodig om die operaties uit te voeren aangeeft (bijvoorbeeld
vermenigvuldigen van twee 8-bits getallen kan 10 keer zo duur zijn als het optellen van twee 8-bits
getallen). Tot slot verschillen computers die we willen bekijken nog van elkaar doordat elementaire
operaties op de ene computer een (constant) aantal keren sneller kunnen worden uitgevoerd. Als we
dus willen weten hoe lang het zoeken in werkelijke tijd kan gaan duren, dan kunnen we aan de hand
van het aantal naamsvergelijkingen daarvoor een goede bovengrens krijgen door dat aantal met de
juiste constanten te vermenigvuldigen. Als we een algoritme willen analyseren zoeken we dus vaak
een operatie die minstens net zo vaak wordt uitgevoerd als alle andere. Het kan zijn dat dat voor
verschillende delen van de algoritme een andere moet zijn, bijvoorbeeld als we eerst gaan sorteren
en dan zoeken, maar dan tellen we de complexiteit van de verschillende delen van de algoritme
gewoon bij elkaar op. Van deze operatie, die in Engelse teksten vaak barometer genoemd wordt,
maar die we hier bij gebrek aan een betere naam voorlopig maar
spil" zullen noemen, geven we
"
een (boven)schatting voor hoe vaak zij wordt uitgevoerd, en dat is dan een maat voor de kosten
van de algoritme.

Samengevat zijn de stappen in de analyse van een algoritme dus:
(cid:15) Verdeel de algoritme en een aantal samenhangende delen (bijvoorbeeld loops).
(cid:15) Zoek binnen elk deel een elementaire operatie die het vaakst wordt uitgevoerd, en tel het

aantal keren dat die wordt uitgevoerd.

(cid:15) De (worst-case) complexiteit van zo’n deel is een constante maal het aantal keren dat die

elementair operatie wordt uitgevoerd.

(cid:15) De (worst-case) complexiteit van de algoritme is een constante maal de worst-case complexiteit

van het duurste onderdeel.

17

Verderop in de tekst zullen we een handige notatie, de O-notatie voor deze complexiteit invoeren.

Verschillende Algoritmen, verschillende complexiteit

De analyse van algoritmen levert een vergelijking tussen verschillende methoden die we kunnen
gebruiken om voor een probleem de beste algoritme te kiezen. In een geval als het bovenstaande
kunnen we gebruik maken van het feit dat de lijst namen gesorteerd is, om een aanzienlijk snellere
algoritme te krijgen. Deze methode heet binary search en gaat als volgt: Vergelijk de naam die
je zoekt met de naam die in het midden van het boek staat, en deel vervolgens het boek in twee
delen. Als de naam die je zoekt groter is dan de naam die je tegenkomt gebruik je vervolgens het
tweede deel en anders het eerste deel. Dit in twee(cid:127)en delen herhaal je totdat je nog (cid:19)e(cid:19)en naam over
hebt. Als dat de naam is die je zoekt, dan heb je hem gevonden en anders staat die naam niet in
het boek. Deze methode doet in een telefoonboek van 25000 stappen maximaal slechts 15 stappen
(de 2-logaritme van 25000, naar boven afgerond) een dramatische verbetering.

Binary search maakt gebruik van een eigenschap van de invoer die het zoeken makkelijk maakt,
namelijk dat de invoer alfabetisch gesorteerd is. Deze eigenschap is, zeker voor mensen, noodzakelijk
bij een zo grote lijst omdat deze anders onhanteerbaar wordt. De eigenschap kan echter niet van
elke lijst voorondersteld worden en is ook niet altijd nodig. Als de lijst met namen niet groter dan
vijf is bijvoorbeeld lijkt het weinig zinvol eerst de lijst te gaan sorteren om het zoeken makkelijker te
maken. Lineair zoeken in zo’n lijst kost namelijk vijf vergelijkingen en binair zoeken kost maximaal
drie vergelijkingen. Sorteren van zo’n lijst kan, afhankelijk van de gebruikte sorteeralgoritme, wel
20 vergelijkingen kosten. Wanneer is het gewenst de lijst te sorteren?

Mengvormen en een Nieuwe Analyse

Als we een grote ongesorteerde lijst hebben, dan kan het voordelig zijn de lijst eerst te sorteren.
Een lijst van 25000 namen sorteren kan met ongeveer 375000 vergelijkingen worden gedaan. Dat is
natuurlijk duur, maar het voorwerk dat we gedaan hebben, winnen we terug omdat elke volgende
opzoekactie hoogstens 15 vergelijkingen kost in plaats van de gemiddeld 12500 vergelijkingen in
de ongesorteerde lijst. Na ongeveer 31 keer een naam opzoeken hebben we de voorinvestering van
375000 vergelijkingen weer terugverdiend. Gemiddeld (average case) is het dus voordeliger de lijst
eerst te sorteren en dan de gesorteerde lijst te gebruiken, dan te werken met de ongesorteerde lijst.
Wat als er maar (cid:19)e(cid:19)en opzoekactie plaatsvindt? Dan is het onzin om te investeren in het sorteren
van de lijst. Dus analyse van het gemiddelde geval is alleen zinvol als we zeker weten dat er veel
goedkope acties worden uitgevoerd, die tegen de dure acties kunnen worden weggestreept.

Uitgesmeerde kosten Er is een methode die dat zeker maakt, namelijk: voer altijd eerst een
heel stel goedkope acties uit voordat een dure actie wordt uitgevoerd. Een voorbeeld uit de praktijk
hierbij is het huren van ski’s. Het kopen van ski’s is relatief duur, maar als je ski’s koopt en je
gaat vaak ski(cid:127)en haal je dat er op den duur uit. Als je ski’s koopt en je gaat niet vaak|omdat je
het niet leuk vindt, of omdat er geen sneeuw valt|zijn gekochte ski’s relatief duur. De oplossing
voor dit probleem is eerst ski’s te huren, net zolang totdat je het bedrag hebt uitgegeven dat ski’s
in de winkel kosten. De volgende keer koop je ze. Op deze manier hoef je per skigelegenheid nooit
m(cid:19)e(cid:19)er dan twee keer de optimale prijs te betalen, hoe vaak je ook gaat. In ons geval zouden we ons
kunnen voorstellen dat de lijst met namen in het telefoonboek niet altijd heel groot is, maar leeg
begint en langzaam groeit. Een opzoekactie zou dan, zo lang de lijst klein genoeg is gewoon lineair

18

zoeken kunnen zijn en alleen als de lijst onhanteerbaar groot wordt, zouden we kunnen besluiten
eerst de lijst te sorteren.

Deze aanpak garandeert ons dat we eerst een heleboel goedkope acties hebben uitgevoerd (lineair
zoeken in een kleine lijst; nieuwe namen ongesorteerd achter aan de lijst plakken) voordat we een
dure operatie (sorteren) uitvoeren om nieuwe zoekacties goedkoper te maken. Als we dan een dure
gesorteerde lijst hebben, kunnen nieuwe opzoekoperaties snel en nieuwe invoegoperaties kunnen
we weer doen met een kleine ongesorteerde lijst, net zo lang tot die lijst weer onhanteerbaar groot
wordt. Vervolgens kunnen we de twee lijsten weer samenvoegen tot een nieuwe, grotere, gesorteerde
lijst.

De analyse waarbij we de kosten van een dure operatie uitsmeren over goedkopere eerdere
operaties heet uitgesmeerde-kostenanalyse (in Engelse teksten amortized case analysis). Ze wordt
veel gebruikt als er datastructuren in het spel zijn die het zoeken vereenvoudigen. Bijvoorbeeld:
zoekbomen kunnen scheefgroeien door toevoegen van data en sommige zoekacties kunnen daardoor
zeer duur worden. Een zoekboom kan gebalanceerd worden, maar dat is een dure operatie en die
moet dus nuttig zijn. We beginnen vrijwel altijd met niets (lege zoekboom), en kunnen dan goedkope
invoegacties en zoekacties doen net zolang tot de boom te groot en te scheef wordt om zoekacties
nog goedkoop te kunnen doen. De volgende stap is dan het balanceren van de boom. Hashtabellen
worden op een bepaalde grootte ge(cid:127)(cid:16)nitialiseerd om een aantal records te kunnen opslaan. Als het
aantal records groter wordt dan de tabel, moet deze worden uitgebreid, maar een uitbreiding van
de tabel met (cid:19)e(cid:19)en veld is een dure operatie. Analyse van dit geval leert dat het voordelig is om
de tabel, als hij te groot wordt, meteen maar twee keer zo groot te maken, en, symmetrisch, als
er records verdwijnen, de tabel te halveren als het aantal records 1/4 van het maximaal mogelijke
aantal is (de lezer kan hier gemakkelijk inzien waarom voor 1/4 in plaats van voor 1/2 gekozen is).
Een ander, misschien niet zo realistisch, maar wel inzichtelijk voorbeeld is dat waarbij we een
element op een bepaalde plaats in een stapel willen invoegen (waarbij dan de stapel verandert). We
moeten eerst een aantal elementen van bovenaf de stapel halen, om vervolgens het nieuwe element
op de resterende stapel te zetten. De verwijderde elementen worden niet meer teruggezet. Elke
operatie kan ons dwingen om de stapel leeg te maken. Een worst-case analyse zou dus zeggen dat
elke operatie op een stapel van grootte n maximaal n stappen kan kosten, maar het afstapelen
maakt de maximale kosten voor volgende afstapeloperaties kleiner! Elke operatie houdt een aantal
keren afstapelen en een keer opstapelen in, maar in een rij van n van deze operaties, kan het totaal
van de afstapeloperaties niet meer dan n zijn, omdat elk element maar (cid:19)e(cid:19)en keer afgestapeld kan
worden, en dat geld voor elke n. Een totaal van n van deze operaties, kan zo niet meer dan 2n
stappen kosten, dus elke stap kan niet meer dan 2 operaties kosten, als we kosten dure stappen over
vorige goedkopere stappen mogen uitsmeren.

De hier gepresenteerde analyse (ook wel

aggregate analysis" genoemd) is een vrij gro(cid:11)e vorm
"
van analyseren: tel alle operaties bij elkaar op en deel door het aantal operaties. Dat is natuurlijk
toegestaan, maar wijst niet deze vorm van uitgesmeerde complexiteit precies aan goedkope en dure
operaties toe. Hieronder zullen we twee methode van analyse bespreken die dat wel doen, en
daardoor nauwkeuriger zijn.

Een voorbeeld van Uitgesmeerde Complexiteit

We kunnen het verschil tussen worst-case analyse en amortized-case analyse zien door naar een
binaire teller te kijken. Stel we hebben een binaire teller van k plaatsen en we willen met deze teller
tellen tot 2k. Hoeveel kost dat? Laten we eerst een worst-case analyse doen. Een teller heeft k bits.

19

stap
1
2
3
4
5
6
7
8

teller
00001
00010
00011
00100
00101
00110
00111
01000

kosten
1
2
1
3
1
2
1
4

saldo
1
1
2
1
2
2
3
1

potentiaal
1
1
2
1
2
2
3
1

stap
9
10
11
12
13
14
15
16

teller
01001
01010
01011
01100
01101
01110
01111
10000

kosten
1
2
1
3
1
2
1
5

saldo
2
2
3
1
2
2
4
1

potentiaal
2
2
3
2
3
3
4
1

Figuur 1.1: Uitgesmeerde complexiteit

Als spil voor deze algoritme zullen we de bit(cid:13)ip gebruiken. Als de teller (cid:19)e(cid:19)en keer wordt opgehoogd,
dan zal dat dus ten hoogste k bit(cid:13)ips kosten. De teller wordt maximaal 2k keer opgehoogd, dus de
totale kosten zullen begrensd blijven door k (cid:2) 2k. De worst-case analyse is eenvoudig, maar geeft
geen re(cid:127)eel beeld van de werkelijke kosten. Immers niet in elke stap worden k bits ge(cid:13)ipt. Sterker
nog, in de helft van de gevallen wordt maar (cid:19)e(cid:19)en bit ge(cid:13)ipt. In een kwart van de gevallen worden
slechts twee bits ge(cid:13)ipt en in 1/8 van de gevallen 3 bits. Als we simpel tellen wat het totaal aantal
2k (cid:2)k.
bit(cid:13)ips in alle 2k gevallen is, dan komen we tot de volgende som 2k
Dit is een bekende reeks. In Sectie 1.4.3 waarin we onze kennis over het manipuleren van reeksen
opfrissen, zullen we zien dat deze reeks voor elke k begrensd is door 2 (cid:2) 2k en dat dus gemiddeld
het aantal bit(cid:13)ips dat bij (cid:19)e(cid:19)en keer ophogen van de teller kan worden afgeschat met 2 in plaats van
k (cid:13)ips. Om te bewijzen dat ook de uitgesmeerde complexiteit van de bit(cid:13)ips begrensd wordt door
2 moeten we aantonen dat dat ook het geval is als de teller niet 2k keer wordt opgehoogd, maar
ergens tussen de 1 en de 2k keer. Hiervoor zijn een tweetal truuks bedacht, de
bankrekening" en
"
de

potentiaal". Omdat deze truuks vaak gebruikt worden, spreekt men van
"

8 (cid:2)3+: : :+ 2k

methoden".
"

4 (cid:2)2+ 2k

2 (cid:2)1+ 2k

De bankrekening

Een oerhollandse methode om voorbereid te zijn op onverwachte uitgaven is sparen. Zo kunnen
we ook de uitgesmeerde complexiteitsanalyse opvatten. In de Engelse teksten wordt deze analyse
aangeduid met amortized complexity, wat associaties oproept met hypotheken. In het geval van
hypotheken vindt echter altijd eerst een grote lening plaats, waardoor de spaaranalogie misschien
een betere is voor deze vorm van analyse. We weten uit de telpartij hierboven dat over een totaal
van 2k verhogingen van de teller niet meer dan 2 (cid:2) 2k bit(cid:13)ips gemaakt worden of, gemiddeld, niet
meer dan 2 per verhoging. Stel nu dat we voor elke verhoging 2 operaties in rekening brengen in
plaats van het werkelijke aantal operaties. Hebben we dan altijd genoeg
spaartegoed" om voor
"
alle werkelijk uitgevoerde operaties te betalen? Laten we voor een klein geval eens kijken.

Het lijkt erop dat de bankrekening altijd voldoende saldo heeft om de tekorten te dekken als de
twee operaties die we steeds in rekening brengen niet genoeg zijn. Hoe bewijzen we dat? Op dit
punt doet de lezer er misschien goed aan de tekst even terzijde te leggen en over deze vraag na te
denken.

Kijk naar het verloop van het tegoed op de bankrekening. Telkens valt het tegoed terug naar 1,
vlak nadat een groot aantal bits ge(cid:13)ipt zijn. Voor dat moment loopt het tegoed net genoeg op om
voor deze bit(cid:13)ips te kunnen betalen. We zien dat tussen de tijd waarop de meest rechtse i bits op

20

0 staan en de tijd waarop de meest rechtse i bits op 1 staan, het banktegoed precies i groter wordt
dan het daarvoor was.

Hiervan maken we een inductiehypothese: \Als de meest rechtse i bits op 0 staan, dan is het

banktegoed i groter geworden v(cid:19)o(cid:19)or dat de meest rechtse i bits op 1 staan."

Begin met i = 1. Het kost 1 stap om het meest rechtse bit van 0 in 1 te veranderen, en er
worden 2 munten in rekening gebracht. Het banktegoed groeit dus met 1. Neem vervolgens aan
dat de hypothese waar is voor (cid:19)e(cid:19)en of andere i en kijk naar een tijdstip t0 waarop de meest rechter
i + 1 bits op 0 staan. Eerst krijgen we een tijdstip waarop de meest rechter i bits op 1 staan en
het i + 1-e bit nog op 0. Wegens onze aanname is nu het banktegoed i groter dan het was. In de
volgende stap worden 2 munten op de rekening gezet, i munten worden gespendeerd om de meest
rechtse i bits op 0 te zetten, en 1 munt om het i + 1e bit op 1 te zetten, waardoor het banktegoed
precies 1 groter is dan het op t0 was (2 + i (cid:0) (i + 1)). Als de volgende keer de meest rechter i bits
op 1 staan (nu dus op i + 1), dan is het banktegoed i + 1 groter dan het op tijdstip t0 was.

De potentiaalmethode

Een nadeel van de bankrekeningmethode is dat je van tevoren een goed idee moet hebben hoeveel
je voor een operatie moet sparen om hem te kunnen uitvoeren. Een meer dynamische aanpak is
de potentiaalmethode. Deze is afgeleid van de volgende gedachte. Stel ik ben een karretje over een
weg aan het duwen. Elke meter ik a(cid:13)eg kost me een bepaalde hoeveelheid boterhammen (energie).
Als ik het karretje over een vlakke weg duw dan kost elke meter mij evenveel energie. De enige
energie die moet worden toegevoegd, is de energie die door wrijving warmte wordt. Echter, als ik
het karretje een heuvel opduw, dan kosten de heuvelop stappen ineens meer energie, omdat het
karretje potentiaal wint. Al die energie krijg ik volgens de behoudswetten weer terug wanneer het
karretje van de heuvel afrolt, omdat de zwaartekracht dan helpt duwen.
Laten we dit eens vertalen naar de kwestie van uitgesmeerde complexiteit. Stel ik heb een functie
(cid:30)(n) die de potentiaal van de algoritme na de n-de stap voorstelt. Het verschil (cid:30)(n) (cid:0) (cid:30)(n (cid:0) 1) is
de verandering van de potentiaalfunctie tussen stap n (cid:0) 1 en stap n. We nemen aan dat (cid:30)(0) = 0
en dat (cid:30)(n) (cid:21) 0 voor alle n. Laat t(n) het aantal stappen zijn dat in de n-de stap moet worden
^t(n) =

uitgevoerd en de(cid:12)nieer ^t(n) als t(n) + (cid:30)(n) (cid:0) (cid:30)(n (cid:0) 1). Nu geldt voor N stappen PN
PN
n=1(t(n) + (cid:30)(n) (cid:0) (cid:30)(n (cid:0) 1)) = (cid:30)(N ) +PN
n=1 t(n) Dus P ^t(n) is altijd minstens zo groot als
P t(n), dus P ^t(n) is een bovengrens voor het aantal operaties dat gedaan wordt voor elke n.

n=1

Om nu een goede schatting te krijgen voor de uitgesmeerde complexiteit van het probleem hoeven
we slechts een afschatting te maken voor ^t(n) voor een geschikte functie (cid:30). Net zoals het bij de
bankmethode een probleem was om een geschikte inductiehypothese te vinden is het hier natuurlijk
een probleem om een geschikte potentiaalfunctie te vinden. Deze functie moet de eigenschap hebben
dat zij aan het begin 0 is, nooit kleiner dan 0 wordt en altijd voldoende groot is om de kosten op
te vangen. Ongeveer net zoals wanneer we ’s morgens met weinig energie, maar met een volle pot
ko(cid:14)e op het werk aankomen. We kunnen goedkope kopjes ko(cid:14)e uit de pot tappen en daarmee
energie opdoen. Tegen de tijd dat de pot leeg is, hebben we voldoende energie verzameld om de
dure operatie, het zetten van een nieuwe pot, te gaan ondernemen.

In het geval van de binaire teller kiezen we als potentiaalfunctie het aantal bits in de teller dat
op 1 staat en berekenen dan de uitgesmeerde kosten van een stap, ^t. Deze potentiaalfunctie voldoet
aan de eisen. Zij begint met 0, wordt onderweg nooit kleiner dan 0, en als er een dure operatie
nodig is (veel bit(cid:13)ips) dan staan er ook veel bits op 1. Laten we kijken of deze functie ook precies
aan onze behoeften voldoet. Er zijn 3 gevallen: Als er een even getal in de teller zit, dan wordt

21

het rechterbit ge(cid:13)ipt van 0 naar 1 en de potentiaal stijgt met 1, kosten 1 + 1 = 2. Als alle bits in
de teller 1 zijn, dan worden alle k bits ge(cid:13)ipt, maar de potentiaal valt naar 0, kosten k (cid:0) k = 0.
In alle andere gevallen worden er i bits van 1 naar 0 gezet, 1 bit wordt van 0 naar 1 gezet, en de
potentiaal daalt met i (cid:0) 1. De totale kosten zijn dan 1 + i (cid:0) (i (cid:0) 1) = 2.

1.2.3 Sommen

1. De bedoeling van deze som is oefenen met het meten van executieduur van programma’s
waarbij verschillende algoritmen gebruikt worden. Zoals we hierboven al gezien hebben zijn
er verschillende manieren om tegen zoeken en sorteren aan te kijken. We voeren het volgende
experiment uit. Elke keer trekken we een random getal tussen de 1 en de n, voegen dat getal
in, in de structuur die we gemaakt hebben. Dit doen we n keer. Merk op: een getal kan
meerdere keren voorkomen. Vervolgens trekken we m keer een willekeurig getal kleiner dan n
en zoeken dat in het array op. De verschillende gevallen zijn de volgende.

(a) Een ongeordend array. Een nieuw getal wordt steeds achteraan ingevoegd.

(b) Een geordend array. Elke keer als een nieuw getal wordt toegevoegd zetten we het getal

wel achteraan de rij, maar vervolgens wordt de rij gesorteerd met quicksort.

(c) Een geordend array. Elke keer wordt een nieuw getal ingevoegd met insertion sort.

(d) Een mengvorm. We houden het array een tijdlang ongeordend, maar als het aantal

elementen

te groot" wordt, wordt het hele array opnieuw gesorteerd.
"

Implementeer deze gevallen voor verschillende waarden van n en m. Tussen de opdrachten
door roepen we de klok (of time afhankelijk van het gebruikte operating system) aan en
noteren de tijden die met de klokfunctie verkregen worden. Maak een tabel. Voor welke n en
m gaan de verschillen tellen? Waarom verwachtte je dat?

1.3 Asymptotische Grenzen

Vaak zijn we niet zo ge(cid:127)(cid:16)nteresseerd in de kosten van het zoeken van een naam in (cid:19)e(cid:19)en bepaalde
lijst, want als zo’n zoekactie gemiddeld 12500 stappen kost, wat zegt dat dan over de gebruikte
algoritme? We willen graag weten wat zo’n algoritme kost op verschillende instanties van het
probleem. Dus, wat als we in het algemeen een lijst van n namen aan de algoritme geven en we
vragen of een bepaalde naam in die lijst voorkomt. Voor de twee algoritmen uit de vorige sectie
kunnen we zien dat de eerste zoekmethode ongeveer n stappen kost, terwijl de tweede zoekmethode
ongeveer log n stappen kost. Voor steeds groter wordende n zien we dat de eerste zoekmethode dus
een stuk duurder is dan de tweede.

Het is meer informatief te weten hoe een algoritme zich gedraagt op steeds groter wordende
vragen dan op een enkele instantie van een probleem. Met andere woorden: we willen graag zien
hoe het aantal stappen dat een algoritme moet doen om een oplossing te vinden groeit als functie
van de grootte van de vraagstelling. Als een algoritme over een twee keer zo grote vraag twee keer
zo lang doet, vinden we dat in principe geen probleem. Zouden we het wel een probleem vinden als
een algoritme over een twee keer zo grote vraag tien keer zo lang doet? Wat zijn functies die een
redelijke verhouding geven tussen de grootte van de vraagstelling|de lengte van de invoer|en de
grootte van het probleem? Laten we, als voorbeeld, eens kijken naar hoeveel tijd er gemoeid is met

22

# stappen
1.000
1.000.000
10.000.000
100.000.000
1.000.000.000
10.000.000.000
100.000.000.000
1.000.000.000.000
10.000.000.000.000
100.000.000.000.000
1.000.000.000.000.000
10.000.000.000.000.000
100.000.000.000.000.000
1.000.000.000.000.000.000.
10.000.000.000.000.000.000

commentaar

tijd
0.0001 sec
0.001 sec
0.01 sec
0.1 sec waarneembaar

onzichtbaar

1 sec
10 sec
100 sec
16.7 min

ko(cid:14)e
praatje
2uuur 47 min GRRR
geduld?
opgeven?

27 uur
11.25 dagen
4 maanden
3.33 jaar
33 jaar
3.3 eeuwen

Figuur 1.2: Tijd versus aantal stappen op een 1GIPS processor

het doen van een aantal stappen op een machine die 109 bewerkingen per seconde kan uitvoeren
(1GIPS). Zie Figuur 1.2.

Als we een machine, al is die nog zo snel, maar voldoende werk geven, wordt de werktijd vanzelf
onacceptabel lang. Een tegenwerping zou kunnen zijn dat in de dagelijkse praktijk een berekening
die 1020 operaties kost niet voorkomt. Dit is echter een misvatting die veel met algoritmiek te
maken heeft. Laten we eens naar een voorbeeld kijken waar de keuze van de verkeerde algoritme
kan leiden tot excessief processorgebruik, de berekening van Fibonacci getallen, genoemd naar de
Italiaanse wiskundige Leonardo Pisano (1170{1250), bijgenaamd Fibonacci.

In zijn boek

Liber Abaci" beschrijft Fibonacci een groot aantal problemen interessant voor
"

koopmannen. E(cid:19)en van deze problemen is het volgende:

Een bioloog zet een paar konijnen in een afgesloten ruimte. Hoeveel paren konijnen
heeft zij na een jaar, aangenomen dat elk paar elke maand een nieuw paar produceert,
dat zelf na de tweede maand productief wordt?

De oplossing is de overbekende Fibonaccireeks of rij van Fibonacci 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; : : :
(Fibonacci zocht het twaalfde element van deze rij). Hier gaat het ons niet om het vinden van
de oplossing, maar om hoeveel stappen het op een computer kost om de oplossing te vinden. Een
programmeur kan zich er toe laten verleiden te observeren dat het n-de Fibonaccigetal kan worden
gevonden door de twee vorige bij elkaar op te tellen. Zij schrijft een programma als volgt.

1: F(n)
2: if n = 1 or n = 2 then
3:
4: else
5:
6: end if.

return(1);
return(F (n (cid:0) 1) + F (n (cid:0) 2));

23

n2
n
10
100
20
400
40
1600
80
6400
104
100
500 2:5 (cid:2) 104
106
1000

n3
103
8 (cid:2) 103
6:4 (cid:2) 103
5:12 (cid:2) 105
106
1:25 (cid:2) 108
109

2n
1024
1:04 (cid:2) 106
1:1 (cid:2) 1012
1:2 (cid:2) 1024
1:2 (cid:2) 1030
3:2 (cid:2) 10150
1:7 (cid:2) 10301

3n
59049
3:48 (cid:2) 109
1:2 (cid:2) 1019
1:4 (cid:2) 1038
5:1 (cid:2) 1047
3:6 (cid:2) 10238
1:3 (cid:2) 10477

n!
3628800
2:43 (cid:2) 1018
8:2 (cid:2) 1047
7 (cid:2) 10118
9:3 (cid:2) 10157
1:2 (cid:2) 101134
4 (cid:2) 102567

10
20
40
80
100
500
1000

Figuur 1.3: Functies en aantallen operaties

Als wij ons afvragen hoeveel rekenstappen zo’n programma kost, dan zien we dat we om het
100e getal uit te rekenen moeten weten wat het 99e en het 98e getal is, en dat we daarvoor moeten
berekenen wat het 97e en het 96e getal is enzovoort. In dit programma echter wordt het 98e getal
twee keer uitgerekend, zowel in de berekening van het 100e getal als van het 99e getal, en beide
berekeningen roepen zelf weer twee andere berekeningen aan. Elke berekening zal de berekening van
twee andere getallen vereisen, behalve als n = 1 of n = 2. De berekening van het 100e Fibonacci
getal zal met dit programma ongeveer 2100 stappen kosten (we zullen dit verderop nog precies
maken), en omdat 210 ongeveer 103 is, zijn dit 1030 operaties, een aantal dat ons op pagina 23 nog
onrealistisch voorkwam. In het geval van de Fibonacci-getallen is het niet de aard van het probleem
dat de oplossing ingewikkeld maakt. Immers, als we onthouden dat het derde (cid:12)bonacci getal 2 is in
plaats van dat telkens weer uit te rekenen, hebben we
slechts" 100 tussenresultaten nodig, die elk
"
uit de twee voorgaande opgeslagen tussenresultaten kunnen worden berekend, dus er zijn slechts
ongeveer 200 stappen nodig om het 100e Fibonacci-getal te berekenen.

Het verschil tussen de beide bovenbeschreven algoritmen is het verschil tussen een algoritme
met exponenti(cid:127)ele (2n) looptijd versus een algoritme met lineaire 2 (n) looptijd. Het beantwoorden
van een vraag van grootte n kost in het eerste geval 2n en in het tweede geval slechts n stappen.
Het verschil in aantal stappen voor verschillende waarden van n en een aantal van deze functies
wordt in Figuur 1.3 nog eens duidelijk gemaakt.

We zien aan deze tabel dat voor betrekkelijk kleine vragen (1000 bits is natuurlijk helemaal
niet zo groot) een algoritme die loopt in tijd n! op onze eerdere 1 giga(cid:13)ops machine onevenredig
veel tijd in beslag neemt. Computers worden echter steeds sneller en het is doorgaans slechts een
kwestie van een paar maanden voordat er een computer is die twee keer zo snel is. Dit verschijnsel
wordt Moore’s law genoemd (al gaat Moore’s law eigenlijk meer over dichtheid van chips dan over
snelheid). Toch zijn er op verschillende manieren grenzen aan te geven aan de snelheid die door
machines bereikt kunnen worden. In de eerste plaats is er de lichtsnelheid, en het feit dat om een
waarneembaar verschil tussen 0 en 1 te hebben, een elektronische schakeling bepaalde minimale
afmetingen moet hebben. Hieruit kan worden afgeleid dat een machine die een algoritme uitvoert
waar de ene stap de andere moet opvolgen nooit meer dan ongeveer 1035 stappen per seconde zal
kunnen doen. Voor deze machine en invoeren van 1000 bits, toont de tabel aan dat de tijd die
deze machine moet gebruiken om een oplossing te vinden, voor een algoritme die bijvoorbeeld n!
stappen doet, onacceptabel groot is.

In de tweede plaats is er een veel eerder bereikte grens, die van de energiedissipatie. Als een

2Strikt genomen kan de vraag:

uitvoeren van n stappen betekent dus in de lengte van de invoer nog steeds exponenti(cid:127)ele tijd. Meer hierover later.

Wat is het n-de Fibonacci getal?" in ongeveer log n bits worden gesteld. Het
"

24

machine een oplossing vindt voor de optelling 1 + 1, dan is met het vervangen van de vergelijking
door de oplossing, 2, de informatie waar deze oplossing vandaan komt verloren. De berekening is
onomkeerbaar . Dit informatieverlies of toename van de entropie heeft ontwikkeling van warmte tot
gevolg. Deze warmte moet ergens naartoe, en wel naar buiten door de oppervlakte van de chip.
Een manier om deze energiedissipatie te verminderen is het verlagen van de voedingsspanning van
de chip. Hoe lager de voedingsspanning echter, hoe moeilijker het verschil tussen 0 en 1 te zien is
en dus hoe eerder er fouten optreden. De huidige voedingsspanning van ongeveer 5V lijkt dicht bij
de grens te liggen van wat haalbaar is. Een tegenwoordig in de belangstelling staande aanpak van
dit probleem is die van de omkeerbare berekening. In plaats van tussenresultaten weg te gooien
kunnen ze ook bewaard blijven zodat van de uitvoer terug kan worden gerekend naar de invoer.
Deze aanpak blijkt ook in de praktijk aanleiding te geven tot lagere energiedissipatie.

Hoewel het in de industrie al een tijdje niet meer zo erg hard gaat, vooral vanwege het energie-
dissipatieprobleem (laptop computers zijn de laatste tijd zelfs weer langzamer geworden), heeft het
niet veel zin om bij het afschatten van de complexiteit van een probleem te kijken naar factoren als
2, of in het algemeen naar constante factoren. Immers, je moet dan altijd precies zeggen over welke
computer het gaat. Er zijn nog andere, meer theoretische redenen om constante factoren in de
berekening van de complexiteit van een probleem te verwaarlozen. Onder andere is er de
constant
"
factor speedup" stelling uit de automatentheorie die zegt dat voor een bepaalde algoritme en een
bepaalde constante altijd een machine te maken is die die algoritme die constante sneller uitvoert.
We gaan hier in deze tekst niet dieper op in. Vaak gaat het in de algoritmiek erom een constante
in de exponent aan versnelling te winnen, bijvoorbeeld om een algoritme die in tijd n3 loopt te
verbeteren tot een algoritme die in tijd n2 loopt. Voor elke constante winst kunnen we in dergelijke
gevallen natuurlijk n groot genoeg kiezen om het e(cid:11)ect van de constante winst te doen verbleken.
In het algemeen zullen we problemen waarvan de rekentijd begrensd wordt door (cid:19)e(cid:19)en of ander

polynoom e(cid:14)ci(cid:127)ent oplosbare problemen noemen. Dit heeft verschillende redenen.

(cid:15) In de eerste plaats blijkt dat in de praktijk voorkomende problemen waarvoor polynomiale
algoritmen bestaan bijna altijd problemen zijn waarvoor algoritmen met polynomiale grenzen
bestaan met een kleine exponent (2,3,4 heel soms 5) en deze algoritmen (zie tabel 1.3) gedragen
zich op redelijke computers redelijk, dwz. vragen van niet al te grote omvang kosten niet al
te veel stappen.

(cid:15) In de tweede plaats hebben polynomen de eigenschap dat ze zich laten samenstellen en dat
de samenstelling weer een polynoom is. (Onthoud: een polynoom van een polynoom is een
polynoom). Dus hebben we twee bewerkingen die polynomiale tijd begrensd zijn, dan kunnen
we, ook omdat in polynomiale tijd niet meer dan polynomiaal veel bits als uitvoer gegenereerd
kunnen worden die bewerkingen achter elkaar op de invoer loslaten, waarbij het totaal van de
bewerkingen toch e(cid:14)ci(cid:127)ent blijft.

(cid:15) In de derde plaats groeien polynomiaal begrensde algoritmen niet al te veel met de groei van
de vraagstelling. Dat blijkt al uit de tabel die we hierboven presenteerden, maar ook, als de
probleemstelling met een constante groeit (zeg verdubbelt), dan groeit het polynoom ook met
een constante (zie: (2x)k = 2kxk).

(cid:15) Polynomiale tijd is een ondergrens voor machinemodel onafhankelijk redeneren. We zullen in
het tweede deel zien dat theoretische modellen voor machines die van praktische voorbeelden
zijn afgeleid elkaar kunnen simuleren in polynomiaal begrensde tijd. Dwz. wat de ene machine
in n stappen kan uitvoeren kan de andere machine in nk stappen uitvoeren voor (cid:19)e(cid:19)en of andere

25

constante k. Wil je het dus in je redenering niet over een speci(cid:12)eke machine of speci(cid:12)ek
machinemodel hebben, dan zul je alle polynomen als grenzen op (cid:19)e(cid:19)en hoop moeten gooien.

(cid:15) Je zou kunnen beweren dat lineaire tijd (probleemgrootte n kost n stappen) een ondergrens
is voor een algoritme, omdat elke algoritme tenminste deze tijd kwijt is voor het lezen van de
invoer.

Dit laatste is niet zo’n heel sterk argument omdat bijvoorbeeld zoeken in een gesorteerde rij niet
de gehele invoer leest, anders zou een log n algoritme niet mogelijk zijn. Ook andere algoritmen
kunnen volstaan met het slechts gedeeltelijk lezen van de invoer. We zien echter dat er genoeg
argumenten bestaan om algoritmen waarvan de looptijd begrensd wordt door een polynoom in de
lengte van de invoer samen te nemen en deze groep de

e(cid:14)ci(cid:127)ente" algoritmen te noemen.
"

1.3.1 Notatie voor de Complexiteit van Algoritmen

Nadat we beargumenteerd hebben dat voor de afschatting van de complexiteit van algoritmen con-
stanten niet interessant zijn en dat het er bij de afschatting van de complexiteit van algoritmen
vooral om gaat hoe deze algoritmen zich gedragen op steeds groter wordende invoeren, zullen we hier
een paar symbolen invoeren waarmee we het gedrag van algoritmen op invoeren van lengte n kunnen
noteren. Deze notaties hebben de eigenschap dat ze eenvoudige makkelijk te vergelijken functies
geven die een goede afschatting zijn van de werkelijke complexiteit (altijd binnen een constante fac-
tor van de werkelijke complexiteit). Bovendien laten deze afschattingen zich samenstellen, dwz. als
je een stel afschattingen hebt voor gedeelten van de algoritme, dan kun je daaruit een afschatting
voor de gehele algoritme verkrijgen. De afschattingen worden gede(cid:12)nieerd als klassen van functies.
De werkelijke complexiteit van een algoritme is dus altijd een element van de afschatting van een
functie. Als we bijvoorbeeld kijken naar (cid:19)e(cid:19)en van de meest gebruikte afschattingen O hieronder dan
de complexiteit van deze algoritme is in O(n)", genoteerd als 2 O(n), om
is de goede uitspraak:
"
...is van orde n", genoteerd als
een lineaire bovengrens aan te geven. In veel boeken wordt gezegd
"
= O(n). Deze taalvervlakking is van dezelfde orde als het gebruik van
het" algoritme in plaats
"
van het correcte
de" algoritme. Helaas is dit niet tegen te gaan. We gebruiken alle notaties voor
"
boven- en ondergrenzen in het vervolg als afschattingen van de complexiteit van algoritmen. Het
is niet zo zinvol om daarbij rare (cid:13)abberende functies te beschouwen, al is het soms wel nuttig te
kijken wat deze functies zouden doen. Verschillende auteurs hanteren verschillende manieren om de
functies zo te normaliseren dat ze het gewenste gedrag vertonen. Zo kijkt Knuth bijvoorbeeld alleen
naar de absolute waarden van de gebruikte functies in de vergelijkingen. Om onnodige complicaties
te voorkomen kiezen hier voor de variant waarbij alle gebruikte functies gaan van de natuurlijke
getallen (N)naar de positieve re(cid:127)ele getallen (R+).

Bovengrenzen

De volgende bovenafschattingen voor functies zijn in gebruik

O(f ) = fg : (9c; n0 2 N)(8n > n0 2 N)[g(n) (cid:20) cf (n)]g In de klasse O(f ) zitten zo alle
functies die op den duur (dat wil zeggen voor voldoende grote n kleiner worden dan (cid:19)e(cid:19)en of
andere constante c keer f (n). Voorbeeld 3n 2 O(n2) omdat vanaf n = 3 geldt dat 3n (cid:20) n2,
maar ook is 3n al kleiner dan of gelijk aan 3n2 vanaf n = 1.

26

o(f ) = fg : limn!1 g(n)
f (n) = 0g. In o(f ) zitten alle functies die echt kleiner worden dan f .
Vaak zie je dat g 2 O(f ) en g 2 o(f ) samengaan, maar bijvoorbeeld sin n 2 O(1) maar niet
in o(1), terwijl bijvoorbeeld wel sin n 2 O(n).

Ondergrenzen

De volgende onderafschattingen voor functies zijn in gebruik

(cid:10)(f ) = fg : (9(cid:15) > 0;91ni)

h g(ni)

f (ni) > (cid:15)

ig. Opmerkingen:

1. De notatie 91 is niet zo heel bekend. Ze betekent \er zijn oneindig veel"
2. Deze de(cid:12)nitie maakt van (cid:10) de tegenhanger van o bij ondergrenzen. In een groot aantal
teksten (cid:12)gureert (cid:10) ook als de tegenhanger van O, en is zij gede(cid:12)neerd als: (cid:10)(f ) = fg :
(9c 2 R+; n0 2 N)(8n > n0 2 N)[g(n) (cid:21) cf (n)]g. Wij zullen hier aan de eerste de(cid:12)nitie
vasthouden om historische redenen, hoewel het in de praktijk vaak niet zoveel uitmaakt
welke van de twee de(cid:12)nities je gebruikt. Ook maakt het in de praktijk niet zoveel uit of
we nu eisen dat c 2 N of c 2 R+. In het laatste geval geldt weliswaar niet dat n2 2 (cid:10) n2
2
en in het eerste geval wel, maar dergelijke gevallen doen zich in de praktijk nauwelijks
voor.

!(f ) = fg : limn!1 f (n)

g(n) = 0g

Dubbele grenzen

Naast boven- en ondergrenzen zijn er ook nog twee notaties voor simultane onder en bovengrenzen.

(cid:18)(f ) = fg : (9c1; c2 2 R; n0 2 N)(8n > n0 2 N)[c1f (n) (cid:20) g(n) (cid:20) c2f (n)]g
(cid:24) (f ) = fg : limn!1 g(n)

f (n) = 1g

Al deze notaties hebben de eigenschap dat ze simpele betekenisvolle grenzen kunnen geven voor
ingewikkelde algoritmen. Een algoritme bestaat namelijk vaak uit veel gedeelten die allemaal hun
eigen complexiteit hebben. Het programma kan bestaan uit verschillende, vaak geneste loops, pro-
cedure en function calls etc., allemaal met eigen grenzen aan de rekentijd. Deze grenzen kunnen we
apart bepalen en vervolgens optellen. Het grote voordeel van de notatie die we hier hebben afgespro-
ken is dat het optellen van al die onderdelen niet leidt tot een grote, lelijke, onoverzichtelijke uitdruk-
king. Er geldt bijvoorbeeld de optelregel voor O die zegt dat O(f (n)+g(n)) = O(maxff (n); g(n)g).
Als dus bijvoorbeeld een programma bestaat uit een loop die O(n2) keer wordt uitgevoerd, gevolgd
door een loop van complexiteit O(n3), dan is de totale complexiteit van het programma O(n3).
Ook zien we hier het grote voordeel van het weglaten van de constanten. In de verschillende loops
worden een aantal operaties ongeveer even vaak uitgevoerd. Hebben we bijvoorbeeld een loop als
for i = 1 to n do p = p + 1, dan wordt de variabele p precies n keer verhoogd, maar ook de
variabele i. Toch kunnen we de kosten van deze loop op O(n) operaties stellen omdat constante
factoren bij de bepaling van onze grenzen niet meetellen. Voor geneste for loops kunnen we zo de
complexiteit bepalen door een operatie te vinden die in zo’n for loop het vaakst wordt uitgevoerd.
In een programmafragment als:

for i = 1 to n do
if a = b then

27

for j = 1 to m do x = x + 1;
end for

end if

end for

kunnen we een aantal operaties onderscheiden. De variabele i wordt n keer opgehoogd. De test a = b
wordt n keer uitgevoerd. De variabele j wordt (hoogstens) n(cid:2)m keer opgehoogd en ook de variabele
x wordt hoogstens n (cid:2) m keer opgehoogd. We zien hier echter dat de optelling x = x + 1 minstens
net zo vaak wordt uitgevoerd als elke andere operatie in deze geneste loop en daarom kunnen we de
kosten van deze loop van boven afschatten met een constante keer het aantal keren dat x = x + 1
wordt uitgevoerd. De operatie x = x + 1 wordt in Engelse teksten vaak barometer genoemd. Dat
lijkt in deze tekst minder zinvol, maar omdat de complexiteit van dit stukje programma als het
ware hangt aan de operatie x = x + 1 zullen we deze operatie hier spil noemen (zie ook pagina 17).
Als we de complexiteit van een loop willen bepalen gaan we dus op zoek naar een spil op het diepste
niveau en bepalen hoe vaak deze wordt uitgevoerd. De complexiteit van een nesting van loops is
vaak het product van de complexiteiten van die loops en de complexiteit van een stel opeenvolgende
loops kunnen we afschatten met de maximale complexiteit van die loops.

1.3.2 Sommen

1. Bedenk enkele voorbeelden van algoritmen die niet de gehele invoer hoeven te lezen voordat

ze stoppen en een antwoord geven.

2. Onderzoek de uitgesmeerde complexiteit van zoekbomen en hashtabellen. Waarom halveren

we de hashtabel pas wanneer deze voor 1=4e gevuld is en niet wanneer deze half gevuld is?

3. Laat zien dat log3 n 2 O(n1=3).
4. Geef een voorbeeld van een functie f (n) zodat f (n) =2 O(n) en f (n) =2 (cid:10)(n).

5. Een polynoom van graad n is een functie a0 + a1x + : : : + anxn. Geef een algoritme om de
waarde van zo’n polynoom in een gegeven punt uit te rekenen en bepaal de complexiteit.
Bepaal ook de complexiteit van het Horner product, dat is de berekening p(x) = a0 + x(a1 +
x(a2 + x(a3 + : : : + xan)) : : :).

6. Conditionele asymptotische notatie. Niet altijd is een asymptotische grens te geven voor elke
waarde van n. Het kan zijn dat een functie bijvoorbeeld O(n2) is alleen maar als n een macht
van 2 is. Voor bepaalde veel voorkomende functies kunnen we zo’n conditionele grens vertalen
in een grens die voor alle n geldt. We zeggen dat een functie f uiteindelijk niet dalend is als
er een n0 bestaat zo dat f (n) (cid:20) f (n + 1) voor alle n (cid:21) n0. Verder heet een functie b-glad als
f (bn) 2 O(f (n)), en glad als zij b-glad is voor elke b (cid:21) 2. Als t uiteindelijk niet dalend is, en
f is b-glad dan geldt. t(n) 2 (cid:18)ff (n) : n is een macht van bg ) t(n) 2 (cid:18)(f (n)). Bewijs dit.

7. Bewijs dat O(f + g) = O(maxff; gg).
8. De symbolen O,o,(cid:18),(cid:10), en (cid:24) kunnen opgevat worden als relaties tussen functies (bijvoorbeeld
R(f; g) $ f 2 O(g). Welke van de aldus gede(cid:12)ni(cid:127)eerde relaties zijn re(cid:13)exief (R(f; f )), transitief
(R(f; g) ^ R(g; h) ! R(f; h)) en/of symmetrisch (R(f; g) $ R(g; f ))?

9. Geef aan welke relaties f 2 (cid:15)(g) gelden in onderstaande gevallen voor (cid:15) 2 fO; o;(cid:24); (cid:18); (cid:10)g

28

10. Onderzoek de volgende uitspraken op waarheid als f (n) 2 O(g(n) en als f (n) 2 (cid:10)(g(n)).

(a) f (x) = (x2 + 3x + 1)3; g(x) = x6.

(b) f (x) = 2x; g(x) = 3x.
(c) f (x) = x + 4; g(x) = x2 (cid:0) 3.
1
j2 ; g(x) = 1.

(d) f (x) =P

j(cid:20)x

(a) f (n) + g(n) 2 O(g(n)).
(b) f (n) (cid:2) g(n) 2 O(g(n).
(c) f (n) (cid:0) g(n) 2 O(f (n)).
(d) f (n)

g(n) 2 (cid:18)(f (n)).

1.4 Wiskundige Hulpmiddelen

Belangrijk bij de Analyse van Algoritmen en bij het bepalen van de Complexiteit van Problemen
is dat we kunnen tellen.
In het bijzonder moeten we boven en ondergrenzen kunnen bepalen.
Omdat het aantal operaties, of geheugenplaatsen dat gebruikt wordt vaak als functie van de invoer
gerepresenteerd wordt, en dan bovendien lang niet altijd in gesloten vorm maar veel meer als
samenraapsel van een aantal telpartijen en observaties, hebben we wat elementaire wiskunde nodig
schone" afschatting van de complexiteit te krijgen. In deze sectie zullen we een aantal
om een
"
technieken die hierbij kunnen helpen de revue laten passeren. Dit is mogelijk een herhaling van
eenvoudige wiskunde die de lezer al eens eerder heeft gezien. Opfrissing van deze kennis is echter
altijd nuttig.

1.4.1 Inductie en Recursie

Inductie

Bij een van zijn vele bezoeken aan Amsterdam vertelde Carl Smith eens over zijn
favorite induction
"
proof". Het is een bewijs met inductie dat je nagenoeg zonder wiskundige hulpmiddelen kunt geven
en dat door iedereen onmiddellijk begrepen wordt. Wellicht heeft de lezer dit probleem al eens
eerder gezien. Het gaat om het volleggen van een bord, bestaande uit velden, met stukken van de
vorm van Figuur 1.4.1. Zo’n L-vormige (cid:12)guur beslaat precies 3 velden van het bord. De bewering
is dat voor elk vierkant bestaande uit 2k (cid:2) 2k velden de stukken zo in het vierkant gelegd kunnen
worden dat slechts (cid:19)e(cid:19)en veld onbezet blijft, en dat veld kan bovendien willekeurig vantevoren worden
gekozen.
Het inductiebewijs is als volgt. Voor een 2 (cid:2) 2-vierkant is het simpel. Door rotatie kan elk van
de vier velden onbedekt gelaten worden. Stel dat het probleem kan worden opgelost voor k (cid:0) 1.
Bekijk een 2k (cid:2) 2k-vierkant. Kies een veld dat onbedekt moet blijven. Dit veld ligt in (cid:19)e(cid:19)en van de
vier 2k(cid:0)1 (cid:2) 2k(cid:0)1 vierkanten die volgens de inductiehypothese kunnen worden volgelegd. De andere
drie worden zo volgelegd dat de open velden de drie velden in het midden zijn waar ze alledrie bij
elkaar komen en op die velden leggen we precies (cid:19)e(cid:19)en stuk.

29

Figuur 1.4: Met volledige inductie...

Recursie

Een recursieve aanpak van programmeren, zoals we in Sectie 2.2 zullen bekijken, verdeelt een
algoritmisch probleem in kleinere, vaak identieke stukken. Op deze stukken kan dan weer dezelfde
algoritme worden gebruikt, net zo lang tot de stukken zo klein geworden zijn dat de oplossing
triviaal is. Recursieve aanpak van problemen en inductieve bewijzen gaan vaak hand in hand. Hoe
zouden we namelijk een oplossing vinden voor het probleem dat hierboven geschetst is? We weten
dat het probleem eenvoudig is voor 2(cid:2)2-vierkanten, en als we een groter vierkant krijgen met daarin
een veld, dan kunnen we het probleem in vier kleinere problemen opdelen, elk met hun eigen veld
dat vrij gelaten moet worden om, als we voor deze vier kleinere problemen een oplossing hebben
gevonden, met toevoeging van (cid:19)e(cid:19)en stuk een oplossing voor het hele probleem te genereren.

1.4.2 Recurrente betrekkingen

De methode om een afschatting te krijgen voor de complexiteit van een probleem waarvoor we
een recursieve algoritme hebben bedacht is het oplossen van de recurrente betrekking. Stel dat we
zouden willen weten hoe moelijk het is de inductieopgave uit 1.4.1 te vinden. We zien dat we om
een probleem van afmetingen n op te lossen, we 4 problemen van afmeting n=2 moeten oplossen,
ofwel T (n) = 4 (cid:2) T (n=2). Nu kunnen we het volgende zien.

...

T (n) = 4 (cid:2) T (n=2)
= 16 (cid:2) T (n=4)
= 43 (cid:2) T (n=23)
...
= 4log n (cid:2) T (n=2log n)
= 4log n
= (22)log n
= (2log n)2
= n2

30

We hebben hier aangenomen dat de laatste T in deze reeks T (n=2log n) = T (1) een triviale waarde
(bijvoorbeeld 1) aanneemt. Aangezien de complexiteit voor constante afmetingen in ieder geval
constant is, en we constanten in de O-notatie toch verwaarlozen is dit in ons geval geen verkeerde

Dat is niet altijd het geval. Soms is een recurrente betrekking algemener.

aanname. De recurrente betrekking laat zich dan als het ware uitrollen totdat we een gesloten
uitdrukking voor de complexiteit van het probleem overhouden.
In het geval van
de recursieve aanpak van de Fibonacci-getallen zagen we dat F (n) = F (n (cid:0) 1) + F (n (cid:0) 2). Hier
zijn al twee startwaarden nodig om van de grond te komen.
In dit speciale geval hebben we
F (0) = F (1) = 1, dus kunnen we die gebruiken om F (2); F (3); : : : uit te rekenen. Echter, de
vergelijking laat zich dan al niet meer gemakkelijk uitrollen, maar meer uitbomen. Van boven naar
beneden geeft F (n) steeds twee nieuwe waarden, dus uiteindelijk exponentieel veel waarden om uit
te rekenen.

Een andere eenvoud bevorderende eigenschap aan ons inductievoorbeeld is dat de factor die voor
de T (n=2) staat steeds dezelfde is. Dat kan natuurlijk ook afhankelijk van de probleemgrootte zijn.
Een recurrente betrekking kan bijvoorbeeld van de vorm xn+1 = bn+1xn zijn. In dit geval, kunnen
we de vergelijking ook uitrollen als xn+1 = bn+1xn = bn+1bnxn(cid:0)1 = : : : = bn+1bnbn(cid:0)1 (cid:1)(cid:1)(cid:1) b1 (cid:2) x0.
Dat is kennelijk nog niet moelijk genoeg. Laten we dus een extra moeilijkheid toevoegen en kijken
naar de vergelijking

Het uitrollen van de vergelijking geeft dan achtereenvolgens

xn+1 = bn+1xn + cn+1:

xn+1 =
=
= bn+1(bn(bn(cid:0)1xn(cid:0)2 + cn(cid:0)1) + cn) + cn+1:

bn+1(bnxn(cid:0)1 + cn) + cn+1

bn+1xn + cn+1

We raken hierbij al snel het overzicht kwijt.
Een betere aanpak voor dit soort vergelijkingen is de volgende. Eerst de(cid:12)nieren we een nieuwe
variabele yn door xn = b1b2 (cid:1)(cid:1)(cid:1) bnyn. Vul in b1b2 (cid:1)(cid:1)(cid:1) bn+1yn+1 = bn+1b1b2 (cid:1)(cid:1)(cid:1) bnyn+cn+1. We kunnen
nu door de coe(cid:14)ci(cid:127)ent van yn delen en krijgen yn+1 = yn + dn+1, waarbij dn+1 = cn+1=(b1 (cid:1)(cid:1)(cid:1) bn+1).
j=1 dj en, door terugsubstitutie
j=1 dj]. Deze substitutie van variabelen blijkt een winnende strategie te zijn.

Deze vergelijking laat zich weer uitrollen tot de oplossing yn = y0+Pn
xn = (b1 (cid:1)(cid:1)(cid:1) bn)[x0 +Pn
en vind dat yn+1 = yn + n=3n+1 ofwel yn =Pn(cid:0)1
xn = 3n (cid:2) n(cid:0)1X

Voorbeeld 1.4.1: Kijk naar de vergelijking xn+1 = 3xn + n, met x0 = 0. Substitueer xn = 3nyn

j=1 j=3j+1. Terugsubsitutie van yn = xn=3n geeft

Dit is al behoorlijk precies, maar met de technieken uit de sectie 1.4.3 kunnen wePn(cid:0)1

j=3j+1:

j=1

j=1 j=3j+1 nog
2

nauwkeuriger bepalen, zoals verderop blijkt.

Recurrente betrekkingen als tot nu toe behandeld, noemen we eerstegraads recurrente betrek-
kingen. Er is sprake van twee variabelen, xn en xn(cid:0)1, en nog wat andere termen die niet van de
recurrentie afhangen. Deze afhankelijkheid lijkt dus een beetje op de manier waarop de coordinaten
van een eerstegraadsfunctie (lijn) van elkaar afhangen. Het is echter ook in de algoritmiek moge-
lijk dat de afhankelijkheid complexer is. In de recursieve implementatie van het n-de Fibonacci
getal is er afhankelijkheid van xn van zowel xn(cid:0)1 als xn(cid:0)2 (F (n) = F (n (cid:0) 1) + F (n (cid:0) 2)). Ook
uitrollen" totdat alleen F (0) en F (1) nog in de vergelijking
deze recurrente betrekking kunnen we
"
staan, maar er is een slimmere manier. Als we een vergelijking hebben als xn = xn(cid:0)1 + xn(cid:0)2, dan

31

2

kunnen we eens een oplossing proberen van de vorm xn = (cid:11)n voor constante (cid:11). Invullen van dit
probeersel geeft (cid:11)n = (cid:11)n(cid:0)1 + (cid:11)n(cid:0)2 of (delen door (cid:11)n(cid:0)2) (cid:11)2 = (cid:11) + 1. De kwadratische vergelijking
(cid:11)2 (cid:0) (cid:11) (cid:0) 1 = 0 laat zich direct oplossen en geeft (cid:11) = 1(cid:6)p

5

.

In het algemeen zijn tweede orde recurrente betrekkingen van de vorm xn = axn(cid:0)1 + bxn(cid:0)2 +
f (n). Als de vergelijking (cid:11)2 = a(cid:11) + b een oplossing heeft, dan heeft de recurrente betrekking
xn = axn(cid:0)1 + bxn(cid:0)2 een oplossing in gesloten vorm xn = (cid:11)n, waarbij (cid:11) (cid:19)e(cid:19)en van de wortels van
de vergelijking is. Bij twee gelijke wortels vinden we een oplossing van de vorm (cid:11)n(c1 + c2n)
analoog aan de oplossing van di(cid:11)erentiaalvergelijkingen. Het punt is dat de oplossingen van deze
tweedegraadsvergelijkingen slechts begrensd lijken te worden door exponenti(cid:127)ele functies. Zeker is
(cid:11)n een ondergrens, maar als f (n) ook door (cid:11)n begrensd wordt, dan is (cid:11)n ook een bovengrens voor
de groei van xn. We vatten dit samen in de volgende stelling.
Stelling 1.4.1 Laat fxngn voldoen aan xn (cid:20) b1xn(cid:0)1 + : : : + bkxn(cid:0)k + f (n) met (8i)[bi (cid:21) 0],

P bi > 1 en laat c > 1 zo dat ck = b1ck(cid:0)1 + : : : + bk. Als f (n) 2 o(cn), dan geldt xn 2 O((c + 1)n).

Het bewijs van deze stelling gaat als volgt. Eerst merken we op dat als t = (c + 1)k (cid:0) b1(c +
1)k(cid:0)1(cid:0) : : :(cid:0) bk, dan is t > 0. Immers, ck = b1ck(cid:0)1 + : : : + bk, en als een k-de graads functie eenmaal
groter is geworden dan een k (cid:0) 1-ste graads functie in voor positieve argumenten, dan blijft dat zo.

De(cid:12)nieer

K = maxfjx0j;jx1j=(c + 1); : : :jxkj=(c + 1)k; maxff (n)=t(c + 1)n(cid:0)k : n (cid:21) kgg

Dan is K eindig en bovendien geldt jxjj (cid:20) K(c + 1)j voor j (cid:20) n (cid:0) 1. We beweren dat jxnj (cid:20)

K(c + 1)n voor alle n. Stel dat de bewering waar is tot en met n (cid:0) 1, dan

jxnj (cid:20)

b1jxn(cid:0)1j + : : : + bkjxn(cid:0)kj + f (n)

(cid:20) b1K(c + 1)n(cid:0)1 + : : : + bkK(c + 1)n(cid:0)k + f (n)
= K(c + 1)n(cid:0)k(b1(c + 1)k(cid:0)1 + : : : + bk) + f (n)
=
=
(cid:20)

K(c + 1)n(cid:0)k((c + 1)k (cid:0) t) + f (n)
K(c + 1)n (cid:0) (tK(c + 1)n(cid:0)k (cid:0) f (n))

K(c + 1)n:

Een Master Theorem

Hoewel goed om te hebben, leert Stelling 1.4.1 ons vooral dat algoritmen waarvan de tijd gegeven
wordt door een recurrente betrekking met meerdere termen die als index n (cid:0) c hebben, met c
een constante, geen e(cid:14)ci(cid:127)ente algoritmen zijn.
In het bereik van de e(cid:14)ci(cid:127)ente algoritmen komen
recurrente betrekkingen als T (n) = T (n=2) + f (n) veel vaker voor, zoals we bijvoorbeeld bij zoeken
en sorteren verderop zullen zien. Een recursie als de bovenstaande kunnen we natuurlijk uitrollen
en een gesloten uitdrukking voor T (n) in f (n) krijgen, maar er is een meer generieke aanpak. In een
tekstboek als bijvoorbeeld dat van Cormen, Leiserson en Rivest [CLR90] wordt deze aanpak
The
"
Master Theorem" genoemd. Op veel andere plaatsen wordt deze aanpak de Akra-Bazzi methode
genoemd, naar de auteurs van [AB98]. Beide methoden hebben veel gemeen, al dekt de Akra-Bazzi
methode meer gevallen. Het gaat om recurrente betrekkingen van de vorm

un =

aiub n
bi

c + g(n):

kX

i=1

32

De wiskundig ge(cid:127)(cid:16)nteresseerde lezer wordt aangemoedigd om het artikel [AB98] te lezen, maar
voor de analyse van algoritmen kan vaak worden volstaan met een sterk vereenvoudigde aanpak
zoals in [CLR90]. Vaak is er in een recurrente betrekking die uit een complexiteitsanalyse volgt
namelijk slechts sprake van (cid:19)e(cid:19)en enkele veranderlijke, d.w.z. de recurrente betrekking is van de vorm.

(cid:26)

T (n) =

c

aT (n=b) + f (n)

als n < d
als n (cid:21) d

We kunnen dan volstaan met de vereenvoudiging:
1. Als f (n) 2 O(nlogb a(cid:0)(cid:15)) dan T (n) 2 (cid:18)(nlogb a).
2. Als f (n) 2 (cid:18)(nlogb a logk n) dan T (n) 2 (cid:18)(nlogb a logk+1 n)
3. Als f (n) 2 (cid:10)(nlogb a+(cid:15)) en (9(cid:14) < 1)[af (n=b) (cid:20) (cid:14)f (n)] dan T (n) 2 (cid:18)(f (n)).

Deze vereenvoudiging van de stelling is bij veel complexiteitsanalyse van algoritmen een machtig

wapen.

Voorbeeld 1.4.2:

1. Bij de algoritme voor mergesort, wordt een array verdeeld in twee arrays van de halve grootte,
die vervolgens gesorteerd worden en weer samengevoegd tot een gesorteerd array van de
oorspronkelijke grootte. Dat samenvoegen kost tijd proportioneel aan de lengte van het array.
De recurrente betrekking die daarbij hoort is

T (n) = 2T (n=2) + O(n):

Met bovenstaande stelling zien we dat a = b = 2 dus nlogb a = n, dus f (n) 2 O(nlogb a), maar
f (n) 62 O(nlogb a(cid:0)(cid:15)), ofwel we zitten in geval 2 met k = 0. Gevolg: T (n) 2 (cid:18)(n log n).

2. Gewone matrixoptelling kunnen we recursief doen door vier matrices van de halve grootte bij

elkaar op te tellen. De recurrente betrekking die daarbij hoort is

We zitten hiermee in geval 1 van de stelling, en dus T (n) 2 (cid:18)(n2), want log2 4 = 2.

T (n) = 4T (n=2) + O(1):

3. Gewone matrixvermenigvuldiging kan gebeuren door 8 matrices van de halve grootte met
elkaar te vermenigvuldigen, en dan de resultaten van de vermenigvuldiging twee aan twee bij
elkaar op te tellen. Dat zijn vier optellingen. We hebben gezien dat matrixoptelling (cid:18)(n2)
bewerkingen kost, dus is de recurrente betrekking die hierbij hoort

We zien hier a = 8; b = 2, dus logba = 3, en n2 2 O(n3) dus T (n) 2 (cid:18)(n3).

T (n) = 8T (n=2) + O(n2):

4. Stel we hebben een rij van n getallen waaruit we een deel van log n getallen willen selecteren
die van klein naar groot gesorteerd is. Dat kunnen we doen door bijvoorbeeld log n keer het
minimum van de rij te nemen, maar aangezien het vinden van het minimum van een rij O(n)
stappen kost, zijn we dan n + n(cid:0) 1 + n(cid:0) 2 + : : : + n(cid:0) log n stappen bezig en dat is (cid:18)(n log n).

33

Omdat we niet zoveel getallen nodig hebben, kunnen we ook als we het minimum van een rij
hebben gevonden, vervolgens het minimum zoeken van de helft van de overgebleven rij. Dan
zijn de kosten

Volgens bovenstaande stelling is dan a = 1; b = 2 ! logb a = 0, dus komen we in geval 3,
waaruit volgt dat T (n) 2 (cid:18)(n).

T (n) = n + T (n=2):

2

1.4.3 Reeksen

Het optellen van complexiteit van verschillende stukjes van een programma is een belangrijk onder-
deel van de bepaling van de complexiteit van problemen. Echter, de optelling is vaak afhankelijk van
een variabele. De tweede keer dat een stukje programma wordt uitgevoerd is vaak de complexiteit
van dat stukje programma anders. Een voorbeeld is het samenstellen van twee gesorteerde rijen tot
een nieuwe gesorteerde rij in de algoritme mergesort(zie 2.2). Deze algoritme laat zich uitleggen
als volgt. Een rij die bestaat uit (cid:19)e(cid:19)en getal is altijd gesorteerd. Verder kunnen we twee gesorteerde
rijen van lengte n samenstellen tot een gesorteerde rij van lengte 2n door de twee eerste elementen
met elkaar te vergelijken en daarvan de kleinste weg te schrijven, net zo lang tot de beide rijen leeg
zijn. Zo krijg je bijvoorbeeld uit de rijen 1; 2; 4; 7 en 3; 5; 6; 8 de rij 1; 2; 3; 4; 5; 6; 7; 8. Elke keer als je
dit stukje programma uitvoert, is de lengte van de resulterende rij twee keer zo groot als de vorige
keer. De hele executie van mergesort voegt n=2 rijen van lengte 1 samen tot n=4 rijen van lengte 2
die worden samengevoegd tot n=8 rijen van lengte 4 eindigend in het samenvoegen van 2 rijen van
lengte n=2 (even uitgaande van het gunstige geval dat n een macht van 2 is). Om te bepalen wat
de totale complexiteit van het steeds samenvoegen van twee rijen is, moet je dus die getallen bij
i=1 2i is. In deze sectie
zullen we een aantal truuks voor het sommeren van reeksen die de lezer waarschijnlijk eerder gezien
heeft, maar mogelijk weer vergeten is, de revue laten passeren. We beginnen met een eenvoudige.

elkaar kunnen optellen, dus bijvoorbeeld kunnen uitrekenen wat de somPlog n

Bekijk de reeks

n(cid:0)1X

xi = 1 + x + x2 + : : : + xn(cid:0)1 = (1 (cid:0) xn)=(1 (cid:0) x) voor x 6= 1:

i=0

kunnen we een antwoord krijgen op de vraag hoe groot Plog n
bepalen wat Pn

Dat dit waar is, is in te zien door beide kanten met 1(cid:0) x te vermenigvuldigen. Met deze observatie
i=0 2i is, zoals we hierboven zochten,
want het is gewoon deze reeks met x = 2 en log n gesubstitueerd voor n, er komt dus uit (1 (cid:0)
2log n)=(1 (cid:0) 2) = n. Omdat we deze reeks echter voor algemene x hebben opgelost kunnen we ook
i=0 3i voor het geval dat we een algortime hebben waarbij volgende slagen steeds

drie keer zo lang zijn.
Een reeks als deze laat zich gebruiken voor nog andere toepassingen. Stel eens dat we niet
1 + x + x2 + : : : + xn(cid:0)1 moeten uitrekenen, maar 1 + 2x + 3x2 + : : : + (n (cid:0) 1)xn(cid:0)2. Deze reeks is de
afgeleide van de reeks 1 + x + x2 + : : : + xn(cid:0)1 en dus is de som ook de afgeleide van (1(cid:0) xn)=(1(cid:0) x)
dus

1 (cid:0) nxn(cid:0)1 + (n (cid:0) 1)xn

(1 (cid:0) x)2

:

34

Voor machtreeksen geldt dat als we de som van de machtreeks kennen, zeg bijvoorbeeldP anxn =
f (x), dan kennen we ookP nanxn(cid:0)1, want dat is de afgeleide van f (x), maar dan natuurlijk ook
P nanxn want dat is weer xf0(x). Dus als de nde co(cid:127)e(cid:14)cient met n vermenigvuldigd wordt, dan
herhalen. Immers als xf0(x) =P nanxn dan is xf00(x) =P n2anxn(cid:0)1 en is x2f00(x) =P n2anxn.

Dit spel|neem de afgeleide en vermenigvuldig het resultaat weer terug met x|kunnen we

verandert de som van f (x) naar x d

dx f (x).

Met andere woorden, het vermenigvuldigen van de n-de co(cid:127)e(cid:14)cient met n2 verandert de som van
de reeks van f naar (x d
dx )2f (x). Algemener: als we de n-de co(cid:127)e(cid:14)cient van een machtreeks met np
vermenigvuldigen, dan verandert de som van de reeks van f naar (x d
dx )pf (x). Vanwege het feit
dat we eindige sommen kunnen herordenen in elke volgorde die we willen, geldt dit voor algemene
polynomen. Als we bijvoorbeeld de co(cid:127)e(cid:14)cient van xn vermenigvuldigen met 5n3 + n2 + 4, dan
verandert de som van f (x) naar (5(x d
dx )2 + 4)f (x). De algemene regel voor een willekeurig
polynoom P is als volgt.

dx )3 + (x d

X

j

(cid:18)

x

d
dx

(cid:19)X

j

P (j)ajxj = P

ajxj

In plaats van xi als sommand kunnen we ook te maken krijgen met ix. Het bekendste voorbeeld
is wel 1 + 2 + 3 + 4 + : : : + n = n(n + 1)=2 dat veelvuldig gebruikt wordt om bewijzen met
i=0 i3 =
(n(n + 1))2=4. Dit geldt veel algemener. Stel dat we (zie som 5) de beschikking hebben over de
volgende stelling.

inductie te illustreren. Niet iedereen kent echter de veralgemenisering van dit voorbeeld: Pn
Stelling 1.4.2 Als p een polynoom in i van graad d is, dan is Pn
Nu kunnen we de beweringPn
elk polynoom p achter de waarde vanPn

i=0 i3 = (n(n + 1))2=4 bewijzen door te controleren dat n = 0; n =
1; n = 2; n = 3 en n = 4 aan beide kanten respectievelijk 0, 1, 9, 36 en 100 opleveren omdat 5
punten een polynoom van de graad 4 volledig vastleggen, maar dat niet alleen. We kunnen nu voor
i=0 p(i) komen door een paar lineaire vergelijkingen op te

i=0 p(i) een polynoom in n van

graad d + 1.

lossen die de coe(cid:14)ci(cid:127)enten van het resulterende polynoom bepalen.

Voorbeeld 1.4.3: Bereken

We weten door Stelling 1.4.2 dat hier een polynoom in n van graad 3 uit moet komen. De algemene
vorm is an3 + bn2 + cn + d. Vier punten van het polynoom zijn voldoende om het uniek te bepalen.
Voor n = 0; 1; 2; 3 is de waarde van de som respectievelijk 4, 6, 12 en 22. We lossen op:

nX

i=0

2i2 + 4:

d = 4
a + b + c + d = 10
8a + 4b + 2c + d = 22
27a + 9b + 3c + d = 44

2
3

n3 + n2 +

n + 4:

13
3

35

Zodat we als som voor deze reeks vinden

Figuur 1.5: De integraal en de som van log x.

Ten slotte noemen we nog een aantal voorbeelden van sommen die vaak voorkomen en goed zijn

om te kennen.

2

= P1
= P1
= P1
1(cid:0)x = P1

ex
sin x
cos x
log 1

m=0 xm=m!
r=0((cid:0)1)rx2r+1=(2r + 1)!
r=0((cid:0)1)rx2r=(2r)!
j+1 xj=j

1.4.4 Reeksen en Integralen

Integralen zijn in de wiskunde de in(cid:12)nitesimale vorm van sommeren. Een integraal geeft, zeer
informeel gesproken, een uitdrukking van de oppervlakte van een gebied onder een functie doordat
de som genomen wordt van oneindig veel rechthoeken van oneindig kleine dikte. We kunnen deze
het integraalkenmerk van d’Alembert" genoemd wordt, gebruiken
eigenschap, die in de analyse
"
om sommen af te schatten. Kijk bijvoorbeeld eens naar de functie f (x) = log x. Figuur 1.5
laat twee plots voor deze functie zien, waarbij de waarden tussen 1 en 10 op twee manieren als
een staafdiagram zijn weergegeven. De som van de functiewaarden (vermenigvuldigd met 1 maar
dat kun je niet zien) geeft op twee manieren een schatting van de waarde van de oppervlakte
onder de functie, ofwel de oppervlakte van de functie geeft op twee manieren een schatting van
de som van de functiewaarden. Nemen we de functiewaarden van 1 t.e.m. 9 dan zien we dat de
som een onderschatting is van de integraal|ofwel de integraal is groter dan deze som, terwijl de
functiewaarden van 2 t.e.m. 10 een bovenschatting zijn van de integraal|ofwel de integraal is
kleiner dan de som. Deze eigenschap kunnen we uiteraard gebruiken om de afschatting van een
reeks te krijgen, wanneer we de integraal wel kennen maar de som niet. In het geval van log x is
i=1 log i dan

de integraal xlogx (cid:0) x, dus als we een afschatting willen hebben van bijvoorbeeld Pn

weten we dat (cid:18)(n log n) een geschikte afschatting is.

1.4.5 Sommen

1. Rondom een cirkel staan 2n nullen en (cid:19)e(cid:19)enen, n van elke soort. Bewijs met inductie dat het
altijd mogelijk is een punt te vinden z(cid:19)o dat als je een volledige cirkel met de klok meedraait,
je op elk punt van de draai minstens evenveel nullen als (cid:19)e(cid:19)enen gezien hebt.

36

2. Los de volgende recurrente betrekkingen op.

(a)

(b)

(c)

(d)

(e)

5tn(cid:0)1 (cid:0) 6tn(cid:0)2

als n = 0 of n = 1
anders

(cid:26) n

tn =

(cid:26) 9n2 (cid:0) 15n + 106
(cid:26) n
(cid:26) n + 1

(cid:26) 0

tn =

tn(cid:0)1 + 2tn(cid:0)2 (cid:0) 2tn(cid:0)3

als n = 0 of n = 1 of n = 2
anders

tn =

tn(cid:0)1 + tn(cid:0)3 (cid:0) tn(cid:0)4

als n = 0 of n = 1 of n = 2
anders

tn =

3tn(cid:0)1 (cid:0) 2tn(cid:0)2 + 3 (cid:2) 2n(cid:0)2

als n = 0 of n = 1
anders

tn =

1=(4 (cid:0) tn (cid:0) 1)

als n = 0
anders

3. Laat S een verzameling van n lijnen zijn waarvan geen twee parallel zijn en geen drie in

hetzelfde punt snijden. Bewijs met inductie dat de lijnen van S in (cid:18)(n) punten snijden.

4. Bereken

i=0 i (cid:2) ni
i=0 i3 + 2i2 + 4
i=0(i3 + 2i2 + i)xi

(a) Pn(cid:0)1
(b) Pn
(c) Pn
5. Bewijs met volledige inductie dat als p een polynoom in i van graad d is, dan isPn
6. Geef schattingen voorPn

i=1dlogie enPn

polynoom in n van graad d + 1 (Stelling 1.4.2).

i=1dlog(n=i)e.

i=0 p(i) een

37

38

Hoofdstuk 2

Technieken

In dit hoofdstuk bekijken we een aantal veelgebruikte technieken om te komen tot e(cid:14)ci(cid:127)ente al-
goritmen voor problemen. We maken een indeling naar de aard van de algoritme die voor het
probleem wordt besproken. Sommige van de algoritmen in dit hoofdstuk zouden met evenveel recht
in het volgende hoofdstuk, Grafenalgoritmen, kunnen worden geplaatst, omdat ze speci(cid:12)ek voor
grafenproblemen zijn ontworpen. De keuze om ze in dit hoofdstuk te behandelen is arbitrair.

2.1 Gulzige Algoritmen

De eerste soort algoritmen die we zullen bekijken zijn optimalisatie algoritmen. Bij optimalisatie-
algoritmen is altijd sprake van verschillende mogelijke uitkomsten waarvan er (cid:19)e(cid:19)en of meer als beste
kan worden aangemerkt. Bijvoorbeeld:

1. Er zijn mogelijke paden tussen A en B, en het pad dat in lengte het kortst is vinden wij het

beste,

2. uit hop en water kunnen we verschillende soorten en hoeveelheden bier maken en de verdeling

die het meeste geld oplevert vinden wij het beste,

3. een verzameling bussen kan langs een verzameling steden rijden en het schema waarbij de

totale reislengte van alle passagiers zo klein mogelijk gehouden wordt, vinden wij het best.

Een aanpak die altijd werkt voor optimalisatiealgoritmen is het bekijken van alle mogelijke
oplossingen en daaruit de oplossing(en) te kiezen die het beste resultaat geven. Deze uitputtende
methode (exhaustive search) kan echter soms heel duur zijn. Als we het grootste getal willen vinden
dat in n bits geschreven kan worden, kunnen we alle getallen van n bits onder elkaar schrijven en
de grootste noteren, dat kost 2n stappen. Er zijn snellere methoden denkbaar, en (cid:19)e(cid:19)en van die
methoden is de gulzige methode (of Greedy Method).
Gulzig" of
"

Greedy" als ze de volgende karakteristieken
"

We noemen een optimalisatiealgoritme

heeft.

- Een optimale oplossing wordt stap voor stap opgebouwd.

- Een (cid:19)e(cid:19)enmaal genomen stap wordt nooit ongedaan gemaakt.

39

- In iedere stap wordt een zo groot of zo goed mogelijk tussenresultaat behaald.

Gulzige methoden zijn vaak niet moeilijk om te bedenken. Het is de formule

grote stappen
"
gauw thuis" en dus lijkt het op wat een mens als eerste geneigd is om te doen als de situatie
onoverzichtelijk is. Een gulzige methode is ook bijzonder e(cid:14)ci(cid:127)ent omdat je nooit een verkeerd pad
inslaat. Veel moeilijker is het om te bewijzen dat de gulzige methode ook tot de optimale oplossing
leidt, omdat er talloze problemen zijn waarvoor helemaal geen gulzige algoritmen (kunnen) bestaan.
Vaak leidt de weg die het gunstigst lijkt verderop tot een uitzichtloze situatie. We zullen een aantal
voorbeelden van problemen beschrijven waarin gulzige algoritmen tot een optimale oplossing leiden.
Laten we eerst eens ons triviale getallenvoorbeeld bekijken: we weten dat bij (cid:19)e(cid:19)enbits getallen
een 1 groter is dan een 0. Als we dus een keuze moeten maken om een 1 of een 0 in te vullen en we
willen een zo groot mogelijk getal hebben, dan kiezen we voor de 1. In plaats van alle 2n getallen
op te schrijven kunnen we ook een groot n bits getal maken door bij ieder bit de best mogelijke
keuze te doen. Voor het eerste bit weten we dat een 1 groter is dan een 0 en we kiezen dus 1, voor
het tweede bit geldt hetzelfde, voor het derde bit ook enzovoort. Als grootste n-bits getal krijgen
we met deze keuzen vanzelf 11 : : : 1.

Dit lijkt allemaal eenvoudiger dan het is. Niet in alle gevallen kunnen we een globaal optimum
bereiken door steeds locaal een optimale stap te kiezen. Als we bijvoorbeeld van Amsterdam naar
Saarbruecken (Dld) willen rijden met de auto kunnen we zowel bij Arnhem als bij Maastricht de
grens over. Arnhem is aanmerkelijk dichterbij Amsterdam dan Maastricht, toch is de keuze voor
Arnhem de verkeerde als we zo snel mogelijk bij ons doel willen zijn. In dit geval is dus de keuze
van het dichtstbijzijnde tussenstation niet goed genoeg om ook de kortste weg te vinden. In 2.1.3
zullen we nog uitgebreid bespreken wat wel een goede manier is om de kortste weg van A naar B
te vinden.

Om van een probleem aan te tonen dat er een gulzige algoritme voor bestaat zullen we een
eigenschap van het probleem moeten vinden die het mogelijk maakt gedeeltelijke oplossingen steeds
uit te breiden totdat we een optimale oplossing voor het hele probleem gevonden hebben. Hiervan
zullen we dan moeten bewijzen dat de keuze die we maken bij het uitbreiden van de deeloplossing
steeds leidt tot een optimale oplossing. We bekijken een paar voorbeelden.

2.1.1 Geld Wisselen

We beginnen met een algoritme die elke cassi(cid:127)ere van de lokale supermarkt beheerst. Het probleem
is het teruggeven van wisselgeld, waarbij het aantal bankbiljetten en muntstukken dat moet worden
teruggegeven wordt geminimaliseerd. In ons muntsysteem is het allereerst zo dat elk bedrag dat
moet worden teruggegeven kan worden gemaakt, omdat in ons muntsysteem de eenheid zit. In het
geval van de euro is de eenheid de eurocent. Om verschillende reden is die eurocent uit het systeem
gehaald, maar alle af te rekenen bedragen worden vervolgens afgerond op vijf cent, zodat de vijf
cent munt de rol van de eenheid gaat vervullen.

Als we de bedragen die moeten worden teruggegeven vormen uit uitsluitend vijf eurocent mun-
ten, dan is het onmiddelijk duidelijk dat het aantal munten dat wordt teruggegeven niet minimaal
is. Een oplossing zou kunnen zijn, om eerst het terug te geven bedrag uit vijf cent munten te ma-
ken, en vervolgens die munten \in te wisselen" voor grotere, net zo lang tot dat niet meer kan. Dit
zou echter tot problemen kunnen leiden aangezien eerder genomen beslissingen, latere beslissingen
zouden kunnen be(cid:127)(cid:16)nvloeden. Bijvoorbeeld twee vijf cent stukken en (cid:19)e(cid:19)en tien cent stuk maken een
twintig cent stuk, maar dat twintig cent stuk kan ook uit twee tien cent stukken gemaakt worden.
De oplossing die door cassi(cid:127)eres gehanteerd wordt (en die ook leidt tot een optimale oplossing) is die

40

waarbij telkens de grootste munteenheid die in het gat past dat gevuld moet worden daarin gestopt
wordt, totdat er geen gat meer over is. Deze algoritme werkt helaas niet in elk muntsysteem. Het
muntsysteem moet ervoor ontworpen zijn om deze eenvoudige manier van optimaliseren mogelijk
te maken.

2.1.2 Knapsack

Het probleem is het vullen van een rugzak met objecten die allemaal een eigen gewicht en een eigen
waarde hebben. Als men bijvoorbeeld gaat kamperen, dan is de tent van waarde (afhankelijk van
waar men naartoe gaat uiteraard) maar het krat bier ook. Het gewicht van beide objecten verschilt.
Doorgaans zijn zwaardere objecten waardevoller, maar niet altijd. De creditcard is zeer licht van
gewicht, maar bij sommige bestemmingen onmisbaar. Als het totaal gewicht begrensd is door (cid:19)e(cid:19)en
of andere waarde b, wat is dan de juiste combinatie van mee te nemen objecten, zo dat de totale
waarde gemaximaliseerd wordt?

We beginnen eenvoudig en nemen aan dat we niet altijd hele objecten mee hoeven nemen.
Ko(cid:14)e bijvoorbeeld laat zich tot ongeveer elk deel verdelen en van een voorraad ko(cid:14)e kunnen we
dus besluiten een aantal gram mee te nemen. Hetzelfde geldt voor water, geld, etc. Om ons
probleem eenvoudig te maken nemen we dit aan voor alle mee te nemen objecten. Elk object heeft
dus een bepaald gewicht en een bepaalde waarde. Een gulzige algoritme kan dus op deze gewichten
en waarden in elke stap selecteren en net zo lang kiezen tot de grens is bereikt. Volgens onze
aanname kunnen we van elk object een deel meenemen, dus de grens die gesteld is kan altijd precies
worden bereikt. Er zijn twee voor de hand liggende keuzen.

1. We kunnen zoveel mogelijk objecten van zo klein mogelijk gewicht meenemen. Daarmee
kunnen we veel objecten in de rugzak steken en dus de totale waarde van de rugzak groot
maken.

2. We kunnen in elke stap een object met een zo groot mogelijke waarde kiezen. Dan vullen we

de rugzak met zeer waardevolle objecten en krijgen we ook een totale waarde die groot is.

Beide aanpakken werken niet. Om dat aan te tonen bekijken we twee kleine voorbeelden.

Voorbeeld 1 geeft aan dat het kiezen van een zo klein mogelijk gewicht niet goed is. Neem
als voorbeeld een gewichtsgrens 5 en 3 objecten met gewichten 2,2,5 en waarden 2, 2, 10. Kiezen
voor het kleinste gewicht eerst zal leiden tot het meenemen van objecten 1, 2 en 1/5e van object 3
voor een totale waarde van 2 + 2 + 2 = 6, terwijl het meenemen van alleen object 3 een waarde 10
oplevert.

Voorbeeld 2 geeft aan dat het kiezen van het object met de grootste waarde niet altijd goed is.
Als we weer een gewichtsgrens 5 hebben en nu 3 objecten met waarde 5,4,3 en gewicht 5,3,2 dan
krijgt de rugzak een totale waarde 5 als we alleen object 1 meenemen, maar de rugzak krijgt waarde
7 als we objecten 2 en 3 meenemen. De oplossing is hier dat we de objecten moeten rangschikken
naar oplopende waarde per gewichtseenheid en dan eerst het object kiezen dat de grootste waarde
per gewichtseenheid heeft. In het eerste geval leidt dat tot een ordening: 1, 1, 2, wat inhoudt dat
we eerst zullen kiezen voor zoveel mogelijk meenemen van object 3 en in het tweede geval leidt dat
tot een ordening 1, 4/3, 3/2, waardoor we eerst voor object 3, en daarna voor object 2 zullen kiezen,
waarna de rugzak vol is. Deze strategie leidt ook in het algemeen tot een optimale oplossing. Dit
zullen we bewijzen in Opgave 3.

41

2.1.3 Grafen: kortste paden

Het probleem is het vinden van het kortste pad in een gewogen graaf. Gegeven is dus een graaf
G = (V; E) met E (cid:18) V (cid:2) V , een gewichtsfunctie f : E 7! R+ (alleen positieve gewichten) en een
speciaal startpunt S in de graaf, en gevraagd is voor elk punt A in de graaf de lengte van een pad
van S naar A te vinden zo dat de som van de gewichten van de kanten in dat pad minimaal is.
Ook voor dit probleem bestaat een gulzige algoritme, bedacht door E.W. Dijkstra in 1959 die in
de praktijk nog steeds gebruikt wordt in bijvoorbeeld routeplanners. Een voor de hand liggende
gulzige strategie zou zijn om eerst de kant met het kleinste gewicht te kiezen en van daaruit verder
te werken, maar een zeer klein tegenvoorbeeld laat zien dat dat niet tot de optimale oplossing kan
leiden (zie opgave 6). De aanpak die Dijkstra koos is de volgende.

Aan het begin van de algoritme is er precies (cid:19)e(cid:19)en knoop waarvan we met zekerheid kunnen zeggen
wat de afstand tot S is, namelijk S zelf. Omdat alle afstanden in de graaf groter dan 0 zijn, kunnen
we geen korter pad naar S vinden dan het pad zonder kanten. De afstand van S tot S is dus met
zekerheid 0. Dit wetende, kunnen we van (cid:19)e(cid:19)en andere knoop de afstand tot S bepalen. S heeft
namelijk een aantal buren v1; v2; : : : ; vk, die allemaal door een kant met gewicht groter dan 0 met
S verbonden zijn. Elk pad naar een willekeurige knoop in de graaf (dus zeker naar v1; : : : ; vk) gaat
door (cid:19)e(cid:19)en van deze knopen. Als dus vm een buur van S is waarvan het gewicht van de verbindende
kant minimaal is, dan kan er geen pad in de graaf zijn dat korter is dan het gewicht van deze kant.
Kortom vm vormt samen met S een groep knopen waarvan we de afstand tot S in de graaf weten.
Noem deze groep knopen W . De algoritme breidt nu stap voor stap de verzameling W uit, totdat
alle knopen in de graaf in W zitten.

Op elk moment geldt dat we, kijkend naar de buren van knopen in W , zien dat we (cid:19)e(cid:19)en van
deze knopen ook het kortste pad in de graaf weten. Dat is namelijk van de knoop, v, waarvan de
afstand tot S, uitsluitend via knopen in W , minimaal is. Immers, als het korste pad van S naar v
niet uitsluitend via knopen in W zou lopen, dan zou het via een andere knoop w buiten W lopen.
Laat w zonder beperking der algemeenheid de eerste knoop zijn die op het korste pad naar v ligt
en niet in W zit. Dan loopt het pad van S naar w uitsluitend door knopen in W , en is korter dan
het pad dat uitsluitend door knopen in W naar v loopt, want v 6= w. Dat is in tegenspraak met de
manier waarop v gekozen is.

Voorbeeld 2.1.1: Beschouw de volgende graaf.

9

1

3

3

4

2

2

7

3

2

1

S

5

2

8

1

7

8

5

6

9

5

42

De algoritme van Dijkstra vindt achtereenvolgens de volgende afstanden

(cid:127)
(cid:127)
/
/
(cid:15)
(cid:15)
O
O
(cid:127)
(cid:127)
@
@
(cid:30)
(cid:30)
(cid:31)
(cid:31)
O
O
?
?
(cid:31)
(cid:31)
O
O
S
0
0
0
0
0
0
0
0
0
0

8

4

3

6

5

7

2
1
1 1 1 1 1 3 1 1 5
3 1 8 1 3 1 1 5
1
3 1 8 1 3
5
1
8 1 3
5
3
1
8 1 3
5
3
1
8 1 3
5
3
1
8 1 3
1
3
5
8 1 3
5
3
1
5
3
8
3
1
1
3
8
3
5

9 W
fSg
fS; 1g
fS; 1; 6g
fS; 1; 6; 2g
fS; 1; 6; 2; 8g
fS; 1; 6; 2; 8; 3g
fS; 1; 6; 2; 8; 3; 7g
fS; 1; 6; 2; 8; 3; 7; 9g
fS; 1; 6; 2; 8; 3; 7; 9; 4g
fS; 1; 6; 2; 8; 3; 7; 9; 4; 5g

5
5
5
5
5
5
5
5

4
4
4
4
4
4
4
4

5
5
5
5
5
5
5

11
11

2

2.1.4 Grafen: opspannende bomen

Een opspannende boom in een gewogen graaf is een deelverzameling van de kanten die samen een
boom vormen waarin alle knopen zijn opgenomen. Deze boom is niet noodzakelijk geworteld. De
meest voor de hand liggende toepassing van een opspannende boom is die van de netwerk (bij-
voorbeeld telefoon) verbinding. Tussen een aantal punten van het vlak zijn verbindingen mogelijk,
ieder met hun eigen kosten. Het vinden van een opspannende boom is dan het vinden van een
deelverzameling van de kanten zo dat elk van de punten door middel van een pad met elk ander
punt verbonden is, maar niet door twee paden. De kunst van de optimalisatie is hier natuurlijk het
vinden van een opspannende boom waarvan het totale gewicht minimaal is, de zogenoemde min-
cost spanning tree. Er zijn twee bekende gulzige algoritmen voor het vinden van de opspannende
boom, vernoemd naar de uitvinders van deze algoritmen. Beide algoritmen starten met een lege
verzameling kanten en breiden deze verzameling uit totdat een opspannende boom van minimale
kosten is gebouwd.

De algoritme van Prim

De opzet van de algoritme is simpel. Begin met de lege verzameling. Voeg een kant van minimaal
gewicht toe, dan hebben we een boom met 2 knopen. Als we een boom met k knopen hebben,
kunnen we een boom met k + 1 knopen krijgen door de minimale kant toe te voegen die deze boom
verbindt met een knoop die nog niet in de boom zit. Zo breiden we de boom uit totdat alle knopen
in de boom zijn opgenomen. Deze boom is ook van minimale kosten, maar dat zullen we voor beide
algoritmen tegelijkertijd bewijzen.

De algoritme van Kruskal

Ook hier beginnen we met een lege graaf en voegen we kanten toe, te beginnen met de kant van
minimaal gewicht. Orden de kanten naar gewicht en voeg een volgende kant (in de ordening)
aan de verzameling kanten toe als deze geen cykel introduceert. Als de graaf waarmee je begint
verbonden is, dan worden zo uiteindelijk alle knopen in de graaf met elkaar verbonden, en heb je een
opspannende boom. In tegenstelling tot Prim’s algoritme maken we ons niet druk om het bijhouden
van een gedeelte van een opspannende boom, maar laten we een bos ontstaan dat langzaamaan tot
een enkele boom aan elkaar groeit.

43

Correctheid

Dat deze algoritmen correct zijn volgt uit het feit dat ze beide de volgende invariant respecteren.
op elk tijdstip is de opgenomen verzameling kanten deelverzameling van de verzameling kanten van
een minimale opspannende boom. Merk op, er kan meer dan (cid:19)e(cid:19)en minimale opspannende boom
zijn. We zullen laten zien dat de invariant behouden blijft m.b.v. een inductief bewijs. Uiteraard
is voor beide algoritmen de invariant gerespecteerd aan het begin van de uitvoering. Immers de
verzameling kanten is leeg, en de lege verzameling is deelverzameling van elke verzameling. Stel nu
eens dat er ergens in de algoritme een punt t is waar de invariant niet meer gerespecteerd wordt,
en neem aan dat we de eerste keer bekijken dat een kant e wordt opgenomen die niet element
is van enige minimale opspannende boom. De verzameling van kanten die tot tijdstip t (cid:0) 1 was
opgenomen, Et(cid:0)1, was nog wel deelverzameling van een minimale opspannende boom, zeg Tt(cid:0)1.
Bekijk de verzameling T = Tt(cid:0)1 [ feg. Omdat Tt(cid:0)1 een boom is en e =2 Tt(cid:0)1 heeft T een cykel.

Laat Vt(cid:0)1 de verzameling eindpunten van Et(cid:0)1 zijn. Er is minstens (cid:19)e(cid:19)en punt op de cykel dat
niet in Vt(cid:0)1 zit. Immers e heeft maar (cid:19)e(cid:19)en eindpunt in in Vt (Prim) of de opname van e in stap t
introduceert geen cykel (Kruskal). Er is dus een kant e0 in T die Vt(cid:0)1 verbindt met de rest van de
boom. Het gewicht van deze kant is minstens zo groot als het gewicht van e, anders was e0 in stap
t gekozen. Dit betekent echter dat T (cid:0) fe0g een spanning tree is, waarvan de kosten hoogstens zo
groot zijn als die van T (cid:0) feg (en die dus ook een mincost spanning tree is) waarvan e een kant is.

Voorbeeld 2.1.2: We gebruiken als voorbeeld de volgende graaf.

3

2

1

0

5

2

2

7

3

1

2

5

6

9

5

3

1

5

4

8

7

8

2

1

3

3

4

9

Met de beide besproken algoritmen nemen we dan achtereenvolgens de volgende knopen en

kanten op.

44

knoop
0
1
2
5
3
6
8
9
7
4

Prim
kant
-
(0,1)
(1,2)
(0,5)
(2,3)
(0,6)
(6,8)
(6,9)
(6,7)
(5,4)

gewicht
0
1
3
5
7
10
11
12
14
17

Kruskal
kant

knoop

gewicht
0
1
2
3
5
7
9
11
14
17

-

(0,1)
(6,8)
(9,6)
(5,0)
(1,2)
(2,3)
(6,7)
(0,6)
(4,5)

0
1
6,8
9
5
2
3
7
-
4

Het toeval wil dat de algoritmen allebei dezelfde opspannende boom opleveren, namelijk de

volgende.

3

4

2

2

3

2

2

1

0

5

7

8

2

1

6

9

3

1

1

2

2.1.5 Scheduling

Bij het postkantoor staan mensen in een rij.
Iedereen wil natuurlijk zo snel mogelijk uit de rij
vandaan en daarom zou iedereen het eerst geholpen willen worden. Voor de beambte achter het loket
zal het om het even zijn wie eerst geholpen moet worden, want de totaal benodigde tijd om iedereen
te helpen is niet afhankelijk van in welke volgorde de personen in de rij moeten worden geholpen.
Toch maakt de volgorde iets uit omdat de verschillende handelingen een verschillende hoeveelheid
tijd kosten, en als de postzegels eerst verkocht worden dan moet de klant die het aangetekende stuk
wil verzenden daar weliswaar op wachten, maar als het aangetekende stuk verzonden moet worden,
moet de klant die de postzegels wil kopen d(cid:19)a(cid:19)ar op wachten. Kortom, behalve de nuttig bestede
tijd die kan worden afgemeten aan de werktijd van de beambte|deze is naar wij aannemen altijd
nuttig bezig|is er een hoeveelheid onnuttig bestede tijd, namelijk die de klanten op elkaar staan
te wachten. Ons eerste scheduling probleem is het minimaliseren van deze tijd.

Voorbeeld 2.1.3: Laat drie taken met hun tijdsduur gegeven zijn t1 = 5, t2 = 10 en t3 = 3. Er

45

zijn zes mogelijke volgordes waarin deze taken kunnen worden uitgevoerd.

Volgorde Tijd
123
132
213
231
312
321

5+(5+10)+(5+10+3)=38
5+(5+3)+(5+3+10)=31
10+(10+5)+(10+5+3)=43
10+(10+3)+(10+3+5)=41
3+(3+5)+(3+5+10)=29
3+(3+10)+(3+10+5)=34

2

In de eerste regel van dit voorbeeld is klant 1 het eerst aan de beurt, haar totale tijd in de rij is
dus 5, daarna komt klant 2 die eerst op klant 1 heeft moeten wachten zodat haar totale tijd in de
rij 15 is. Tenslotte komt klant 3 die eerst op klant 1 en klant 2 heeft moeten wachten zodat haar
totale tijd in de rij 18 is. In dit voorbeeld valt op dat de volgorde van behandelen waarbij de klant
die het minste tijd vraagt het eerst behandeld wordt, de minste totale wachttijd oplevert. Mogelijk
is dat ook de basis voor onze gulzige algoritme.

We bewijzen dit als volgt. Laat P = p1; p2 : : : ; pn een permutatie zijn van 1; : : : ; n en laat
si = tpi|de tijd die taak pi nodig heeft|zijn. Als de taken worden uitgevoerd in volgorde P dan
is de totale tijd die nodig is om alle taken uit te voeren

T (P ) = s1 + (s1 + s2) + (s1 + s2 + s3) + : : :
ns1 + (n (cid:0) 1)s2 + (n (cid:0) 2)s3 + : : :

Pn
k=1(n (cid:0) k + 1)sk

=
=

Stel dat P niet de taken in volgorde van benodigde tijd uitvoert, dan zijn er getallen a en b met
a < b en sa > sb. Als we alleen a en b verwisselen, dan krijgen we een nieuwe volgorde P 0 met
totale tijd

T (P 0) = (n (cid:0) a + 1)sb + (n (cid:0) b + 1)sa +

(n (cid:0) k + 1)sk:

nX

k=1

k6=a;b

We berekenen

T (P ) (cid:0) T (P 0) = (n (cid:0) a + 1)(sa (cid:0) sb) + (n (cid:0) b + 1)(sb (cid:0) sa)

=

(b (cid:0) a)(sa (cid:0) sb) > 0

Dus elk schema waarin twee taken worden uitgevoerd die niet in oplopende volgorde van de tijd

staan die die taken nodig hebben kost meer tijd dan (cid:19)e(cid:19)en waarin die taken wel in volgorde staan.

Deadlines

Allerlei ver(cid:12)jningen kunnen aan scheduling worden opgehangen. E(cid:19)en van de meest gebruikelijke is
dat taken niet onbegrensd lang op elkaar kunnen wachten. Aan elke taak kunnen we een \deadline"
hangen, dwz een tijdstip waarop de taak moet worden uitgevoerd om nog er nog pro(cid:12)jt van te
kunnen hebben. We maken de vereenvoudiging dat elke taak nu slechts (cid:19)e(cid:19)en eenheid tijd kost. Laat
di de deadline voor taak i zijn, die als zij v(cid:19)o(cid:19)or de deadline wordt uitgevoerd pro(cid:12)jt gi oplevert.
Laten we eens naar de volgende vier taken kijken.

46

i
gi
di

1
50
2

2
10
1

3
15
2

4
30
1

De deadlines in dit voorbeeld zijn zo strak gesteld dat er maar een paar mogelijke manieren zijn

om de taken uit te voeren. De overgebleven volgordes zien er als volgt uit.

Volgorde Opbrengst Volgorde Opbrengst

1
2
3
4
1,3

50
10
15
30
65

2,1
2,3
3,1
4,1
4,3

60
25
65
80
45

We noemen een deelverzameling van de taken uitvoerbaar als er een volgorde is waarin elk van de
taken in deze deelverzameling kan worden uitgevoerd voor zijn deadline. Een voor de hand liggende
gulzige algoritme om ons probleem op te lossen is nu|beginnend met de lege verzameling|telkens
de taak met de grootste opbrenst aan de verzameling toe te voegen zodat de samengestelde verza-
meling uitvoerbaar blijft, totdat dit niet meer mogelijk is. In het voorbeeld zouden we eerst taak 1
kiezen en daar vervolgens taak 4 aan toe kunnen voegen omdat de volgorde 4,1 uitvoerbaar is. De
volgende taak zou taak 3 zijn, maar f1; 3; 4g is niet uitvoerbaar en ook f1; 2; 4g is niet uitvoerbaar,
dus deze algoritme eindigt met f1; 4g. Vindt deze algoritme altijd een optimaal schema?

Eerst merken we op dat als we een verzameling taken hebben dat uitvoerbaar is en we willen er
een nieuwe taak aan toevoegen, dat we dan niet alle permutaties hoeven na te gaan om te zien of
de nieuwe verzameling uitvoerbaar is. Dit wegens de volgende eigenschap.

Als J een verzameling van k taken is, genummerd d1 (cid:20) : : : (cid:20) dk dan is J uitvoerbaar

als en alleen als de volgorde 1; 2; : : : ; k uitvoerbaar is.

Het is duidelijk dat de verzameling uitvoerbaar is als de volgorde 1; : : : ; k uitvoerbaar is. Om-
gekeerd als 1; 2; : : : ; k niet uitvoerbaar is, dan wordt in die volgorde tenminste (cid:19)e(cid:19)en taak na zijn
deadline gepland. Als r zo’n taak is dan is dus dr (cid:20) r (cid:0) 1. Aangezien de taken in de volgorde van
niet-dalende deadlines zijn gerangschikt betekent dat dat tenminste r taken een deadline kleiner
dan of gelijk aan r (cid:0) 1 hebben. Hoe je die ook rangschikt, er komt er dan altijd (cid:19)e(cid:19)en te laat.

De gulzige algoritme hierboven geschetst vindt altijd de optimale volgorde.

I en S0

J voorkomt in S0

Stel dat deze algoritme (cid:19)e(cid:19)en of andere volgorde I kiest die niet optimaal is. Er is een andere
volgorde J die wel optimaal is. Zet de volgordes SI en SJ onder elkaar, mogelijk met gaten. We
herschikken de taken in SI en SJ , ook mogelijk met gaten, zodat uitvoerbare volgordes S0
I en S0
J
ontstaan, waarin elke taak die S0
J recht onder dezelfde taak in S0
I staat.
Dat dit kan is als volgt in te zien. Stel dat taak a in SI en SJ voorkomt. op plaatsen tI en tJ
respectievelijk. Als tI = tJ is er niets te doen, stel daarom dat tI < tJ . De deadline voor a is niet
eerder dan tJ . We kunnen nu a in SI verplaatsen naar tJ . Als er in SI een gat zit op plaats tJ ,
dan is er niets meer te doen. Als op plaats tJ een taak b staat, dan verwisselen we a en b. De taak
b wordt dan naar voren gehaald in de volgorde, en dat kan zeker niet tot onuitvoerbaarheid leiden.
Nu we aldus alle gemeenschappelijke taken op dezelfde plaats hebben gezet zijn dus de overige
taken (inclusief gaten) die tegenover elkaar staan verschillend. Stel er is een tijdstip t waarop in S0
een taak a staat en in S0

I

J iets anders.

47

1. Als op tijdstip t = t1 een gat in S0

J zit, dan zit a nergens in S0

J en kan a worden toegevoegd
waardoor de opbrengst in J0 stijgt. Dit is in tegenspraak met de vooronderstelde optimaliteit
van SJ .

2. Als a een gat is op t = t2 en ertegenover staat een taak b, dan is de verzameling I [ fbg een
uitvoerbare verzameling en heeft de gulzige algoritme geen geldige reden om te stoppen na de
vorming van I.

3. De overgebeleven mogelijkheid is dat tegenover een werkelijke taak a0 op t = t3 een werkelijke

taak b0 staat. Dan staat a0 niet in J en b0 niet in I. Er zijn dan drie mogelijkheden.
(a) ga0 > gb0, dan kan b0 vervangen worden door a0 en de opbrengst van J vergroot worden.

Dit is in tegenspraak met de optimaliteit van J.

(b) ga0 < gb0, maar dan is I (cid:0)fa0g[fb0g uitvoerbaar en ga0 < gb0 dus als de gulzige algoritme

a0 kiest, dan kiest zij b0. Tegenspraak.

(c) ga0 = gb0.

S0
S0

I

J

: : :
: : :

t1
a

t2

b

t3
: : : a0
b0
: : :

: : :
: : :

: : :
: : :

De enige manier waarop I en J dus kunnen verschillen is als ze verschillende taken hebben met

dezelfde opbrengst, maar dan zijn hun totale opbrengsten natuurlijk ook gelijk.

Meerdere Verwerkingseenheden

Tot hier hebben we het gehad over taken die moeten worden uitgevoerd door (cid:19)e(cid:19)en verwerkingseen-
heid. We kunnen ons echter een postkantoor voorstellen waar meerdere beambten aan een balie
staan. Iedere beambte kan in principe elke klant helpen, en de klant wordt geholpen door de eerst-
volgende vrijkomende beambte. Gebruikelijk is in dit systeem dat de klanten worden afgehandeld
in volgorde van binnenkomst, maar is dit ook optimaal?
Ons model is een verzameling van machines die allemaal elke taak van een verzameling taken
uit f1; : : : ; ng kunnen uitvoeren. De eenvoudigste vorm van het probleem is die waarbij elke uit te
voeren taak een starttijd si en een eindtijd ti heeft. Het optimaliseringsprobleem is het gebruiken
van een minimaal aantal machines om alle taken uit te voeren. Het is duidelijk dat twee taken niet
op dezelfde machine kunnen worden uitgevoerd, als de tijd waarin ze worden uitgevoerd overlapt.
De voor de hand liggende strategie is dus de taken net zolang aan een gegeven verzameling machines
toe te wijzen totdat het niet meer mogelijk is om een nieuwe taak aan (cid:19)e(cid:19)en van de machines uit de
verzameling toe te wijzen. Dan schakelen we een nieuwe machine in. Om deze algoritme geordend
uit te voeren, ordenen we eerst de taken naar starttijd en voegen de taken in die volgorde in. Deze
strategie blijkt in dit geval ook optimaal. Dit kunnen we als volgt bewijzen.
Stel onze algoritme vindt voor de taken f1; : : : ; ng, waarbij de starttijden oplopend, dat er k
machines nodig zijn. We moeten laten zien dat het niet met minder kan. Laat taak i de taak
zijn waarvoor de k-de machine erbij is geroepen. Taak i kon niet worden uitgevoerd op machines
1; : : : ; k (cid:0) 1 dus moet er aan elk van deze machines een taak toegewezen Tj zijn die een con(cid:13)ict
heeft met taak i. De starttijd van elke Tj moet liggen voor si, want Tj was eerder ingedeeld en de
lijst met taken is gesorteerd. De eindtijd van elke Tj moet liggen n(cid:19)a si, anders was er niet met elke

48

machine een con(cid:13)ict. We zien dat deze k (cid:0) 1 taken niet alleen een con(cid:13)ict hebben met de i-de taak,
maar ook met elkaar . Immers het tijdstip si komt in al deze taken voor. In totaal hebben we dus
een verzameling van k taken die paarsgewijs een con(cid:13)ict hebben. Zo’n verzameling taken kan niet
op k (cid:0) 1 machines worden uitgevoerd.

Op het thema scheduling bestaan enorm veel variaties. Jobs kunnen eenheid tijd nemen of een
tijdsinterval. Er zijn situaties waarin elk van de jobs op elke machine kunnen worden uitgevoerd,
en er zijn scenario’s waarin elke job zijn eigen soort machine heeft. Een job kan op (cid:19)e(cid:19)en machine
worden uitgevoerd en is dan klaar of een job kan langs meerdere machines moeten. Het kan zo
zijn dat een job die eenmaal op een machine is gestart ook afgemaakt moet worden of een job kan
onderbroken worden en later weer opgepakt etc. etc. Voor lang niet alle van deze problemen bestaan
gulzige algoritmen. Veel van deze problemen zijn zo moeilijk dat er alleen maar exponenti(cid:127)ele tijd
begrensde algoritmen voor bestaan. Verder kunnen de problemen ook nog op andere manieren
als optimaliseringsproblemen worden voorgesteld dan het minimaliseren van het aantal gebruikte
machines. Je kunt ook bijvoorbeeld de totale overschrijding van de deadlines minimaliseren of de
totaal gebruikte tijd op alle machines. Kortom de variaties zijn eindeloos en dit onderwerp is een
actief onderwerp van research.

2.1.6 Sommen

1. Laat zien dat het systeem van euromunten de eigenschap heeft dat de gulzige algoritme voor
het teruggeven van een bepaald bedrag altijd het minimum aantal munten vindt. Aanwijzing.
Gebruik een Lemma dat zegt dat er voor elke muntwaarde, behalve de grootste, een maximum
aantal munten is dat in de optimale oplossing kan zitten.

2. Bedenk een systeem van muntwaarden waarbij de gulzige algoritme uit deze sectie niet tot

een optimale oplossing leidt.

3. Toon aan dat de gulzige algoritme voor knapsack waarbij eerst zoveel mogelijk van het object

met de grootste waarde/gewicht ratio altijd leidt tot een optimale oplossing.

4. Laat P1; : : : ; Pn een verzameling programmas zijn die op een schijf worden opgeslagen. Pro-
gramma Pi heeft si megabyte ruimte nodig. De capaciteit van de schijf is D megabyte, waar

(a) Kunnen we een gulzige algoritme gebruiken om zoveel mogelijk programma’s op de schijf

(b) Kunnen we een gulzige algoritme gebruiken om zoveel mogelijk megabyten van de schijf

D <P si.

op te slaan?

te gebruiken?

5. Gegeven zijn de lijsten L1, L2, L3 en L4 met respectievelijke lengten 10, 20, 30, 40.

(a) Neem aan dat de kosten van het samenvoegen van twee lijsten evenredig is met de
lengte van de resulterende lijst, en dat we niet meer dan twee lijsten in (cid:19)e(cid:19)en keer kunnen
samenvoegen. Wat is de optimale volgorde om L1; : : : ; L4 tot (cid:19)e(cid:19)en lijst L samen te voegen?
lijsten L1; : : : ; Ln van

(b) Beschrijf een greedy algoritme voor het algemene geval:

input:

verschillende lengte; output: (cid:19)e(cid:19)en lijst L

(c) Bewijs dat deze algoritme optimaal is; dwz. dat het gebruikte aantal bewerkingen mini-

maal is.

49

6. Geef een voorbeeld van een graaf waaruit blijkt dat bij het zoeken naar het kortste pad in de
graaf het altijd kiezen van de kant met het kleinste gewicht niet tot een optimale oplossing
leidt.

7. Als een graaf negatieve kanten heeft, is het vinden van een opspannende verzameling van
minimale kosten nog steeds zinvol. De opspannende structuur hoeft dan niet noodzakelijk
meer een boom te zijn. Hoe kunnen we onze algoritmen aanpassen zodat ze het gewenste
resultaat opleveren?

8. Een graaf hoeft niet noodzakelijke (cid:19)e(cid:19)en minimale opspannende boom te hebben. Wanneer is

dit wel het geval? Geef een bewijs.

9. Een Dijkstra boom is een boom die bestaat uit een punt v en verder alle kortste paden van
v naar de knopen in de graaf. (Waarom is dat een boom?). Laat zien dat voor een gegeven
graaf een Dijkstra boom niet altijd een minimale opspannende boom is, maar dat een Dijkstra
boom wel altijd minstens (cid:19)e(cid:19)en kant gemeen heeft met een minimale opspannende boom.

10. In een bepaald gebied bevinden zich n draadloze stations. Elk station heeft zijn eigen com-
municatiesnelheid. Als een snel station met een langzaam station praat, dan moet de snelheid
van de communicatie aangepast worden aan het langzame station. Men wil een topologie
schetsen waarbij vanaf (cid:19)e(cid:19)en punt elk station kan worden bereikt (en dus elk station met min-
stens (cid:19)e(cid:19)en ander station praat) en waarbij de gemiddelde snelheid zo hoog mogelijk is. Bedenk
een greedy algoritme voor dit probleem. U mag hierbij het vertragende e(cid:11)ect van het praten
van (cid:19)e(cid:19)en station met meerdere andere verwaarlozen (en dus aannemen dat een snel station met
meerdere snelheden kan communiceren).

Programmeren

1. Een verladingsbedrijf onderhoudt diensten tussen Rotterdam en Scha(cid:11)hausen, beide gelegen
aan de Rijn. Het bedrijf heeft 10 schepen met verschillende capaciteiten van twee t.e.m.
tien ton. Een schip dat twee keer zo zwaar is doet anderhalf keer zo lang over de reis. Van
Amsterdam naar Sha(cid:11)hausen vervoert het bedrijf tarwe, rijst en mais, en in omgekeerde
richting rogge, grind en zand. De winst per 100 kilo is respectievelijk 1, 3 en 4 euro voor
tarwe rijst en mais, en 2, 5 en 0.5 euro rogge, grind en zand, en we houden er in de simulatie
geen rekening mee dat schepen moeten worden schoongemaakt voordat ze de terugweg met
een nieuwe lading kunnen aanvaarden. Experimenteer met verschillende verladingsstrategieen
(hoge winst in grote schepen, snelle schepen etc.) en bereken de winst. Tekent er zich een
gulzige algoritme af? U hoeft hier geen bewijzen te geven.

2.2 Verdeel en Heers

Verdeel en heers is een adagium dat teruggaat tot de oude Romeinen (divide et impera). De
betekenis van dat adagium is tot op zekere hoogte vergelijkbaar met de betekenis die we er in de
hedendaagse algoritmiek aan hechten. De Romeinen waren erop gericht de tegenstanders uit elkaar
te spelen, zodat ze met elkaar veel meer dan met de Romeinen oorlog zouden voeren waardoor de
Romeinen hun macht konden handhaven. In de algoritmiek willen we een enkel groot probleem graag
uit elkaar trekken in kleinere deelproblemen die gemakkelijk te hanteren zijn. De oplossingen voor

50

de kleine deelproblemen samen vormen dan een oplossing voor het grote probleem. Als voorbeeld
gebruiken we het voorbeeld van de volledige inductie gegeven in Sectie 1.4 op pagina 29. Het
probleem is het volleggen van een vierkant met L vormige (cid:12)guren, en het probleem is simpel als het
vierkant afmetingen 2(cid:2) 2 heeft. Een verdeel-en-heersalgoritme dat dit probleem oplost voor grotere
Inductie, verdeel en heers, en recurrente betrekkingen
vierkanten gaat (dus) als in Figuur 2.1.

Leg de enige L zo dat de opening op i,j komt.

1: Square(n; i; j)
2: if n = 2 then
3:
4: else
5:
6:
7:

do 4 times
set(i0, j0);
call Square(n/2,i’,j’);
end do 4 times
put results together;
return(result);

8:
9:
10:
11: end if

Figuur 2.1: Recursieve algoritme voor de L-overdekking

gaan in de algoritmiek hand in hand. De inductie levert het bewijs van correctheid, de verdeel-
en-heersstrategie levert de oplossing voor het probleem, en de bijbehorende recurrente betrekking
levert de complexiteit van de algoritme. Niet altijd is het e(cid:14)ci(cid:127)ent om een verdeel-en-heersstrategie
toe te passen, ook al ligt die voor de hand. In Hoofdstuk 1 hebben we daar (pagina 23) al een
afschrikwekkend voorbeeld van gezien. Soms echter is verdeel en heers de enige manier om een
probleem te behappen en soms ook levert het wel degelijk een e(cid:14)ci(cid:127)entere algoritme dan de voor de
hand liggende. Een beroemd geworden voorbeeld hiervan is de matrixvermenigvuldigingsalgoritme
van V. Strassen [Str69].

2.2.1 Matrixvermenigvuldiging
Stel we hebben twee n(cid:2)n matrices A en B die we met elkaar willen vermenigvuldigen. De algoritme
om dat te doen is dat we van matrix A steeds een rij vector nemen en van matrix B een kolomvector
en van deze twee vectoren het inproduct bepalen. Zo geeft het inproduct van de ide rij van A en
de jde kolom van B het element i; j van de productmatrix C. De complexiteit van deze algoritme
is n3. Immers, we moeten n2 inproducten bepalen en elk inproduct kost n vermenigvuldigingen.
Er is een andere methode, gebaseerd op het verdeel-en-heersprincipe die een e(cid:14)cientere algoritme
oplevert.

Wanneer we voor het gemak aannemen dat n een 2-macht is, n = 2k dan zien we dat we
matrix A in vier deelmatrices kunnen verdelen A1; : : : ; A4 en ook matrix B in B1; : : : ; B4, met de
eigenschap dat we de productmatrix C ook kunnen bepalen door 8 matrixvermenivuldigingen(zie
Figuur 2.2). Immers, C1 = A1 (cid:2) B1 + A2 (cid:2) B3, C2 = A1 (cid:2) B2 + A2 (cid:2) B4, C3 = A3 (cid:2) B1 + A4 (cid:2) B3 en
C4 = A3 (cid:2) B2 + A4 (cid:2) B4. Bovendien is bij deze vermenigvuldiging de aanname van commutativiteit
niet nodig, zodat ze inderdaad voor matrixvermenigvuldiging geldig is.

We kunnen dus in plaats van de standaardalgoritme voor matrixvermengivuldiging een verdeel-
en-heersstrategie implementeren die steeds kleinere (vierkante) matrices met elkaar vermenigvul-
digt, waarbij het triviale geval de vermenigvuldiging van (cid:19)e(cid:19)en bij (cid:19)e(cid:19)en matrices is. De recurrente

51

(cid:18) A1 A2

A3 A4

(cid:19) (cid:18) B1 B2

(cid:19)

B3 B4

(cid:18) C1 C2

C3 C4

(cid:19)

=

Figuur 2.2: Onderverdeling bij matrixvermenigvuldiging

betrekking die bij deze algoritme hoort is T (n) = 8T (n=2). Wanneer we deze betrekking oplossen
zien we T (n) 2 O(n3) zodat de verdeel-en-heersstrategie hier wel een andere, maar niet meteen
een betere algoritme oplevert. Het probleem zit in het aantal recursieve aanroepen van de matrix-
vermenigvuldigingsalgoritme dat gedaan wordt. Als we op dit aantal zouden kunnen bezuinigen,
dan zou de algoritme sneller worden. Dit is precies de observatie die V. Strassen [Str69] heeft
gedaan. In plaats van met 8 kunnen we, door slim eerder verkregen tussenresultaten te gebruiken,
toe met zeven vermenigvuldigingen, waardoor de complexiteit van de algoritme daalt naar nlog 7,
een beduidend e(cid:14)ci(cid:127)entere algoritme.

De zeven producten zijn de volgende.
1. M1 = A1(B2 (cid:0) B4) = A1B2 (cid:0) A1B4
2. M2 = (A1 + A2)B4 = A1B4 + A2B4

3. M3 = (A3 + A4)B1 = A3B1 + A4B1
4. M4 = A4(B3 (cid:0) B1) = A4B3 (cid:0) A4B1
5. M5 = (A1 + A4)(B1 + B4) = A1B1 + A1B4 + A4B1 + A4B4
6. M6 = (A2 (cid:0) A4)(B3 + B4) = A2B3 (cid:0) A2B4 (cid:0) A4B3 (cid:0) A4B4
7. M7 = (A1 (cid:0) A3)(B1 + B2) = A1B1 + A1B2 (cid:0) A3B1 (cid:0) A3B2
Waarna de productmatrix wordt

(cid:18) M5 + M4 (cid:0) M2 + M6

M3 + M4

C =

M1 + M2

M1 + M5 (cid:0) M3 (cid:0) M7

(cid:19)

:

C1 = A1B1 + A1B4 + A4B1 + A4B4 + A4B3(cid:0) A4B1(cid:0) A1B4 + A2B4 + A2B3(cid:0) A2B4(cid:0) A4B3(cid:0) A4B4
C2 = A1B3 (cid:0) A1B4 + A1B4 + A2B4
C3 = A3B2 + A4B1 + A4B3 (cid:0) A4B1
C4 = A1B2 (cid:0) A1B4 + A1B1 + A1B4 + A4B1 + A4B4 (cid:0) A3B1 + A4B1 (cid:0) A1B1 (cid:0) A1B2 + A3B1 (cid:0) A3B2

2.2.2 Zoeken en sorteren

Een zeer bekend voorbeeld van een probleemgebied waar de verdeel-en-heersstrategie succesvol is, is
het zoeken en sorteren. In het voorwoord van \The Art of Computer Programming, Vol. 3" [Knu73]
zegt Donald E. Knuth: \...Indeed, I believe that virtually every important aspect of programming
arises somewhere in the context of sorting or searching!". Het hele deel 3 is dan ook aan zoeken
en sorteren gewijd.
Intussen, meer dan 30 jaar later, zijn er meer toepassingen van program-
meertechnieken gekomen, maar toch is zoeken en sorteren nog een zeer belangrijk onderwerp in

52

de informatica. Moderne ontwikkelingen als het internet hebben zoektechnieken alleen nog maar
belangrijker gemaakt. Wij zullen hier niet honderden pagina’s aan zoeken en sorteren wijden, maar
we zullen wel in het kader van de verdeel-en-heerstechniek een paar van de bekendste algoritmen
bespreken.

zoeken: binary search

We zullen steeds doen alsof de invoer voor zoek en sorteeralgoritmen bestaat uit een rij getallen.
De complexiteit van de algoritme zullen we dan uitdrukken in het aantal getallen. De lengte van
de invoer hangt hiermee wel samen maar is hieraan niet gelijk. Als er n getallen op de invoer
staan die in m bits kunnen worden uitgedrukt is de lengte van de invoer natuurlijk nm en niet n.
Toch zullen we de probleemgrootte hier voor het gemak met n aanduiden. Bij het zoeken in een rij
getallen naar een gegeven getal maakt het een dramatisch verschil of de gegeven rij gesorteerd is of
niet. In een ongesorteerde rij is het enige dat we kunnen doen vooraan de rij beginnen en deze van
voor naar achter onderzoeken totdat we het getal gevonden hebben of niet. Worst case kost dus
het doorzoeken van n getallen (cid:18)(n). Dat deze ondergrens geldt is te bewijzen met een zogenoemd
\adversary argument". Voor elke methode die in (cid:19)e(cid:19)en of andere volgorde de rij doorzoekt, is er een
rij die het gezochte getal als laatste in deze volgorde heeft staan. Voordat alle getallen zijn bekeken
kun je dus onmogelijk zeggen of het gezochte getal in de rij staat of niet. In het bijzonder als dat
getal niet in de rij staat.

De situatie wordt heel anders wanneer de rij getallen gesorteerd is. We kunnen nu gebruik
maken van een vergelijking van de getallen en bijvoorbeeld concluderen dat als een het gezochte
getal groter is dan dan een getrokken getal uit de gesorteerde rij, het getal ook groter zal zijn dan
alle getallen die in de rij daarvoor komen. Dus die getallen hoeven dan niet meer bekeken te worden.
Deze observatie geeft aanleiding tot de zoekalgoritme die bekend staat als binary search.

1: input: een rij getallen row[1 : : : n]; een getal k
2: min=1, max=n
3: while min < max do
4:

middle=bmin + max =2c;
if row[middle] == k then

5:
6:
7:
8:
9:
10:

return(middle);

end if
if row[middle] > k then

max=middle;

end if
if row[middle] < k then

min=middle;

11:
12:
end if
13:
14: end while
15: return(not found);

De recurrente betrekking die bij deze zoekmethode hoort is T (n) = T (n=2) + c, waaruit volgt

dat de tijdcomplexiteit van deze algoritme O(log n) is.

53

sorteren: quicksort

Net als bij zoeken is de divide en conquer methode ook bij sorteren zeer in trek. Een in de praktijk
veelgebruikte zoekmethode is quicksort. Deze methode heeft een worst-case complexiteit van O(n2),
dus behoort de methode eigenlijk tot de \dommere" sorteeralgoritmen. Niettemin is ze zeer populair
omdat ze eenvoudig te implementeren is, en in de praktijk vrijwel altijd veel goedkoper is dan O(n2).
De average case complexiteit van deze sorteermethode is O(n log n), zoals we hieronder zullen zien.
Eerst bespreken we de methode. Uitgangspunt is dat een rij getallen die bestaat uit 1 element
gesorteerd is. Een rij van n getallen kunnen we in twee rijen verdelen door een element uit de rij
te kiezen, vervolgens alles dat kleiner dan dat element is in de eerste rij op te slaan en alles dat
groter dan of gelijk is aan dat element in de tweede rij op te slaan. Als we vervolgens de aldus
geconstrueerde rijen sorteren en aan elkaar plakken, dan is de hele rij gesorteerd. Het element dat
we kiezen om de twee deelrijen te maken zullen we de as noemen. In algoritmische vorm:

1: function Sort( row[1; : : : ; n])
2: if n > 1 then
3:
4:
5:
6:
7:

Choose 1 (cid:20) k < n;
row1=frow[i] : row[i] < row[k]g;
row2=frow[i] : row[i] (cid:21) row[k] ^ i 6= kg;
Sort(row1);
Sort(row2);
return(concatenate(row1,row[k],row2);

8:
9: else return(row);
10: end if

De kosten van deze algoritme zijn zeer afhankelijk van een goede keuze van de as, row[k]. We
zien dat het mogelijk is deze telkens zo ongelukkig te kiezen dat de bovengrens op de complexiteit
kwadratisch wordt. Als de as telkens zo gekozen wordt, dat alle overige elementen ofwel in row1
ofwel in row2 terechtkomen, dan is T (n) = T (n (cid:0) 1) + n (cid:0) 1 en deze recurrente betrekking heeft
de afschatting T (n) = (cid:18)(n2). Alleen als de beide rijen een constante fractie van de oorspronkelijke
rij zijn, dan wordt een betere grens bereikt. Immers T (n) = T (n=c) + T (n (cid:0) n=c) + O(n) heeft
een O(n log n) afschatting. We zullen bewijzen dat dit in het gemiddelde geval, bij een uniforme
distributie over alle mogelijke ongesorteerde (en een gesorteerde) rijen geldt.
Er zijn n! mogelijke volgorden waarin de getallen (laten we voor het gemak 1; : : : ; n aannemen)
kunnen staan. Laat Ri de rij in volgorde i voor i (cid:20) n! zijn, T (Ri) is dan de tijd die het kost om Ri
met quicksort te sorteren. De gemiddelde tijd T is dan
. Als bekend is op welke plaats
Pn
de as in Ri thuishoort, kunnen we de kosten van het sorteren van Ri bepalen. Dat is namelijk
T (Ri1) + T (Ri2) + n(cid:0) 1. Als Ri uniform verdeeld is, dan is elke plaats voor de as in de gesorteerde
j=0 T (Ri[1; : : : j (cid:0) 1]) + T (Ri[j + 1; : : : n]) + n (cid:0) 1.
rij even waarschijnlijk, en is dus T (Ri) = 1
n
Merk op dat het geval dat de hele rij recursief wordt doorgegeven in de procedure hier ook wordt
meegenomen. Aangezien Ri uniform verdeeld is, zijn de beide deelrijen ook uniform verdeeld, dat
wil zeggen voor elke plaats i heeft elk element dezelfde kans om op plaats i te staan. We kunnen
dus voor een willekeurige rij Ri ook stellen T (n) = n (cid:0) 1 +
. Nu merken we op

P
i=1 T (i(cid:0)1)+T (n(cid:0)i)

Pn!

i=1 T (Ri)

n!

datPn

i=1 T (i (cid:0) 1) =Pn

i=1 T (n (cid:0) i).

We herschrijven de uitdrukking voor T (n) tot:

T (n) = n (cid:0) 1 + 2=n

T (i (cid:0) 1)

;

n

!

  nX

i=1

54

met T (0) = T (1) = 0:

Vermenigvuldigen met n levert

nT (n) = n(n (cid:0) 1) + 2

T (i (cid:0) 1):

nX

i=1

n(cid:0)1X

i=1

Dus ook dat

(n (cid:0) 1)T (n (cid:0) 1) = (n (cid:0) 1)(n (cid:0) 2) + 2

T (i (cid:0) 1):

Trekken we deze twee van elkaar af, dan zien we dat

nT (n) (cid:0) (n (cid:0) 1)T (n (cid:0) 1) = n(n (cid:0) 1) (cid:0) (n (cid:0) 1)(n (cid:0) 2) + 2T (n (cid:0) 1)

Ofwel

T (n) = (1 +

1
n

)T (n (cid:0) 1) + (2 (cid:0) 2
n

)

Substitueer T (n) = (n + 1)yn en we krijgen

Uitrollen van deze recurrentie geeft

yn = yn(cid:0)1 +

2(n (cid:0) 1)
n(n + 1)

yn =

2Pn
= 2Pn
= 2Pn

j(cid:0)1
j(j+1)
j+1 (cid:0) 1
j g
j (cid:0) 4n

n+1

1

j=1

j=1f 2

j=1

Dus is T (n) = 2(n + 1)Pn

sorteren: mergesort

1

j (cid:0) 4n, waaruit volgt dat T (n) 2 O(n log n).

j=1

De toepassing van verdeel en heers die we als laatste voorbeeld bespreken heeft een O(n log n)
bovengrens, en kan dus, gegeven de volgende sectie worden geklassi(cid:12)ceerd als de meest e(cid:14)ci(cid:127)ente
sorteermethode. Dat deze methode in de praktijk toch niet het meest wordt toegepast is gelegen in
het feit dat quicksort toch in de meeste gevallen een O(n log n) performance haalt en bovendien zeer
eenvoudig te implementeren is. De gedachte achter mergesort is weer dat een rij die bestaat uit (cid:19)e(cid:19)en
element al gesorteerd is, en dat bovendien twee gesorteerde rijen van gelijke lengte kunnen worden
samengevoegd tot (cid:19)e(cid:19)en gesorteerde rij van de dubbele lengte door steeds het kleinste element van de
twee rijen eruit te halen en op te slaan. Aangezien de twee rijen gesorteerd zijn, kan het kleinste
element in O(1) tijd gevonden worden en dus kunnen de rijen tot (cid:19)e(cid:19)en rij worden samengevoegd in
O(n) tijd. De sorteeralgoritme bestaat dan uit het herhaaldelijk in twee gelijke (of bijna gelijke)
delen splitsen van een rij, de twee verkregen deelrijen op dezelfde manier sorteren, en vervolgens de
twee gesorteerde rijen samen te voegen. In pseudotaal:

1: Sort(row[1,. . . ,n])

55

row1=row[1; : : : ;bn=2c];
row2=row[bn=2c + 1; : : : ; n];
row1=Sort(row1);
row2=Sort(row2);
return(Merge(row1,row2);

2: if n > 2 then
3:
4:
5:
6:
7:
8: else
9:
10: end if

return(row);

De routine Merge wordt dan als volgt.
1: Merge(row1[1; : : : ; n]; row2[1; : : : ; m])
2: while notempty(row1) and notempty(row2) do
3:
4:
5: end while
6: return(row);

pick the minimal element from row1 and row2;
add it to row;

Voor het sorteren van een rij van lengte n wordt dus twee keer de routine Sort op rijen van
lengte ongeveer n=2 aangeroepen en (cid:19)e(cid:19)en keer de routine Merge op twee rijen van lengte ongeveer
n=2. De recurrente betrekking die hierbij hoort is T (n) = 2T (n=2) + O(n), waaruit een O(n log n)
worst case bovengrens volgt.

sorteren: (cid:10)(n log n) ondergrens

Het sorteren volgens MergeSort levert een worst case bovengrens die gelijk is aan de ondergrens
die geldt voor sorteren in het algemeen, als dat sorteren tenminste gebaseerd is op vergelijken van
twee elementen uit de te sorteren rij. Er zijn nog e(cid:14)cientere methoden denkbaar, bv. radix sort1,
maar deze sorteermethoden zijn doorgaans op andere principes gestoeld dan de vergelijking van
twee elementen in de rij.

Voor sorteermethoden die gebaseerd zijn op vergelijken en verplaatsen van elementen is (cid:10)(n log n)
een ondergrens. We kunnen dit als volgt inzien. Beschouw de te sorteren rij als een rij getallen die
in een boomstructuur gevoerd wordt, waarbij elke rij langs een pad naar beneden loopt. In elke
knoop langs het pad wordt op een rij een operatie (vergelijking, verplaatsing) uitgevoerd, waardoor
uiteindelijk in het blad horende bij het gevolgde pad de gesorteerde rij staat. Twee verschillende
rijen moeten een verschillend pad volgen. Immers als op twee verschillende rijen verschillende ope-
raties uitgevoerd worden, kunnen ze niet allebei door dezelfde serie operaties (verandering van de
volgorde) gesorteerd worden. Aangezien er n! volgorden zijn, moet de boom dus n! bladeren hebben.
Dientengevolge is er een pad in de boom van lengte (cid:10)(log n!) = (cid:10)(n log n).

1Bij radix sort wordt er net zoveel geheugen gereserveerd als de grootte van het maximale element in de rij.
Vervolgens wordt voor ieder element dat wordt aangetro(cid:11)en in de rij een boolese waarde in het bijbehorende geheugen
op true gezet, en vervolgens wordt het hele array nagelopen en wordt het adres van de elementen die op true staan
in een gesorteerde rij geconcateneerd. Soms is deze methode e(cid:14)cient. Immers de complexiteit is lineair in de waarde
van het grootste element, en bovendien is het geheugengebruik ook lineair in de waarde van dit getal. Als die waarde
vergelijkbaar is met het aantal elementen in de rij, dan hebben we dus een lineaire sorteermethode. Echter, aangezien
een getal n met log n bits te representeren is, kan deze sorteermethode ook exponentieel zijn.

56

2.2.3 Sommen

1. Laat T [1::n] een gesorteerd array van verschillende integers zijn, die positief of negatief mogen

zijn. Geef een O(log n) algoritme die een index i vindt met T [i] = i, als zo’n index bestaat.

2. Stel er zijn drie algoritmen om hetzelfde probleem aan te pakken.

(cid:15) Algoritme A lost het probleem op door het in vijf deelproblemen te verdelen, die recursief

op te lossen en de oplossingen in lineaire tijd te combineren.

(cid:15) Algoritme B lost problemen van grootte n op door twee deelproblemen van grootte n(cid:0) 1

op te lossen en vervolgens de oplossingen in constante tijd te combineren.

(cid:15) Algoritme C lost problemen van grootte n op door ze in negen deelproblemen van groote
n=3 te verdelen, die recursief op te lossen en dan de oplossingen in O(n2) tijd te combi-
neren.

Welke algoritme kiest je en waarom?

3. Een staafdiagram wordt door een programma geproduceerd op een n (cid:2) n vierkant. Bedenk

een algoritme die de langste staaf in het diagram vindt in O(n) (dus niet O(n2)) tijd.

4. Een onverlaat heeft de potjes babyvoeding in een supermarkt ge(cid:127)(cid:16)nfecteerd. Er wordt besloten
het ge(cid:127)(cid:16)nfecteerde potje te vinden door proefdieren in te zetten. De incubatietijd van het virus
is 48 uur. De dierenbescherming ziet de noodzaak van het zo snel mogelijk identi(cid:12)ceren van
het besmette potje en het onderzoek op vingerafdrukken wel in, maar eist toch dat er niet
meer dan O(log n) proefdieren per n potjes worden gebruikt. Kan het besmette potje binnen
50 uur gevonden worden?

5. Een spel van n kaarten bevat verschillende afbeeldingen. Het spel heeft een grote deelverza-
meling als n=2 of meer kaarten dezelfde afbeelding hebben. Geef een O(n log n) algoritme die
bepaalt of het spel een grote deelverzameling heeft.

Programmeren

1. Pluk een paar (cid:13)inke teksten van het web en vergelijk de verschillende sorteeralgoritmen,

mergesort, quicksort en insertion sort.

2. Matrixvermenigvuldiging kan gebruikt worden om de transitieve afsluiting van een graaf te
berekenen. Maak een random graaf op 25 knopen en bereken de transitieve afsluiting van
de graaf. Doe dat op twee manieren: de standaardvermenigvuldiging en Strassen’s methode.
Vergelijk de tijden.

2.3 Dynamisch Programmeren

Een belangrijke techniek in de optimalisatie is de techniek van het dynamisch programmeren. Het
is, in tegenstelling tot de top down aanpak van de verdeel-en-heersstrategie(cid:127)en, een bottom up
aanpak die probeert optimale oplossingen voor deelproblemen te vinden. Deze worden vervolgens
samengesteld tot een optimale oplossing voor het hele probleem. Een beetje zoals een legpuzzel

57

wordt opgelost. Telkens wordt een stukje van de legpuzzel opgelost. Als de stukken grotere herken-
bare verbanden gaan vormen worden ze in elkaar gepast. In 1 zagen we al, bij het berekenen van
Fibonaccigetallen dat het opslaan van tussenresultaten soms tot dramatische verbering kan leiden.
Het berekenen van Fibonaccigetallen is echter geen optimalizeringsprobleem. Daarom is dit niet
een typisch voorbeeld voor de aanpak van een probleem met dynamisch programmeren. Een ander
probleem dat we eerder hebben gezien, dat van het geven van wisselgeld kan wel worden aangepakt
met dynamisch programmeren. Dat zullen we hier eerst uitwerken. In Som 2 op pagina 49 hebben
we gezien dat niet in elk systeem de gulzige algoritme voor geldteruggave tot een optimale oplossing
leidt. De hieronder beschreven aanpak met dynamisch programmeren doet dat wel.

Stel we hebben een muntsysteem dat munten van de waarden w1; : : : ; wn heeft, en we moeten een
bedrag B teruggeven. We nemen even aan dat de w1 de eenheid in het muntsysteem is en dat B dus
in ieder geval altijd bereikt kan worden. Nu vinden we een optimale oplossing als volgt. Stel dat we
een optimale oplossing weten die bestaat uit muntwaarden alleen uit w1; : : : ; wi, dan kunnen we een
optimale oplossing met muntwaarden uit w2; : : : ; wi+1 bereken door te observeren dat we de altijd
de keuze hebben wel of geen munten van waarde wi+1 te gebruiken. Als we geen muntwaarde van
type wi+1 gebruiken, dan is de optimale waarde dezelfde als die we hadden berekend bij teruggave
met alleen waarden uit w1; : : : ; wi. Als we wel munten van type wi+1 gebruiken, dan kunnen we
hoogstens W = B=wi+1 van deze munten gebruiken, en een optimale waarde vinden we dus door
voor j (cid:20) W te berekenen wat het optimale aantal munten voor het bedrag B (cid:0) j (cid:2) wi+1 is plus j.

Dus Opt(B; i + 1) = minfOpt(B; i)gSfOpt(B (cid:0) j (cid:2) wi+1; j) + j : j (cid:20) bB=wi+1cg

Waarbij natuurlijk Opt(B; 1) gelijk aan B is voor alle B. We kunnen ons een tabel voorstellen
waarbij we de volgende regel (met muntwaarden wi+1 samenstellen uit door een aantal keren wi in
de vorige regel terug te kijken en dan te zien of we een kleiner getal kunnen krijgen. Misschien is
een getallenvoorbeeld hier illustratief.

Voorbeeld 2.3.1: Neem een muntsysteem met waarden 1,4,5, en 7 en laat 9 het terug te geven
bedrag zijn. We krijgen dan:

0
0
0
0
0

1
1
1
1
1

2
2
2
2
2

3
3
3
3
3

4
4
1
1
1

5
5
2
1
1

6
6
3
2
2

7
7
4
3
1

8
8
2
2
2

9
9
3
2
2

1
4
5
7

Merk overigens op dat de greedy algoritme het bedrag 9 zou vormen uit 7, 1, en 1.

2

Het hier beschreven patroon is een generiek patroon voor algoritmen met dynamisch program-
meren. Het is alleen de dimensie van de tabel en de manier waarop deze wordt ingevuld (rijgewijs,
kolomsgewijs, of langs de diagonalen) die verschilt. We bekijken nog een bekende.

2.3.1 Dynamisch programmeren en Knapsack

Het knapsackprobleem konden we met een gulzige algoritme oplossen gegeven dat de objecten op
elke manier gedeeld kunnen worden. Dat is natuurlijk waar voor ko(cid:14)e en brood, maar is minder
waar voor bijvoorbeeld kristallen kroonluchters. Het knapsackprobleem wordt beduidend moeilijker
als de keuze beperkt wordt tot het wel of niet meenemen van objecten. Deze variant wordt ook wel
de 0-1 variant van knapsack genoemd.

58

We kunnen 0-1 knapsack oplossen met dynamisch programmeren als volgt. Bij elk voorwerp
kunnen we de beslissing nemen het voorwerp wel of niet mee te nemen. Stel dat we weten wat de
optimale oplossing is voor het probleem als we het probleem van het wel of niet meenemen van de
voorwerpen beperken tot de eerste i voorwerpen voor alle getallen tussen 0 en b. Als we bij het
i+1e voorwerp zijn aangekomen, dan kunnen we dit voorwerp niet meenemen (dus blijft de optimale
oplossing voor b geldig voor de eerste i voorwerpen) of het voorwerp wel meenemen, in welk geval
we nog b (cid:0) wi+1 te besteden hebben aan de eerste i voorwerpen. Onze beslissing hangt nu alleen
maar af van de vraag of Opt(f1; : : : ; ig; b) groter of kleiner is dan Opt(f1; : : : ; ig; b (cid:0) wi+1) + wi+1.
Zo kunnen we onze oplossingsverzameling uitbreiden tot we alle voorwerpen hebben opgenomen, en
Opt(f1; : : : ; ng; b) vertelt ons welke oplossing optimaal is voor de verzameling van alle voorwerpen
en b. We kunnen dit in een tabelvorm opschrijven, waarbij we langs de horizontale as de voorwerpen
uitzetten en langs de verticale as de gewichten. Wellicht laat zich dit illustreren aan de hand van
een voorbeeld. Om het probleem wat te vereenvoudigen stellen we de waarde van een object gelijk
aan het gewicht ervan.

Voorbeeld 2.3.2:
2
0
2
2
2
2

w1 = 3
w2 = 2
w3 = 5
w4 = 4
w5 = 6

1
0
0
0
0
0

3
3
3
3
3
3

4
3
3
3
4
4

5
3
5
5
5
5

6
3
5
5
6
6

b = 7

3
5
7
7
7

Als de waarde in een kolom van rij i naar rij i + 1 verandert, betekent dat dat het gunstiger is
2

het nieuw toegelaten object wel mee te nemen.

2.3.2 Tekstwijzigen

Een tekstverwerker zoekt (een groot gedeelte van de tijd) naar een patroon in een tekst. Een tekst
is hierbij een lange rij tekens, en een patroon is een woord of een gedeelte van een zin (korte rij
tekens). De matching hoeft hierbij niet volledig te zijn. Er kunnen, zowel in het patroon als de
tekst letters zijn weggelaten, of veranderd.

Meer precies: we zoeken een patroon P in een text T over hetzelfde alfabet. De edit afstand
tussen P en T is het kleinste aantal veranderingen dat moet worden aangebracht om een deelrij
van tekens van T te veranderen in P . De veranderingen kunnen zijn:

1. Substitutie - twee overeenkomstige letters kunnen verschillen, bijvoorbeeld liggen ! leggen.
2. Invoeging - We kunnen een letter aan T toevoegen die in P voorkomt, bijvoorbeeld gat !

3. Weglating - We kunnen een letter uit T weglaten die niet in P voorkomt, bijvoorbeeld plop

gaat.

! pop.

Er zijn natuurlijk legio andere operaties op P denkbaar die een deelstring van T kunnen
opleveren|denk bijvoorbeeld aan verwisseling van letters|maar deze operaties vormen een ba-
sis voor andere operaties. Dat wil zeggen, andere operaties die van P een deelstring van T maken
zijn kunnen uit deze drie operaties worden samengesteld (in feite zelfs uit de laatste twee).

59

Laten we proberen dit probleem met dynamisch programmeren op te lossen. We hebben dan
(cid:19)e(cid:19)en of andere functie nodig die geoptimaliseerd dient te worden. Natuurlijk is het aantal verschillen
tussen het patroon en enige deelstring van T een duidelijke kandidaat. P moet op enige plaats
langs T gelegd worden, en we vergelijken de letters van P , P1,. . . ,Pn, met een aantal letters van
T |dit aantal kan zowel groter als kleiner zijn dan n. Laten we het minimaal aantal verschillen
tussen P1 : : : Pi en een deelstring van T die eindigt in j bijhouden in een array D[i; j]. Stel dat we
al een gedeelte van P , zeg P1 : : : Pi hebben gepast op een deelstring van T en dat we bij Tj zijn
aangekomen. Hoe breiden we nu het passende patroon uit? Wat is D[i; j]? Er zijn drie gevallen.
1. Als Pi = Tj dan is D[i; j] = D[i (cid:0) 1; j (cid:0) 1], als Pi 6= Tj dan kunnen we substitutie plegen en

D[i; j] = D[i (cid:0) 1; j (cid:0) 1] + 1.

2. D[i (cid:0) 1; j] + 1, dat wil zeggen we voegen een letter in het patroon toe om het patroon op de

3. D[i; j (cid:0) 1] + 1, we laten een letter uit het patroon weg om het patroon op de tekst te laten

tekst te laten lijken.

lijken.

Met deze regels kunnen we een matrix vullen, het getal waarin we ge(cid:127)(cid:16)nteresseerd zijn, dat de
kosten geeft om het patroon helemaal gelijk te maken aan de tekst, staat dan rechts onderin. Als
we alleen ge(cid:127)(cid:16)nteresseerd zijn in gelijkheid van het patroon aan een substring ergens in T , zoals in
een edit programma, dan vinden we de kosten door het minimum van de laatste rij te nemen. We
kunnen niet alleen de kosten vinden, maar door terugredeneren ook de plaatsing en de bijbehorende
operaties terugvinden. Bekijk het volgende voorbeeld.

Voorbeeld 2.3.3: In de tabel hieronder is de dynamisch programmeren algoritme toegepast op de
tekst \...zijn spam-(cid:12)lters handig..." en het patroon \spam-(cid:12)llers"|de werkelijke tekst is uiteraard
veel langer, maar de bijbehorende matrix zou niet prettig zijn voor de layout van de tekst.

h

s

|

d i

a n

e r

a m

z i

7 8

- f

j n

s p

i l t

g
----------------------------------------------------------------------------
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
5 6
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
5 5 6
8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
5 6 5
9 10 11 12 13 14 15 16 17 18 19 20 21
7 8
5 6 6
8 9 10 11 12 13 14 15 16 17 18 19 20
6 7
5 6 7
9 10 11 12 13 14 15 16 17 18 19
7 8
5 6
5 6 7
8 9 10 11 12 13 14 15 16 17 18
6 7
6 5
6 6 7
7 6
5 6
7 8
9 10 11 12 13 14 15 16 17
7 7 7
8 9 10 11 12 13 14 15 16
6 7
6 5
8 7
8 8 8
8 9 10 11 12 13 14 15 16
6 7
7 6
9 9 9
9 8
9 10 11 12 13 14 15
9 10 10 10 10 10 9
8 7
7 6
7 8
9 10 11 12 13 14

| 0
s| 1
p| 2
a| 3
m| 4
-| 5
f| 6
i| 7
l| 8
l| 9
e|10 10
r|11 11 10 10 10 10 10 11 11 11 11 10 9

3 4
3 4
3 4
3 4
4 4
5 5
6 6
7 7
7 8
8 8
9 9 9

1 2
1 2
2 2
3 3
4 4
5 5
6 6
7 6
8 7
9 8

7 8
6 7
5 6
6 5
7 6
8 7
8 8
8 9
9 9

8 8

7 6

7 8

We zien dat in de onderste kolom de minimale waarde 6 optreedt. Als we de diagonaal van dit
getal terugvolgen zien we dat deze (cid:19)e(cid:19)en keer verkregen wordt door substitutie (de t wordt in een l
veranderd), en vijf keer door weglating van respectievelijk z,i,j,n, en een spatie.

2

60

2.3.3 Kortste paden 2: Floyd-Warshall

Bij de gulzige algoritmen in 2.1.3 hebben we al gezien hoe we de het kortste pad kunnen berekenen
tussen een punt a en alle overige punten uit de graaf. Stel nu dat we willen weten, bijvoorbeeld
om een afstandstabel tussen steden te bouwen, wat het kortste pad is tussen alle paren punten van
een graaf. We kunnen dan Dijkstra’s algoritme toepassen op alle punten van de graaf en zo de
afstandstabel opbouwen. Er is echter ook nog een andere methode, die past in dit hoofdstuk omdat
het een toepassing van dynamisch programmeren is. De observatie die een dynamic programming
aanpak mogelijk maakt is dat we elk punt in de graaf afzonderlijk wel of juist niet toe kunnen laten
op een af te leggen pad van a naar b. Als we geen enkel intermediair punt toelaten op het pad
van a naar b dan is het kortste pad simpel de lengte van de kant van a naar b (of 1 als die kant
niet bestaat), en als we het kortste pad weten tussen alle paren knopen in de graaf dat loopt over
punten uit f0; : : : ; ig dan kunnen we het kortste pad in de graaf berekenen dat loopt over punten
uit f0; : : : ; i + 1g, door het korste pad wel of niet door i + 1 te laten lopen. Het minimale pad van a
naar b is dan of het minimale pad van a naar b dat alleen loopt langs knopen uit f0; : : : ; ig of het
minimale pad dat loopt van a naar i + 1 (uiteraard alleen via knopen uit f0; : : : ; ig) geplakt voor
het kortste pad dat loopt van knoop i + 1 naar b. Als i gelijk aan n is geworden, dan hebben we
het minimale pad dat kan lopen langs alle knopen van de graaf, dus het minimale pad.

Voorbeeld 2.3.4: We beschrijven een graaf op 5 punten door een matrix waarin de gewichten van
de kanten staan. De graaf die we hier gebruiken heeft relatief veel kanten zodat een tekening van
de graaf wat onoverzichtelijk wordt. Die tekening is voor de illustratie van de algoritme ook niet
zo belangrijk.

0BBBB@

1CCCCA

1 6
3
8
7 1 2
2
7 1 1 4
7
9

4
9
8
3 1 3
8
8 1 1 1

De algoritme heeft 5 slagen waarin nieuwe knopen in het kortste pad worden toegelaten. Dat
gaat als volgt. Telkens wordt een nieuwe knoop in het pad toegelaten. De corresponderende kolom
en rij worden cursief afgedrukt. Als het pad via de nieuwe knoop korter is dan wat we al hadden
(het cursieve getal in dezelfde rij opgeteld bij het cursieve getal in dezelfde kolom), vervangen we
de waarde van het kortste pad door de nieuwe waarde. Aangezien de lengte van het pad naar de
nieuwe knoop niet kan veranderen door toevoeging van de nieuwe knoop blijven de cursieve rij en
de cursieve kolom dezelfde getallen houden. De knopen waarvoor de afstand een nieuwe waarde
krijgt, drukken we vet af.

61

0BBBB@
0BBBB@

1 6
3
13
7
2
13 10
7
3
8
7
9
8
12

8
2
4
15
1

4
9
8
3
13

10
7
7
7
8

7
6
3
10 2
2
12 7 4
8
7
3
4 1
8

4
5
7
3
4

1CCCCA
1CCCCA

13
7
7
7
9

0BBBB@
0BBBB@

6
13
13
8
8

3
2
10
3
10

8
2
4
10
1

10
7
7
7
8

6
10
12
8
8

2
4

3 5 4
5
2
7
7
3 4 3
4
4

1

0BBBB@

4
9
8
3
13

1CCCCA
1CCCCA

1CCCCA

10
7
7
7
9

6
13
13
8
8

3
2
10
3
10

7
2
4
7
1

4
9
8
3
13

2

We voeren in deze algoritme dus n slagen uit waarin we de informatie in de matrix over mini-
male verbindingen updaten. Elke update kost O(n2) stappen. Per element doen we slechts twee
vergelijkingen. De algoritme kost in totaal dus O(n3).

2.3.4 Matrixvermenigvuldiging

Voor het vermenigvuldigen van twee matrices hebben we een e(cid:14)ciente algoritme gezien in 2.2.1.
We beschouwen hier het probleem van het vermenigvuldigen van een rij matrices, die niet allemaal
vierkant zijn. Twee matrices A en B kunnen met elkaar vermenigvuldigd worden als het aantal
kolommen van A overeenkomt met het aantal rijen van B. Immers op plaats i; j in de productmatrix
komt het inproduct van de i de rij van A en de j-de kolom van B te staan. De i-de rij van A moet
voor die berekening dus net zoveel elementen hebben als de j-de kolom van B, en het aantal
elementen van de i-de rij van A is gelijk aan het aantal kolommen van A. Evenzo is het aantal
elementen in de j-de kolom van B gelijk aan het aantal rijen van B. Laat A een n(cid:2)m matrix zijn en
B een m(cid:2) p matrix zijn. Het resultaat is dan een matrix C met n rijen en p kolommen. Het aantal
vermenigvuldigingen dat hiervoor nodig is, is met de standaard matrixvermenigvuldigingsalgoritme
n (cid:2) m (cid:2) p.
Stel nu eens dat we een drietal matrices moeten vermenigvuldigen A(cid:2)B(cid:2)C, waarbij A een 30(cid:2)40
matrix is, B een 40(cid:2)50 en C een 50(cid:2)60 matrix. We kunnen dit, aangezien matrixvermenigvuldiging
associatief is op twee manieren doen (AB)C of A(BC). In het eerste geval voeren we eerst 30(cid:2)40(cid:2)50
vermenigvuldigingen uit om een 30 (cid:2) 50 matrix te krijgen. Vervolgens vermenigvuldigen we deze
30 (cid:2) 50 matrix met C ten koste van 30 (cid:2) 50 (cid:2) 60 vermenigvuldigingen.
In het tweede geval
vermenigvuldigen we eerst B en C ten koste van 40(cid:2)50(cid:2)60 vermenigvuldigingen en de resulterende
40 (cid:2) 60 matrix vermenigvuldigen we met A ten koste van 30 (cid:2) 40 (cid:2) 60 vermenigvuldigingen. Beide
operaties leiden tot een 30 (cid:2) 60 productmatrix, de ene keer ten koste van 60000 + 90000 = 150000
vermenigvuldigingen en de andere keer ten koste van 120000 + 72000 = 184000 vermenigvuldiginen.
De volgorde van vermenigvuldigen is hier van belang.
Stel dat we een rij matrices A1; : : : ; An hebben die we met elkaar willen vermenigvuldigen,
waarbij gegeven is dat als Ai een di (cid:2) di+1 matrix is, dat dan Ai+1 een di+1 (cid:2) di+2 matrix is,
m.a.w. vermenigvuldiging is mogelijk. Hoe zullen wij de volgorde van vermenigvuldigen (i.e. het
plaatsen van de haakjes) bepalen? Doorwerken van enige voorbeelden (zie Som 2.3.5) laat zien

62

dat gulzige methoden niet werken. De oplossing voor dit probleem bereiken we met de dynamisch
programmeren aanpak. Immers, stel dat we optimaal uit de matrices di tot en met dk een pro-
ductmatrix met di rijen en dk+1 kolommen willen maken. Het buitenste paar haakjes (i.e., ")(")
moet ergens tussen i en k gezet worden, zeg op plaats j. Uitvermenigvuldigen laat twee matri-
ces van dimensies di; dj, respectievelijk dj; dk+1. Het aantal vermenigvuldigingen is nu gelijk aan
di (cid:2) dj (cid:2) dk+1 plus het aantal vermenigvuldigingen dat nodig is om optimaal de rij matrices van
i tot j te vermenigvuldigen plus het aantal vermenigvuldigingen dat nodig is om optimaal de rij
matrices van j tot k te vermenigvuldigen. Door deze getallen uit te rekenen voor j lopend van i naar
k kunnen we achter het optimale getal komen, waarbij het optimale aantal vermenigvuldigingen
om twee opeenvolgende matrices te vermenigvuldigen vast ligt. Dit nodigt uit tot een recursieve
algoritme, ware het niet dat de recursieve boom die aldus onstaat alle mogelijke plaatsing van haak-
jesparen in een knoop representeert. Het aantal mogelijkheden dat dit oplevert is een bekend getal,
het zogenaamde Catalaanse getal en is ongeveer 4n=n3=2. Dit levert dus geen e(cid:14)ciente algoritme
op. Als we echter voor alle paren j tussen i en k het optimale getal kennen, dan kunnen we met
bovenbeschreven methode in ongeveer k (cid:0) i stappen uitrekenen wat het minimum is voor i tot k.
Deze methode nodigt dus ook uit tot de dynamisch programmeren aanpak, en een handige manier
om deze te implementeren levert een O(n2) algoritme als volgt.
Neem een vierkante matrix P van n(cid:2) n getallen. Omdat we weten hoeveel vermenigvuldigingen
optimaal zijn om de matrices op plaats i en i + 1 met elkaar te vermenigvuldigen (di(cid:0)1 (cid:2) di (cid:2) di+1)
kunnen we al deze getallen op plaats i; i + 1 in de matrix invullen (formeel kan ook de diagnonaal
gevuld worden met 0). Nu vullen we de rest van de matrix met de formule

P [i; j] = minfP [i; k] + P [k + 1; j] + di(cid:0)1 (cid:2) dk (cid:2) dj : i < k < jg:

Omdat we de waarden P [i; i + 1] in deze matrix weten, kunnen we hem in O(n2) stappen (waarbij
elke stap niet meer dan het vinden van het minimum in een rij van lengte n kost) verder invullen.
De complexiteit van de algoritme is dus O(n3).

Voorbeeld 2.3.5: Laat gegeven een zijn een rijtje matrices met de volgende dimensies

18 (cid:2) 31; 31 (cid:2) 40; 40 (cid:2) 29; 29 (cid:2) 9; 9 (cid:2) 11; 11 (cid:2) 8; 8 (cid:2) 20; 20 (cid:2) 44; 44 (cid:2) 31

Uit de bovenbeschreven algoritme komt de volgende matrix.

0

22320

0

43200
26622 28404
35960 21600 24669
14400
2871

10440

0

0

0

0BBBBBBBBBBBB@

26544
22080
12160
2880
792
0

29424
27040
18560
7452
2232
1760

0

39920
40032
33280
20128
10152
10912
7040

0

48960
47720
40032
28024
20976
20680
17952
27280

0

1CCCCCCCCCCCCA

Waaruit we kunnen zien dat de meest gunstige manier om deze matrices te vermenigvuldi-
gen 48960 vermenigvuldigingen kost. Om de volgorde te bepalen waarmee dat lukt is het nodig
tussenresultaten op te slaan. In ons geval is de optimale volgorde:

(1 (cid:2) (2 (cid:2) (3 (cid:2) 4 (cid:2) (5 (cid:2) 6)))) (cid:2) ((7 (cid:2) 8) (cid:2) 9)

63

Naast de aantallen vermenigvuldigingen, moeten we daarvoor ook bijhouden welke matrices met
elkaar vermenigvuldigd worden. In de volgende matrix staan op plaats (i; j) telkens het hoogste
niveau haakjes. Een (cid:2) betekent dat twee naast elkaar gelegen matrices rechtstreeks vermenigvuldigd
moet worden en i * j betekent dat op plaats i; j gekeken moet worden hoe deze rij optimaal
vermenigvuldigd kan worden.

0BBBBBBBBBB@

1 (cid:2) 2 (1 (cid:2) 2)3

2 (cid:2) 3

1(2 * 4)
2(3 (cid:2) 4)
3 (cid:2) 4

(1 * 4)5
(2 * 4)5
(3 (cid:2) 4)5
4 (cid:2) 5

1(2 * 6)
2(3 * 6)
3(4 * 6)
4(5 (cid:2) 6)
5 (cid:2) 6

(1 * 6)7
(2 * 6)7
(3 * 6)7
4(5 * 7)
(5 (cid:2) 6)7
6 (cid:2) 7

(1 * 6) (cid:2) (7 (cid:2) 8)
(2 * 6) (cid:2) (7 (cid:2) 8)
(3 * 6) (cid:2) (7 (cid:2) 8)
(4 * 6) (cid:2) (7 (cid:2) 8)
(5 * 7)8
6(7 (cid:2) 8)
7 (cid:2) 8

1CCCCCCCCCCA

(1 * 6) (cid:2) (7 * 9)
(2 * 6) (cid:2) (7 * 9)
(3 * 6) (cid:2) (7 * 9)
(4 * 6) (cid:2) (7 * 9)
(5 (cid:2) 6) (cid:2) (7 * 9)
6(7 * 9)
(7 (cid:2) 8)9
8 (cid:2) 9

2

2.3.5 Sommen

1. Laat zien met behulp van voorbeelden dat gulzige algoritmen voor matrix-ketting-vermenigvuldiging

gebaseerd op
(a) Neem de kleinste producten (minimaliseer di(cid:0)1 (cid:2) di (cid:2) di+1 eerst).
(b) Neem de grootste producten (maximaliseer di(cid:0)1 (cid:2) di (cid:2) di+1 eerst).

niet werken. Kun je nog andere gulzige heuristieken bedenken?

2. Vind dynamisch programmeren oplossing voor de volgende problemen. Het volstaat de recur-

rentie te vinden.

(a) Een gokker begint met 3 euro en wil in drie keer gokken vijf euro hebben. Bij elke gok
is de kans op winst 2/3 en bij winst wordt twee keer de inzet uitbetaald (bij verlies is de
inzet verloren). Bepaal met een een dynamisch programma de strategie (hoeveel moet
zij inzetten) om de kans te maximaliseren.

(b) Langste stijgende subrij. Gegeven een rij getallen, vind de langste deelrij waarvan de ele-
menten monotoon stijgend zijn (ze hoeven niet naast elkaar te staan). Dus bijvoorbeeld
van S = (9; 5; 2; 8; 7; 3; 1; 6; 4) heeft de langste stijgende deelrij lengte drie en is (2; 3; 4)
of (2; 3; 6).

(c) Maximale som. Vind in een rij getallen de deelrij van naast elkaar liggende getallen met
maximale som (bijvoorbeeld in f31;(cid:0)41; 59; 26;(cid:0)53; 58; 97;(cid:0)123; 93; 84g is dat de rij van
59 t.e.m. 97).

(d) Kleuren. n auto’s hebben c kleuren en kunnen k plaatsen versleept worden. Zoek de
rij met het minimaal aantal kleurwisselingen. Bijvoorbeeld: 011200121 kan met k = 2
worden veranderd in 110002211.

64

(e) Play O(cid:11)s. Team A en team B spelen een serie van niet meer dan 2n(cid:0)1 wedstrijden tegen
elkaar. Een team heeft de serie gewonnen zodra het n of meer wedstrijden gewonnen
heeft. Er bestaat geen gelijkspel en de wedstrijden zijn onafhankelijk van elkaar. Voor
elke wedstrijd is er een constante waarschijnlijkheid p dat team A wint (en dus een
constante waarschijnlijkheid 1 (cid:0) p dat team B wint). Bereken de kans dat team A wint.
(f) Shu(cid:15)e. Stel je krijgt drie rijtjes letters:X = x1; x2; : : : ; xm, Y = y1y2; : : : ; yn en Z =
z1; z2; : : : ; zm+n. Z is een shu(cid:15)e van X en Y als Z gemaakt kan worden door om
beurten een stukje van X en een stukje van Y te nemen, waarbij de letters in volgorde
blijven staan. Bijvoorbeeld, cchocohilaptes is een shu(cid:15)e van chocolate em en chips, maar
cchocolhilaptes is dat niet. Gegeven X; Y; Z; m en n. Is Z wel of niet een shu(cid:15)e van X
en Y ?

Programmeren

1. Maak een ongerichte volledige graaf op 25 knopen en geef de kanten random waarden tussen de
1 en de 100. Bereken tussen elk tweetal punten de lengte van het kortste pad. Doe vervolgens
hetzelfde met de algoritme van Floyd-Warshall en vergelijk de uitkomsten.

65

66

Hoofdstuk 3

Grafenalgoritmen

Een belangrijk onderdeel van de algoritmiek wordt gevormd door de speci(cid:12)eke toepassing van al-
goritmen in de grafentheorie. Een aantal typische graafalgoritmen hebben we al besproken in
Hoofdstuk 2 omdat ze de in die sectie besproken techniek uitstekend toelichten. Een aantal ty-
pische grafenproblemen zullen nog uitgebreid aan bod komen in 6.5 vanwege het feit dat er geen
e(cid:14)ciente algoritme voor het algemene probleem bekend is. Voor een aantal eenvoudig te beschrijven
en veelvoorkomende grafenproblemen weten we geen andere oplossing te bedenken dan alle moge-
lijke oplossingen te genereren en daaruit een passende te kiezen. Omdat het totaal aantal mogelijke
oplossingen vaak exponentieel is, zeggen we dat zo’n grafenprobleem ondoenlijk is en zoeken we
naar inperkingen van de soort grafen waarop het aantal mogelijke oplossingen beperkt is, of waarop
de algoritme verder kan worden gespecialiseerd, zodat niet alle oplossingen bekeken hoeven wor-
den. Te denken valt hierbij aan grafen met beperkte graad, beperkte diepte (padlengte), beperkte
boombreedte of andere speciale eigenschappen zoals planariteit. Het onderzoek naar grafenalgorit-
men beweegt zich voor een belangrijk deel op dit gebied. In dit hoofdstuk zullen we nog een paar
algemene methoden bespreken voor het doorzoeken en klassi(cid:12)ceren van grafen. We beginnen met
doorzoeken.

3.1 Zoeken in Grafen

Een graaf bestaat uit knopen en kanten en de structuur van een graaf kunnen we onderzoeken door
van de ene knoop naar de andere knoop te lopen met behulp van een algoritme. Aangezien een
knoop doorgaans door meerdere kanten aan meerdere andere knopen verbonden is, moeten we in
elke knoop een keuze maken welke knoop de volgende in de rij is (of meer precies welke knoop na de
volgende knoop in de rij zal volgen). Er zijn twee hoofdkeuzen die de soort zoekalgoritme bepalen,
de overige methoden zijn variaties daarop.

3.1.1 Depth First Search

In de diepte eerst methode, wordt het volgende te bezoeken punt gekozen door eerst zo diep mogelijk
in de graaf te gaan en pas daarna nog onbezochte knopen die buren zijn van eerder bezochte knopen
te onderzoeken. We nemen aan dat de knopen van de graaf genummerd zijn, zodat we in een knoop

67

als volgende knoop de knoop met het laagste nummer kunnen kiezen. Ook nemen we aan dat we
een merkteken \bezocht" op een knoop kunnen aanbrengen.

1: Procedure DFS(v: knoop)
2: Markeer v bezocht.
3: while 9w buurknoop van v die nog niet bezocht is do

Neem zo’n w met minimale index;
4:
DFS(w);
5:
6: end while

De procedure voor diep zoeken eerst, Depth First Search (DFS), is e(cid:14)ci(cid:127)ent en bijzonder eenvou-
dig op te schrijven. Als we aannemen dat het a(cid:13)open van een kant in constante tijd kan, dan neemt
DFS niet meer tijd dan er knopen zijn, en is dus O(n). Zoiets zou bijvoorbeeld kunnen wanneer
de graaf gegeven is als een adjacency matrix en we dus directe toegang tot de kanten hebben. An-
dere implementaties vereisen misschien eerst sorteren van de knopen (O(n log n)), of van de kanten
(O(m log m) (cid:18) O(n2 log n)). Hoe ook, de procedure blijft buitengewoon e(cid:14)cient. Met behulp van
deze zoekmethoden kunnen we diverse eigenschappen van een graaf identi(cid:12)ceren.

De procedure DFS selecteert een aantal kanten in de graaf en stelt de graaf voor als een boom.
Doorgaans heeft de graaf natuurlijk nog veel meer kanten. De kanten die door DFS gebruikt
worden om de graaf te doorlopen zullen we boomkanten (tree-edges) noemen. De kanten in de
graaf die van een knoop v terugwijzen naar een knoop w die een voorouder is van v in de DFS
boom zullen we terugkanten (back-edges) noemen en de kanten die niet in deze categorie vallen
(dus verschillende paden van de boom met elkaar verbinden) zullen we kruiskanten noemen. In het
voorbeeldje hieronder zullen we de boomkanten van de graaf aangeven met pijlen, de terugkanten
met gestreepte pijlen en de kruiskanten met ).

Voorbeeld 3.1.1: Bekijk de graaf G op 9 knopen met 16 kanten. Deze graaf wordt door DFS in
de (cid:12)guur DFS(G) als boom beschreven.

(cid:15)1

(cid:15)4

(cid:15)7 o

G
(cid:15)2

(cid:15)5

(cid:15)8

(cid:15)3O

(cid:15)6

(cid:15)9

(cid:15)1

(cid:15)4

(cid:15)2

w(cid:15)5

DFS(G)

(cid:15)3

(cid:15)6

(cid:15)9

2

Cykels

Met DFS kan worden bepaald of in een graaf cykels zitten. Immers, als er een cykel in een graaf zit,
dan komen we met DFS langs een pad aan op een knoop die reeds gemarkeerd is, en anders komen
we alleen terug uit de recursie bij reeds gemarkeerde knopen. Een enkele DFS run kan beslissen of

(cid:15)8

(cid:15)7

68

/
/
(cid:15)
(cid:15)
/
/
(cid:15)
(cid:15)
O
/
/
O
O
~
~
/
/
O
O
>
>
(cid:15)
(cid:15)
o
>
>
/
/
~
~
w
w
(cid:11)
(cid:19)
w
w
(cid:11)
(cid:19)
’
’
w
w
w
c
k
w
w
(cid:11)
(cid:19)
K
S
w
w
’
’
B
B
*
*
*
*
er een cykel is die door een gegeven knoop voert. Om te beslissen of er een cykel in de graaf is,
kunnen we DFS achtereenvolgens uit alle knopen uit de graaf starten.

Topological Sort

Een acyclische graaf kan de voorstelling zijn van een parti(cid:127)ele ordening 1 . Soms kan het nodig
zijn van een parti(cid:127)ele ordening een totale ordening te maken. Te denken bijvoorbeeld valt aan
machinevolgordeproblemen waarbij afhankelijkheden bestaan tussen taken uit te voeren door een
machine. Deze afhankelijkheden de(cid:12)ni(cid:127)eren een parti(cid:127)ele ordening die platgeslagen dient te worden
tot een lineaire ordening om op een machine te kunnen worden uitgevoerd. Ook zien we het
topological sort probleem vaak optreden bij het gebruik van databases, waarbij transacties die
gebruik maken van dezelfde resources op elkaar moeten wachten. Het probleem is dan het vinden
van een volgorde waarin de transacties kunnen worden uitgevoerd, of waarin de transacties zouden
kunnen zijn uitgevoerd als ze door een machine zouden zijn behandeld (serializability).

We zouden kunnen proberen voor dit probleem DFS in te zetten, maar DFS respecteert niet

noodzakelijk alle afhankelijkheden in de graaf. Een graafje als bijvoorbeeld

(cid:15)1

(cid:15)2 o

(cid:15)3

wordt door DFS in de volgorde 1, 2, 3 doorlopen, maar de afhankelijkheid 2   3 maakt dat deze
volgorde niet legitiem is voor topological sort.

We hebben dus een andere algoritme nodig voor het vinden van deze ordening. De observatie
die we maken is dat er in een acyclische graaf altijd minstens (cid:19)e(cid:19)en knoop moet zijn met ingraad
0. Begin in een willekeurige knoop, kies een willekeurige inkomende kant en ga naar de knoop die
aan de andere kant zit. Aangezien de graaf acyclisch is, moet deze actie altijd een nieuwe knoop
opleveren, en dat kan niet meer dan n keer. De knoop met ingraad 0 hoeft niet later in de ordening
te komen dan enige andere knoop in de graaf en kan dus de eerste in de ordening zijn. Deze knoop
geven we dus nummer 1 in de volgorde, we verwijderen de knoop en voeren de actie opnieuw voor
de resterende knopen (die ook een acyclische graaf vormen) uit.
1: Procedure TopSort(G,n)
2: if G 6= ; then

Find v with indegree 0;
Give v number n;
TopSort(G (cid:0) fvg; n + 1)

3:
4:
5:
6: end if

Verbonden Componenten

Een verbonden component in een graaf is een deel van de graaf met de eigenschap dat tussen elk
tweetal punten tenminste (cid:19)e(cid:19)en pad loopt. Zowel gerichte als ongerichte grafen hebben verbonden

1Een ordening op een verzameling kan parti(cid:127)eel of totaal zijn. Als een ordening, <, totaal is, dan moet voor elk
paar elementen a en b gelden a < b of b < a. Bij een parti(cid:127)ele ordening hoeft dat niet. Een acyclische graaf kan een
parti(cid:127)ele ordening voorstellen omdat niet tussen elk tweetal knopen een pad hoeft te zijn. Als er een cykel in de graaf
zit, dan kan zowel a < b als b < a gelden. De ordening is dan niet meer antisymmetrisch.

69

 
 
(cid:15)
(cid:15)
o
componenten, maar in ongerichte grafen loopt tussen elk tweetal punten natuurlijk zowel een pad
heen als een pad terug. Dat is in gerichte grafen niet altijd het geval. Als in een deel van een
gerichte graaf tussen elk tweetal punten zowel een pad heen als een pad terug loopt, noemen we
zo’n deel dubbelverbonden of sterkverbonden (bi-connected of strongly connected). Depth First
Search is natuurlijk een uitgelezen algoritme om verbonden componenten te vinden. Immers, als
we een Depth First Search in een punt starten, dan vinden we alle punten in de graaf die door een
pad met dat punt verbonden zijn, ofwel we vinden alle punten in de graaf die in dezelfde verbonden
component zitten als dit punt. DFS kan echter ook gebruikt worden om de dubbelverbonden
componenten van een gerichte graaf te ontdekken.

Articulation Points

Een articulation point in een graaf is een punt dat de graaf in twee delen verdeelt, zo dat elk
pad van het ene deel van de graaf naar het andere deel van de graaf door dit punt moet gaan.
Articulation points in netwerken zijn vaak de kwetsbare punten. Neem je de articulation points
uit een verbonden graaf weg, dan valt de graaf uiteen in een aantal verbonden componenten. In
dataverkeer tussen computers willen we niet graag articulation points hebben omdat uitval van dit
punt het einde van de communicatie betekent. Als articulation points om welke reden dan ook
onvermijdelijk zijn, dan willen we er graag zo weinig mogelijk hebben.

In 3.1.1 hebben we al gezien hoe we met behulp van DFS verbonden componenten konden
identi(cid:12)ceren. Net zo makkelijk kunnen we natuurlijk articulation points met behulp van DFS
identi(cid:12)ceren. Bijvoorbeeld: neem zo’n punt uit de graaf. Twee buren van dit punt komen dan in
verschillende verbonden componenten te zitten. Aan de volledige DFS boom van een verbonden
component kunnen we echter de articulation points nog gemakkelijker herkennen. Bekijk een DFS
boom en neem een punt dat niet de wortel van de boom is. Als dit punt een articulation point
is, dan moet de graaf na het wegnemen van dit punt uit tenminste twee componenten bestaan die
niet met elkaar verbonden zijn. Alle punten in de graaf die niet in de subboom van dit punt zitten,
kunnen vanuit de wortel bereikt worden. De graaf kan na weglating van dit punt dus alleen maar
uit twee niet met elkaar verbonden componenten bestaan, als de subboom van dit punt geen andere
verbinding (terugkanten of kruiskanten) heeft met de rest van de graaf. Dit kunnen we met een
recursieve procedure nagaan.

3.1.2 Breadth First Search

De alternatieve manier om recursief een graaf te doorzoeken is de \breedte eerst" methode.
In
plaats van eerst zo diep mogelijk in de graaf te gaan, bezoeken we eerst de hele buurt van de knoop
waar we zijn, om daarna alle knopen die van deze buren weer buren zijn te bezoeken. Depth First
Search kan worden gekarakterizeerd door een stapel (de eerste buur van een knoop wordt ook het
eerstvolgend bezocht, waarna diens buren op de stapel gezet worden enzovoort) en kan dus met een
recursieve procedure beschreven worden. Breedte eerst heeft veel meer het karakter van een rij. Zo
zullen we ook deze methode in pseudocode beschrijven.
1: Procedure BFS(Q);
2: if Q 6= ; then

3:

4:
5:

remove (cid:12)rst element v from Q;
mark v visited;
enqueue all neighbors of v in Q;

70

BFS(Q);

6:
7: end if

3.2 Kortste paden 3: De A(cid:3) algoritme

In de AI, met name de robotica, is een algoritme voor het zoeken van paden in grafen, waarbij ob-
stakels vermeden dienen te worden zeer populair. Deze algoritme staat tegenwoordig alom bekend
als de A(cid:3) algoritme. Het is een variant op Dijkstra’s algoritme die in de praktijk vaak aanzienlijk
sneller is, maar in theorie zelfs niet hoeft te convergeren. Daarom is deze algoritme in het algorit-
menonderzoek veel minder bekend dan in de AI. De algoritme heeft een beetje een merkwaardige
naam. In het oorspronkelijke artikel [HNR68] werd deze algoritme aangeduid met \Algoritme A".
De algoritme is gebaseerd op een techniek die in de AI \heuristiek"wordt genoemd (zie ook 6.7.3)
en als een optimale heuristiek in de AI is gevonden wordt dat aangeduid met een (cid:3), vandaar de A(cid:3)
algoritme.

In tegenstelling tot de algoritme van Dijkstra is de A(cid:3) algoritme er niet per se op gericht het
kortste pad van A naar B te vinden. Vaak is men al dik tevreden als er een pad gevonden is. Als de
gebruikte heuristiek bekend is, dan is het vaak ook mogelijk de gebruikte variant van de algoritme
te verleiden een pad langs alle mogelijke locaties te produceren.

In overeenstemming met de algoritme van Dijkstra houdt de A(cid:3) algoritme een verzameling
punten bij waarvan het de afstand tot het startpunt A \kent", dwz een pad van A naar dit punt
gevonden heeft. De afstand van A naar een punt P wordt aangeduid met g(P ). Verder gebruikt
de A(cid:3) algoritme een heuristiek h die gegeven een punt P in de graaf een schatting geeft (vaak een
onderschatting) van de afstand van dat punt naar het doelpunt B, h(P ). De \verwachte" afstand
van A tot B is dan de afstand van A naar P plus de afstand van P naar B, fP (B) = g(P ) + h(P ).
De algoritme maakt dan steeds een update door voor de knoop mpet minimale fP (B), de buren
aan de bekende verzameling toe te voegen, net zo lang tot B aan de verzameling is toegevoegd.

Voorbeeld 3.2.1: We berekenen de afstand van Amsterdam naar Eindhoven over verschillende
tussenstations. Als heuristiek gebruiken we de afstand in centimeters tussen een gegeven stad
en Eindhoven, vermenigvuldigd met de schaal van de kaart. De tussenstations die we meenemen
zijn: Delft, Utrecht, Ede, Breda, ’s-Hertogenbosch, Nijmegen, Tilburg, en Helmond. De werkelijke
afstanden tussen deze steden over de weg zijn gegeven in de volgende graaf (afgerond overgenomen
van een internet routeplanner). De afstanden die we (hemelsbreed) van de kaart kunnen a(cid:13)ezen
van de buren van Amsterdam naar eindhoven, vermelden we in een tabel ernaast. Deze worden
gebruikt als schatting voor de resterende afstand.

71

stad
Delft
Utrecht
Ede
Breda
’s-Hertogenbosch
Nijmegen
Tilburg
Helmond

afstand
100
75
60
54
34
43
30
13

D

B

T

64

6746

101

74

49

79

45

46

62

75

41

E

N

A

U

S

H

30

27

67

65

67

35

15

Eh

164

120

(cid:3)

U

S

H

D

B

T

E

E

E

200

141

151

139

U

200

S

N

188

163

T

220

H

Eh

164

187

242

198

187

Op dit punt is een weg naar Eindhoven gevonden over Ede en Nijmegen met een lengte van
187km. De algoritme kan nu stoppen, of proberen een kortere weg te vinden, want zowel de weg
over Delft, als de weg over Utrecht, ’s-Hertogenbosch en Tilburg zouden nog korter kunnen zijn.

2

72

|
|
(cid:15)
(cid:15)
(
(
|
|
(cid:15)
(cid:15)
"
"
(cid:15)
(cid:15)
"
"
(
(
|
|
(cid:15)
(cid:15)
"
"
(cid:15)
(cid:15)
"
"
(
(
3.3 Netwerken en Stromen

Met grafen kunnen we van alles modelleren. Vaak worden grafen gebruikt om relaties tussen
individuele objecten te modelleren. We zien dan vaak ongerichte grafen. Vaak ook worden geordende
transitieve relaties gemodelleerd. Paden in de graaf worden dan belangrijker dan individuele kanten.
We beperken de klasse van grafen onder beschouwing dan vaak tot gerichte grafen (en zouden
eigenlijk
bogen" moeten zeggen in plaats van kanten, maar waar dit niet tot verwarring leidt
"
kant" gebruiken). De paden in een
blijven we toch ook graag in het gerichte geval het woord
"
gerichte graaf modelleren vaak een soort infrastructuur. Zulke grafen zijn het onderwerp van deze
sectie.

Een voorbeeld van het gebruik van de paden in grafen is het probleem van de netwerkstromen.
We hebben gegeven een netwerk dat bestaat uit een graaf en twee functies, de capaciteitsfunctie c
en de stroomfunctie f . We zullen van de graaf aannemen dat hij gericht is. Dat is geen beperking
van de algemeenheid, want een weg die in twee richtingen kan worden genomen, kan altijd worden
voorgesteld door een tweetal kanten. Beide functies f en c zijn functies van de kanten naar de re(cid:127)ele
getallen die aan voorwaarden verbonden zijn.

1. f en c zijn allebei groter dan of gelijk aan 0 voor elke kant.

2. Voor elke v geldt P

e!v f (e) =P

e v f (e). Behalve voor twee speci(cid:12)eke knopen s en t die
we de bron en het doel zullen noemen. Dat wil zeggen voor alle knopen behalve de bron en
het doel is de totale inkomende stroom gelijk aan de totale uitgaande stroom.

3. Voor elke kant e geldt f (e) (cid:20) c(e).

De capaciteitsfunctie is constant voor het probleem en we de(cid:12)nieren verschillende stroomfunc-
ties. Het probleem is het vinden van de stroomfunctie die onder de hierbovenbeschreven voorwaar-
den de maximale inkomende stroom in de knoop t geeft. Deze stroom is vanwege voorwaarde 2
gelijk aan de totale uitgaande stroom uit s, en dit getal zullen we (als die bestaat natuurlijk) \de"
maximale stroom in het netwerk noemen. We zullen een algoritme behandelen die de maximale
stroom vindt. Eerst zullen we bewijzen dat zo’n maximale stroom bestaat.

3.3.1 Min Cut Max Flow

Eerst de(cid:12)nieren we een doorsnijding van het netwerk als een graaf waaruit zoveel kanten zijn verwij-
derd dat precies twee verbonden componenten ontstaan. De ene component bevat s, en de andere
component bevat t. Ofwel als G = (V; E), dan is de doorsnijding van de graaf de de(cid:12)nitie van
twee verzamelingen V1; V2 zodat V1 [ V2 = V , V1 \ V2 = ;, s 2 V1, en t 2 V2. De capaciteit van
een doorsnijding is de som van de capaciteiten van de kanten die van de component van s naar de

component van t lopen, ofwelPfc(e) : e = (v; w) ^ v 2 V1; w 2 V2g.

Stelling 3.3.1 (min-cut-max-(cid:13)ow) De maximale stroom in een netwerk is gelijk aan het mini-
mum genomen over de capaciteiten van alle doorsnijdingen.
f (cid:20) min-cut. Allereerst is het duidelijk dat voor elke doorsnijding geldt dat de stroom in het
netwerk kleiner moet zijn dan de capaciteit van die doorsnijding. Aangezien er een eindig aantal
doorsnijdingen is, moet dus zeker gelden dat de maximale stroom kleiner dan of gelijk is aan de
minimale capaciteit van een doorsnijding.

73

f (cid:21) min-cut. Om in te zien dat in elk netwerk ook een stroom kan lopen waarvan de waarde (=
de totale stroom uit s = de totale stroom in t) gelijk is aan de capaciteit van een doorsnijding, en
bewijs" is wat lang
vanwege de vorige alinea de minimale, geven we een constructief bewijs. Dit
"
en eindigt pas op pagina 75, maar omdat het constructief is, is het nergens echt ingewikkeld.

We de(cid:12)ni(cid:127)eren een algoritme die die maximale stroom berekent, en bewijzen dat de algoritme
pas stopt als die, dan maximale, stroom bereikt is. Deze algoritme is vernoemd naar Ford en
Fulkerson [FF56], die deze algorime voor het eerst presenteerden.

De algoritme begint met een stroom 0 door het netwerk en zoekt dan zogenoemde stroomvergro-
tende paden. Dat zijn paden van s naar t waardoorheen nog extra stroom \geduwd" kan worden.
In deze paden worden kanten in de richting van s naar t opgenomen, maar ook kanten in de tegen-
overgestelde richting. De kanten in de richting van s naar t kunnen in zo’n pad worden opgenomen
als de stroom in de graaf door die kant zijn maximum (capaciteit) nog niet heeft bereikt. Extra
stroom door die kant voeren zou dan de stroom langs het pad vergroten, en stroom langs een kant
in de tegenovergestelde richting kan vergroot worden, als de stroom niet gelijk aan nul is. Door
die stroom te verkleinen, vergroten we de stroom langs het pad. Hebben we zo’n stroomvergrotend
pad gevonden, dan hebben we voor elke kant apart uitgerekend hoeveel extra stroom er nog bij zou
kunnen langs het pad, en dan kunnen we door het minimum te nemen de stroom langs het pad
door alle kanten berekenen. Het vinden van een stroomvergrotend pad gaat vanuit s met DFS naar
t. Als t niet bereikt wordt, dan is de stroom in het netwerk maximaal. We zullen een verzameling
van gemarkeerde knopen bijhouden M , met in het begin alleen s 2 M We zullen voor kanten in de
richting van het pad het verschil tussen de stroom en de capaciteit, en voor kanten tegen de richting
van het pad in de stroom zelf de restcapaciteit van zo’n kant noemen.

1: procedure FFK(node v, real minval)
2: Add v to M ;
3: if v = t then
4:
5:
6: end if
7: for (8w 2 V (cid:0) M )[[(v; w) 2 E ^ f ((v; w)) < c((v; w))] _ [(w; v) 2 E ^ f ((w; v)) > 0]] do

print(t,minval);
return(true);

Let p be the residual capacity of this edge.
Let q be minfp; minvalg;
if FFK(w; q) then

8:
9:
10:
11:

print(w);
return(true);

end if

12:
13:
14: end for
15: return(false);

Deze procedure zoekt met DFS een pad van s naar t. Als een pad in t eindigt, dan wordt t
samen met de minimale vergrotingswaarde langs het gevonden pad afgedrukt, bovendien worden
omdat de recursieve aanroepen achtereenvolgens allemaal true terug geven het pad waarlangs de
stroom kan worden vergroot in omgekeerde volgorde afgedrukt. Eindigt een pad in een knoop omdat
geen vervolgknoop wordt gevonden, dan zal deze knoop geen recursieve aanroep hebben die true
teruggeeft en dus niet worden afgedrukt.

Elke keer dat een stroomvergrotend pad gevonden wordt, wordt de stroom met de minimale
restcapaciteit langs dat pad vergroot. Bovendien weten we dat de stroom niet de capaciteit van
enige doorsnijding kan overstijgen. Betekent dat nu dat de maximale stroom ook zal worden bereikt

74

door deze algoritme? Helaas niet. Er bestaan netwerken waarin de restcapaciteit langs stroomver-
grotende paden die door deze algoritme gevonden worden een machtreeks vormen met een factor
kleiner dan 1, en waarin de werkelijke maximale stroom nooit bereikt wordt. Wel kunnen we in-
ductief a(cid:13)eiden dat als de capaciteiten in het netwerk gehele getallen zijn, de stroom steeds met
een gehele waarde toeneemt. Dat betekent dat het aantal stappen in een netwerk met geheeltal-
lige capaciteiten eindig is. Omdat een getal n in log n bits gerepresenteerd kan worden geeft deze
observatie echter niet een betere dan exponenti(cid:127)ele bovengrens voor de complexiteit van het maxi-
maliseren van de stroom in een netwerk. Ook met geheeltallige capaciteiten kan de algoritme van
Ford en Fulkerson nog onacceptabel traag kan zijn, getuige het volgende voorbeeld.

Voorbeeld 3.3.1: Beschouw de volgende graaf

50

50

(cid:14)s

(cid:14)t

50

50

(cid:14)v

1

(cid:14)w

Een stroomvergrotend pad is, als de stroom 0 is het pad s,v,w,t. Hierlangs kan de stroom met
1 vergroot worden. Daarna is echter het pad s,w,v,t een stroomvergrotend pad geworden. Immers
de stroom kan worden vergroot door 1 eenheid langs dit pad te sturen. De stroom van v naar w
wordt daardoor weer 0. De algoritme die stroomvergrotende paden vindt zal dus in dit netwerk 50
stappen kunnen doen voordat de maximale stroom gevonden wordt. Als echter meteen de goede
paden gekozen worden, dan zal de algoritme slechts twee keer een stroomvergrotend pad hoeven te
2
selecteren.

De algoritme geeft wel een bewijs voor het tweede onderdeel van de min-cut-max-(cid:13)ow stelling,
namelijk een maximale stroom in een netwerk is minstens gelijk aan de minimale capaciteit van
een doorsnijding. Stel namelijk maar dat een maximale stroom bereikt is. Er is kan dan geen
stroomvergrotend pad meer worden gevonden. Dat betekent dat de algoritme t en mogelijk een
aantal andere knopen niet aan M zal toevoegen in regel 2. Er is dus een doorsnijding te de(cid:12)nieren,
nl. het paar (M; V (cid:0) M ), zo dat v 2 M , en t 2 V (cid:0) M . Deze doorsnijding heeft (cid:19)e(cid:19)en of andere
capaciteit. Er loopt geen kant e van M naar V (cid:0) M waarvoor f (e) < c(e), noch loopt er een kant
e0 van V (cid:0) M naar M waarvoor f (e0) > 0. Als dit wel het geval was, dan was M namelijk minstens
(cid:19)e(cid:19)en knoop groter geweest. Dat wil zeggen dat de stroom in het netwerk tenminste gelijk is aan de
capaciteit van de doorsnijding (M; V (cid:0) M ).

De mogelijke traagheid van de Ford-Fulkerson algoritme ligt in het feit dat we onhandig stroom-
vergrotende paden kunnen kiezen. Er is geen duidelijke eigenschap van het netwerk dat het mogelijk
maakt op een handige manier een stroomvergrotend pad te kiezen. Wel geven netwerk en stroom
samen een methode die het totaal aantal stroomvergrotende paden dat gevonden moet worden zo
klein mogelijk houdt. Netwerk en stroom geven namelijk samen een methode om een zogenoemd
gelaagd netwerk te de(cid:12)ni(cid:127)eren, vanwaaruit een nieuwe (grotere) stroom gevonden kan worden. Deze
techniek leidt tot maximalisering van de stroom in een aantal stappen dat begrensd wordt door een
functie van het aantal knopen. Een dramatische verbetering van de complexiteit.

75

(cid:15)
(cid:15)
 
 
>
>
 
 
>
>
3.3.2 Gelaagde Netwerken

Stroomvergrotende paden in een netwerk worden gevonden door paden van s naar t te vinden. In
die paden nemen we kanten in de richting van s naar t op als er een stroom doorheen loopt die
kleiner is dan de capaciteit. Kanten in de richting van t naar s worden opgenomen waardoorheen
een stroom loopt die groter is dan 0. In plaats van elke keer zo’n kant te kiezen en met die kanten
een pad te construeren, geven we nu een methode die als het ware alle stroomvergrotende paden
tegelijkertijd vindt.

een stroomfunctie f gegeven zijn. We de(cid:12)ni(cid:127)eren inductief het gelaagde netwerk L(N ) als volgt.

Laat een netwerk N bestaande uit een graaf G met knopen s en t, een capaciteitfunctie c en
Laag 0 van L(N ) bestaat uit de verzameling fsg. Verder bestaat de i + 1ste laag van L(N ) uit
alle knopen w die nog niet zijn opgenomen in een eerdere laag waarvoor er een knoop v in de i de
laag zit met.

1. Er is een kant van v naar w met f ((v; w)) < c((v; w)), of

2. Er is een kant van w naar v met f ((v; w)) > 0.

De laatste laag van het netwerk bestaat uit de knoop t. Van laag i naar laag i + 1 voegen we
steeds de kanten toe die tot opname van een knoop in laag i + 1 hebben geleid, met als capaciteit
c(e) (cid:0) f (e) of f (e) afhankelijk van de richting waarin de kant in N loopt, totdat we het stadium
bereiken dat t in (cid:19)e(cid:19)en of andere laag opgenomen wordt. De knoop t zit altijd alleen in de laatste
laag van het netwerk. Om de constructie te verduidelijken geven we een klein voorbeeldje. Merk
op dat als een knoop v in laag i zit, dat er dan geen kanten zijn van knoop v van of naar knopen in
laag j < i (cid:0) 1 met de bovenbeschreven eigenschappen. Immers, als die er wel zouden zijn, dan zou
knoop v al opgenomen zijn in laag j + 1. De hierbeschreven methode geeft een beschrijving van een
netwerk waarin altijd nette stroomvergrotende paden lopen, die bestaan uit kanten van laag i naar
laag i + 1.

Voorbeeld 3.3.2: Netwerk

2

37

3

4

17=31

75

91

5

6

7

15=37

20=43

1

Gelaagd Netwerk

20

5=45

8

65

20=37

10=84

52=80

37=93

10=79

37=77

9

11

37=84

10=89

25=25

2=3

10

8=63

76

(cid:127)
(cid:127)
/
/
/
/
(cid:18)
(cid:18)
(cid:15)
(cid:15)
 
 
/
/
)
)
2
2
o
o
O
O
?
?
o
o
(cid:127)
(cid:127)
O
O
~
~
?
?
/
/
/
/
L
L
40

8

5

3

69

56

22

23

1

28

10

25

11

17

6

2

Als nu de lagen van het nieuwe netwerk V1; V2; : : : ; Vk zijn, dan lopen alle stroomvergrotende
paden door opeenvolgende lagen. We kunnen nu, beginnend met de kant met minimale capaciteit
tussen twee lagen, de stroom vergroten net zolang tot de capaciteit van (cid:19)e(cid:19)en van de doorsnijdingen
bereikt is. We noemen zo’n maximale stroom in een gelaagd netwerk een blokkerende stroom en
we vinden zo’n stroom als volgt. Laat de restcapaciteit van een knoop het minimum zijn van de
som van de restcapaciteiten van zijn uitgaande kanten en de som van de restcapaciteiten van de
ingaande kanten. We zoeken de knoop met minimale restcapaciteit, en voegen deze capaciteit eerst
toe als stroom aan de uitgaande kanten van de knoop. Vervolgens duwen we deze stroom door
het netwerk als volgt. Eerst zorgen we ervoor dat in lagen hoger dan de laag waarin deze knoop
zit de behoudswetten weer gelden, en daarna zorgen we ervoor dat ook in de lagen lager dan de
laag waarin deze knoop zit de behoudswetten weer gaan gelden. We beginnen met deze knoop en
zijn ingaande kanten. Minimaal (cid:19)e(cid:19)en knoop in het gelaagde netwerk is nu verzadigd. We halen deze
knoop met met al zijn ingaande en uitgaande kanten uit het netwerk en passen de stroom aan zodat
de behoudswetten weer gelden. Als er nog een stroomvergrotend pad van s naar t is, dan herhalen
we de procedure, anders hebben we een blokkerende stroom gevonden.

De blokkerende stroom kan nu worden opgeteld bij de stroom in het netwerk en een nieuw
gelaagd netwerk kan worden berekend. Een nieuw gelaagd netwerk kan niet al te vaak worden
berekend. We kunnen bewijzen dat elk nieuw gelaagd netwerk dat wordt berekend na een nieuwe,
blokkerende stroom, bij de stroom te hebben opgeteld tenminste (cid:19)e(cid:19)en laag dieper is dan het vorige.
Aangezien er hoogstens V knopen zijn, betekent dit dat ten hoogste V zulke fasen in de volgende
algoritme zitten.

1: repeat
2:

compute layered network Y = LN (N; f );
if t 2 Y then compute blocking (cid:13)ow in Y ;
else

write (cid:13)ow at maximum; exit

3:
4:
5:
6:
7:
8: until exit occurs

end if
add blocking (cid:13)ow to f

In ons voorbeeld gelaagde netwerk is eerst knoop 5 de knoop met de kleinste capaciteit (22).
Na aanpassing van het netwerk en verwijdering van knoop 5, is knoop 8 de knoop met de kleinste
capaciteit (6). Als knoop 8 verwijderd is, is er geen pad meer van s naar t. We kunnen in totaal
28 eenheden bij de stroom optellen en een nieuw gelaagd netwerk berekenen. De algoritme die een
maximale stroom vindt met behulp van blokkerende netwerken wordt MKM algoritme genoemd,
naar de bedenkers Malhotra, Kumar en Maheshwari [MKM78].

77

/
/
(cid:31)
(cid:31)
 
 
@
@
/
/
?
?
(cid:31)
(cid:31)
/
/
Een gelaagd netwerk vindt als het ware alle huidige stroomvergrotende paden \tegelijk". Dat
betekent niet dat een kant maar (cid:19)e(cid:19)en keer gebruikt wordt in een gelaagd netwerk. Een klein voor-
beeldje.

Voorbeeld 3.3.3: Beschouw de volgende graaf

Het eerste gelaagde newerk (met blocking (cid:13)ow) is

0=1 /

2

1

0=1

0=1

0=2

0=2

0=3

0=5

1=1

1=1

1=3

1=5

0=1 /

1=1 /

1=1 /

1=1 /

5

2

5

2

5

2

4

1

4

1

4

4

1=3

1=5

0=2

0=2

1=1 /

s

s

s

s

t

t

t

Waarna de nieuwe stroom wordt

1=1

1=1

Het nieuwe gelaagde newerk (met blocking (cid:13)ow) wordt nu:

1=2 /

1=2 /

1=1 /

1

1=2 /

5

2=4 /

t

2

Zoals uit het voorbeeld blijkt, kunnen we niet voorkomen dat de stroom in (cid:19)e(cid:19)en kant meerdere
keren omhoog en omlaag gaat. Wel kunnen we bewijzen dat elke keer dat het gelaagde netwerk
geconstrueerd wordt, het minstens (cid:19)e(cid:19)en kant dieper is dan de vorige keer. Aangezien er niet meer dan
n knopen in het netwerk zitten, betekent dat dat het gelaagde netwerk hoogstens n keer gemaakt
wordt. Dit geeft een bovengrens op de complexiteit van de berekening van de maximale stroom.

78

/
(cid:23)
(cid:23)
(cid:30)
(cid:30)
@
@
(cid:30)
(cid:30)
/
G
G
@
@
/
(cid:30)
(cid:30)
@
@
(cid:30)
(cid:30)
/
@
@
/
(cid:23)
(cid:23)
(cid:30)
(cid:30)
@
@
(cid:30)
(cid:30)
/
G
G
@
@
/
/
/
/
/
3.4 Toepassingen van Network Flow

De algoritmen die we besproken hebben voor het maximaliseren van de stroom kunnen we gebruiken
om andere problemen op te lossen. Veel toepassingen zijn denkbaar, we noemen er hier drie.

3.4.1 Perfect Matching

Als eerste voorbeeld bekijken we het probleem PERFECT MATCHING, dat we ook verderop in
deze tekst in een wat ingewikkelder vorm tegen zullen komen. Gegeven is een ongerichte tweedelige
graaf G = ((V1; V2); E) en gevraagd is een deelverzameling van de kanten te vinden, zo dat elke
knoop in het ene deel van de graaf verbonden is met precies (cid:19)e(cid:19)en knoop in het andere deel van
de graaf. Dit probleem is met het maximaliseren van stromen op te lossen als volgt. Geef alle
kanten in G een richting zodat ze van V1 naar V2 lopen. Voeg aan V twee knopen s en t toe.
Verbind s met alle knopen uit V1, en t met alle knopen uit V2, waarbij de nieuwe kanten uit s en
in t gericht zijn. Tenslotte krijgen alle kanten capaciteit 1. We kunnen nu bewijzen dat zowel de
Ford-Fulkerson algoritme als de gelaagde netwerk algoritme een maximale stroom vindt waarbij
elke kant stroom 1 of 0 heeft, en dat door elke knoop in V1 en V2 precies (cid:19)e(cid:19)en enheid stroom gaat.
Immers, de restcapaciteit bij elke update van de (cid:13)ow algoritme is steeds een geheel getal en de
totale inkomende capaciteit van elke knoop in V1 is 1 terwijl de totale uitgaande capaciteit van een
knoop in V2 eveneens 1 is. Als we nu alle kanten tussen V1 en V2 selecteren waarlangs een stroom
1 loopt, dan hebben we een perfecte matching gevonden.

3.4.2 Connectivity

Een belangrijk probleem dat samenhangt met het al eerder besproken probleem van het vinden van
articulation points is het vinden van de connectiviteit van een graaf. De connectiviteit van een graaf
is het minimum aantal kanten dat verwijderd moet worden om tenminste twee componenten over
te houden. Dit probleem kunnen we [ET75] oplossen met de algoritme voor het maximaliseren van
de stroom in een netwerk, als volgt. Laat een graaf G = (V; E) gegeven zijn. We maken netwerk
N = (V; E; f ) door 1 als source te gebruiken en een willekeurige knoop j als sink. Vervolgens
vervangen we elk paar (v; w) 2 E door een kant in beide richtingen die allebei capaciteit 1 hebben en
berekenen een maximale stroom Fj. Het maximum van de getallen F1; : : : ; Fn is de edge connectivity
van G.

3.4.3 Matrixsommen

De laatste toepassing van stromen in netwerken die we bespreken is het probleem van de matrix-
sommen.

naam: Matrix Som
gegeven: Twee verzamelingen getallen R en C
gevraagd: Is het mogelijk een 0/1 matrix op te stellen zodat de getallen in R precies de rij-

sommen zijn en de getallen in C precies de kolomsommen zijn?

Ook dit probleem kan met netwerk (cid:13)ow worden opgelost. Stel maar dat de rijsommen r1; : : : ; rm
zijn en de kolomsommen s1; : : : ; sn. We maken een netwerk N als volgt. De knoop s is verbonden
met knopen x1; : : : ; xn door kanten met capaciteit r1; : : : ; rn respectievelijk, en de vanuit de knopen
y1; : : : ; ym lopen kanten met capaciteit s1; : : : ; sm respectievelijk naar t. Verder loopt van elke xi

79

een kant naar elke yj met capaciteit 1. Maximaliseer de stroom en zet een 1 op plaats (i; j) in de
matrix als in de maximale stroom de stroom door de corresponderende kant 1 is.

3.4.4 Sommen

1. Bewijs dat een graaf met n knopen en meer dan n (cid:0) 1 kanten een cykel heeft.

2. Kijk naar de volgende algoritme voor ongerichte grafen G = (V; E).

Find nodes v; v0 such that there is no path from v to v0;
Add (v; v0) to E;

1: repeat
2:
3:
4: until no such pair can be found
Als jjV jj = n, dan is de scherpste afschatting voor het aantal keren dat de repeat loop wordt
uitgevoerd O(

n), O(n), O(n2) of O(n3)? Waarom?

p

3. n > 1 personen staan op een veld, gewapend met een taart.

Iedereen heeft een unieke
dichtstbijstaande buur die met 100% zekerheid geraakt wordt, en iedereen gooit tegelijkertijd.
Als iemand niet geraakt wordt noemen we die persoon

overlevende".
"

(a) Geef een voorbeeld waarbij er geen overlevenden zijn, en een voorbeeld waarbij er meer

dan (cid:19)e(cid:19)en overlevende is.

(b) Laat zien dat voor oneven n er altijd minstens (cid:19)e(cid:19)en overlevende is.

4. Een gerichte acyclische graaf is een tralie als hij een knoop s heeft, zodat van s naar elke
andere knoop in de graaf een pad loopt en een knoop t, zodat vanuit elke andere knoop in de
graaf een pad naar t loopt.

(a) Beschrijf een algoritme die voor een input gerichte acyclische graaf beslist of het een

tralie is.

(b) Wat is de worst-case looptijd van de algoritme?
(c) Gegeven een graaf met gewogen kanten. Laat A(cid:3) algoritme gebruik maken van de heu-
ristiek h, die de afstand van twee punten op het papier waarop de graaf getekend is
berekent. Bedenk een graaf met twee punten A en B zo dat de algoritme een pad tussen
A en B produceert dat langs alle punten gaat, en niet het optimale pad is.

5. Een toernooi (ook wel volledige gerichte graaf genoemd) is een graaf waarbij elk tweetal
punten door een kant verbonden wordt. Een kampioen in een toernooi is een punt dat afstand
hoogstens twee tot elk ander punt heeft. Dwz. k is een kampioen als voor elke x in het toernooi
er ofwel een kant van k naar x is ofwel er een y in het toernooi is, zo dat er een kant van k
naar y en een kant van y naar x bestaat. Bewijs (met inductie) dat elk toernooi een kampioen
heeft. Is zo’n kampioen uniek?

6. Bewijs met inductie dat in een netwerk met geheeltallige capaciteiten, de algoritme van Ford

en Fulkerson altijd convergeert.

7. Laat zien dat er netwerken bestaan waarin de algoritme van Ford en Fulkerson niet conver-

geert.

80

8. Bewijs dat na de berekening van een blokkerende stroom en aanpassing van de stroom in het

originele netwerk het nieuwe gelaagde netwerk altijd tenminste (cid:19)e(cid:19)en laag dieper is.

9. Het probleem System of Distinct Representatives (SDR) wordt als volgt gede(cid:12)nieerd.

naam: SDR
gegeven: Een collectie deelverzamelingen fSigm
gevraagd: Bestaat er een S0 = fu0

1; : : : ; u0

i=1 van een verzameling U = fu1; : : : ; ung

i 2 Si en u0

i 6= u0

j voor i 6= j?

mg, z(cid:19)o dat u0

Geef een algoritme voor dit probleem m.b.v. netwerkstromen.

10. Een stel families gaan samen uit eten. Om de sociale interactie te vergroten willen ze een
tafelarrangement bedenken zo dat geen twee leden van dezelfde familie aan dezelfde tafel
zitten. Stel dat er p families zijn en dat de i-de familie a(i) leden heeft. Stel ook dat er q
tafels beschikbaar zijn en dat de j-de tafel capaciteit q(j) heeft. Formuleer dit probleem als
een network-(cid:13)ow probleem.

programmeren

1. Een reisbureau heeft over de hele wereld 1000 vestigingen, die tegelijkertijd toegang hebben
tot een gedistribueerd databasesysteem om plaatsen op bepaalde vluchten te reserveren. De
plaatsen zijn aangegeven alleen door stoelnummers, maar een stoelnummer kan natuurlijk
ook de vlucht waarvan zij deel uitmaakt identi(cid:12)ceren. Als reserveringen verschillende stoel-
nummers betre(cid:11)en, kan de database ze tegelijkertijd (in (cid:19)e(cid:19)en batch) vastleggen, maar sommige
vluchten zijn populairder dan andere, en dus komt het vaak voor dat twee of meer reserve-
ringen voor hetzelfde stoelnummer gemaakt moeten worden. Die moeten dan in volgorde van
binnenkomst worden afgehandeld. Implementeer een batch van 100000 aanvragen, waarbij
stoelnummers random tussen de 1 en de 500 worden gekozen. Het programma moet een
verdeling maken van de transacties zo dat zo min mogelijk batches voorkomen.

2. Stel eens dat ons reisbureau alleen maar van paren transacties kan vaststellen dat ze niet gelijk-
tijdig gedraaid kunnen worden. Dus niet per se omdat ze dezelfde stoel willen reserveren maar
bijvoorbeeld omdat ze een printer in hetzelfde kantoor willen gebruiken, dezelfde vluchttabel
willen raadplegen of wat dan ook. Nu kan dus alleen van twee transacties T1 en T2 worden
vastgesteld dat ze niet tegelijkertijd uitgevoerd kunnen worden, maar niet noodzakelijk van
grotere verzamelingen. Hoe pak je nu het probleem aan?

3. Maak een netwerk van ongeveer 100 knopen met willekeurige capaciteiten tussen de 1 en de
100. Vergelijk op dit netwerk de snelheden van de Ford-Fulkerson algoritme en de MKM
algoritme.

81

82

Hoofdstuk 4

Numerieke Algoritmen

4.1 De Euclidische Algoritme en Uitbreidingen

de oudste algoritme" genoemd, de algoritme om de grootste gemene deler van twee
Het wordt wel
"
Elementen" van Euclides, ongeveer 300 voor
getallen te bepalen. Voor het eerst beschreven in
"
Christus en oorspronkelijk geformuleerd als een meetkundig probleem: zoek een gemeenschappelijke
maat voor twee lijnstukken. Deze algoritme echter was bijna zeker al 200 jaar eerder bekend bij
Eudoxus van Cnidus (375vChr) en ook Aristoteles verwijst er in 330 vChr al naar in zijn Topica.
de Euclidische Algoritme" is dus waarschijnlijk net zo min van
De algoritme die wij kennen als
"
Stelling van Pythagoras"van Pythagoras was (het is bekend dat deze stelling door
Euclides als de
"
Pythagoras gestolen is van de Babyloniers). Niettemin zullen wij de algoritme uit deze sectie
de
"
Euclidische Algoritme noemen" en de pas veel later bekend geworden uitbreiding die we nodig
Uitgebreide Euclidische Algoritme". Waar ging het ook alweer over?
hebben in Sectie 4.5 als de
"
Als we twee getallen a en b hebben, dan is er een grootste getal dat beide getallen deelt. Als dat
getal 1 is, dan zeggen we dat a en b relatief priem zijn, anders kunnen wij een groter getal dan
1 vinden dat beide getallen deelt, maar hoe? We zouden bijvoorbeeld de beide getallen kunnen
ontbinden in (priem)factoren, en dan de kleinste machten van de gemeenschappelijke priemfactoren
kunnen uitvermenigvuldigen. Bijvoorbeeld 1400 = 23 (cid:1) 52 (cid:1) 7 en 6860 = 22 (cid:1) 5 (cid:1) 73, waaruit volgt
dat de grootste gemene deler van 1400 en 6860 gelijk is aan 22 (cid:1) 5 (cid:1) 7 = 140. Dat geeft zeker de
grootste gemene deler, maar is, zeker voor grote getallen, een moeizaam proces. Veel simpeler is
de algoritme gebaseerd op de volgende observatie. Als je twee getallen a en b hebt en a = qb + t,
dan deelt elk getal dat zowel t als b deelt ook a. De grootste gemene deler van t en b is dus ook de
grootste gemene deler van a en b. Als b = 0, dan is a de grootste gemene deler van a en b, want
elk getal deelt 0. Dit suggereert een recursieve algoritme: (cid:19)of (cid:19)e(cid:19)en van a en b is 0 en dan is het klaar,
(cid:19)of a > b en dan schrijven we a = qb + t met t zo klein mogelijk en gaan verder met b en t. We
schrijven dit in pseudocode in Figuur 4.1

Als r gelijk aan 0 is geworden, dan is b gelijk geworden aan de grootste gemene deler van de
oorspronkelijke getallen. Deze algoritme is aanzienlijk e(cid:14)ci(cid:127)enter dan het ontbinden in factoren.
Aangezien in elke iteratie de getallen minstens door 2 gedeeld worden kan de loop niet vaker dan
log keer doorlopen worden, in het aantal bits van de input is dat dus lineair. Hierbij nemen we
echter aan dat elke deling (cid:19)e(cid:19)en stap kost, wat bij grote getallen misschien niet een re(cid:127)ele aanname is.

83

1: r = a mod b
2: while r 6= 0 do

a = b
b = r
r = a mod b

3:
4:
5:
6: end while

Figuur 4.1: grootste gemene deler

4.1.1 De Uitgebreide Euclidische Algoritme en Inversen

Neem twee getallen a > b. Als de grootste gemene deler van a en b gelijk is aan 1, dan heeft b een
multiplicatieve inverse modulo a, ofwel, er is een getal x zodanig dat bx mod a = ggd(a; b) = 1. Dit
getal x kan bij het bepalen van de grootste gemene deler van a en b door de Euclidische algoritme
gevonden worden. Dat gaat als volgt.

De Euclidische algoritme is gebaseerd op de waarneming dat de grootste gemene deler van twee
getallen a en b gelijk is aan de grootste gemene deler van b en a mod b, ofwel als a = qb + r en
r = a mod b, dan geldt d = ggd(a; b) = ggd(b; r). De recursie gaat net zolang door totdat b = 0
en d = r. Stel nu eens dat de recursieve algoritme gebaseerd op deze observatie niet alleen de ggd
terug zou geven maar ook twee getallen k en l zodat d = kb + lr. Dat klopt in ieder geval op de
bodem, want dan b = 0, d = r en l = 1, maar als het op (cid:19)e(cid:19)en of ander niveau klopt, dan klopt het
ook een niveau hoger, want als d = kb + lr = kb + l(a (cid:0) qb) = la + (k (cid:0) lq)b dan is d = xa + yb.
Als d gelijk is aan 1 en we rekenen modulo a, dan staat daar 1 = (k(cid:0)lq)b. Om de multiplicatieve
door te geven" naar
"

inverse van b modulo a te vinden, hoeven we dus alleen de k en de l weer
boven.

return (a,1,0)

1: function Egcd(a; b)
2: if b = 0 then
3:
4: else
5:
6:
7:

r = a mod b;
q = (a (cid:0) r)=b;
(d; k; l) = Egcd(b; r);
return(d; l; k (cid:0) lq);

8:
9: end if

Figuur 4.2: de uitgebreide Euclidische algoritme

Voorbeeld 4.1.1:

(cid:15) Een getallenvoorbeeld is altijd illustratief. We berekenen dus de inverse van 17 modulo 93
met deze algoritme. We beginnen met het uitvoeren van de uitgebreide Euclidische algoritme.

a = q (cid:2) b + r
93 = 5 (cid:2) 17 + 8
17 = 2 (cid:2) 8 + 1

84

De volgende stap is 0. De vergelijkingen d = kb + lr = kb + l(a(cid:0) qb) = la + (k (cid:0) lq)b vertellen
nu achtereenvolgens 1 = 1(cid:2) 17(cid:0) 2(cid:2) 8, 1 = 1(cid:2) 17(cid:0) 2(cid:2) (93(cid:0) 5(cid:2) 17), en 1 = (cid:0)2(cid:2) 93 + 11(cid:2) 17,
waaruit volgt dat 11 de inverse van 17 modulo 93 is.
Dus d = 1 = 11 (cid:2) 17 (cid:0) 2 (cid:2) 93 waaruit volgt dat 11 het gezochte getal is.

(cid:15) Met het diepste stuk van de recursie bovenop, wordt het wellicht nog duidelijker.

1 = 0 (cid:3) 6 + 1 (cid:3) 1
1 = 1 (cid:3) 25 + (cid:0)4 (cid:3) 6
(1; 1;(cid:0)4)
1 = 0 (cid:3) 16 + 1 (cid:3) 1
1 = 1 (cid:3) 17 + (cid:0)1 (cid:3) 16
1 = (cid:0)1 (cid:3) 135 + 8 (cid:3) 17
(1;(cid:0)1; 8)
1 = 0 (cid:3) 6 + 1 (cid:3) 1
1 = 1 (cid:3) 7 + (cid:0)1 (cid:3) 6
1 = (cid:0)1 (cid:3) 13 + 2 (cid:3) 7
1 = 2 (cid:3) 59 + (cid:0)9 (cid:3) 13
1 = (cid:0)9 (cid:3) 131 + 20 (cid:3) 59
1 = 20 (cid:3) 190 + (cid:0)29 (cid:3) 131
1 = (cid:0)29 (cid:3) 321 + 49 (cid:3) 190
1 = 49 (cid:3) 511 + (cid:0)78 (cid:3) 321

(1; 49;(cid:0)78)

2

Het resultaat van deze algoritme is een getal l dat modulo b de multiplicatieve inverse is van a

(uiteraard alleen als de grootste gemene deler van a en b gelijk is aan 1).

4.1.2

sommen

1. Schrijf een niet-recursieve versie van de Euclidische algoritme. Generaliseer dit tot een niet-

recursieve versie van de uitgebreide Euclidische algoritme.

2. Bewijs het bestaan van additieve inversen in Zp. Dat wil zeggen laat zien dat er voor elke

x 2 Zp een y 2 Zp bestaat z(cid:19)o dat x + y mod p = 0.

3. Maak een vermenigvuldigingstabel voor Z5, waar het element op plaats (i; j) in de tabel gelijk

is aan i (cid:3) j mod 5.

4. Bereken de multiplicatieve inversen van de getallen 435, 234, en 534 in Z947.

4.2 Vermenigvuldiging van Grote Getallen, DFT

4.2.1

Inleiding

Computers zijn rekenautomaten en rekenen, naast zoeken en sorteren, is nog steeds hun belang-
rijkste activiteit. Van de rekenkundige operaties: optellen, aftrekken, vermenigvuldigen, delen,

85

machtsverhe(cid:11)en en worteltrekken worden sommige veel vaker uitgevoerd dan andere, en zijn som-
mige complexer, dwz. vereisen meer rekenkracht dan andere.

In veel gevallen beschouwen we een optelling of vermenigvuldiging als een atomaire operatie, en
tellen voor elke vermenigvuldiging (cid:19)e(cid:19)en stap. Dat is niet altijd gerechtvaardigd, zie ook 5.2.2. Omdat
machines beperkte registergrootte hebben (meestal 8, 16, 32 of 64 bits), kan een vermenigvuldiging
van twee willekeurig grote getallen niet in (cid:19)e(cid:19)en stap worden uitgevoerd, maar moeten delen van de
getallen (vaak individuele cijfers) net zoals wanneer je met de hand en kladpapier vermenigvuldigt,
apart worden uitgevoerd. Het resultaat van de vermenigvuldiging volgt dan vaak uit een optelling
van de tussenresultaten. In deze sectie zullen we verschillende vermenigvuldingsalgoritmen bekijken,
beginnend met (cid:19)e(cid:19)en die we ook voor vermenigvuldiging met de hand gebruiken, en de complexiteit
van deze algoritmen analyseren. Zoals we gewend zijn, gaan we voorbij aan constante factoren in
de complexiteit, maar de lezer zij bijvoorbaat gewaarschuwd dat in de algoritmen die in deze sectie
gepresenteerd worden deze factoren wel degelijk een rol spelen. De meest e(cid:14)ci(cid:127)ente algoritme voor
vermenigvuldiging, die aan het eind gepresenteerd wordt, is daarom alleen zinvol bij het vermenig-
vuldigen van zeer grote getallen|enkele honderden cijfers. Gelukkig heeft het vermenigvuldigen
van zeer grote getallen tegenwoordig toepassing gevonden in de cryptogra(cid:12)e, zoals we verderop in
dit hoofdstuk zullen zien. Public key cryptosystemen maken gebruik van sleutels die het resultaat
zijn van de vermenigvuldiging van priemgetallen van enkele honderden cijfers. Om een boodschap
te coderen, wordt een getal dat de boodschap in binaire code voorstelt tot de macht zo’n groot
getal genomen. Hiervoor zijn dus meerdere vermenigvuldigingen met grote getallen nodig, evenals
een e(cid:14)ciente manier van machtsverhe(cid:11)en. Hierop komen we later terug.

4.2.2 De eerste algoritmen

De algoritme voor vermenigvuldiging die mensen het meest gebruiken is het
vierkante schema"
"
dat we op de basisschool leren. Stel dat we de getallen 981 en 1234 willen vermenigvuldigen. Dan
schrijven we deze getallen onder elkaar als.

Overigens zij opgemerkt dat dit cultuurbepaald is. Op de Engelse scholen wordt dit vermenig-

vuldigingsschema

andersom" geleerd als:
"

981
1234
3924
29430
196200
981000
1210554

981
1234
981000
196200
29430
3942
1210554

86

Hoeveel elementaire operaties (vermenigvuldiging van twee (cid:19)e(cid:19)encijfergetallen) kost dit? Als we
een getal van n cijfers met een getal van m cijfers vermenigvuldigen, dan kunnen we in het vierkant
van vermenigvuldiging hierboven zien dat er n(cid:2)m vermenigvuldigingen van (cid:19)e(cid:19)encijfergetallen gedaan
worden. Dit is niet optimaal.

4.3 Betere algoritmen voor vermenigvuldiging

Een andere manier om 2 getallen met elkaar te vermenigvuldigen wordt gegeven door het onder-
staande schema.

981
490
245
122
61
30
15
7
3
1

1234
2468
4936
9872
19744
39488
78976
157952
315904
631808

1234

4936

19744

78976
157952
315904
631808
1210554

Het maakt gebruik van de simpele observatie dat je twee operanden met elkaar kunt vermenig-
vuldigen door de ene operand herhaald te halveren terwijl de andere herhaald verdubbeld wordt.
Het gaat erom de resultaten te krijgen waarbij in de binaire representatie van de ene operand een 1
staat, dat zijn de punten waar bij de deling een oneven getal resulteert. Die waarden transporteren
we naar de rechterkolom en tellen we op.

Enige analyse leert dat deze algoritme nog steeds n2 bewerkingen doet om twee getallen van n
(cid:18)a la russe"
cijfers met elkaar te vermenigvuldigen. Voor computers heeft deze vermenigvuldiging
"
zoals hij genoemd wordt echter een zeer groot voordeel. Het betreft alleen vermenigvuldigen met
en delen door 2. In machines is dat een simpele shift operatie.

Een zeer populaire manier om algoritmen te ontwikkelen is de

verdeel-en-heersmethode" (zie
"
Sectie 2.2). Het probleem wordt uitgedrukt in twee of meer kleinere deelproblemen die dan ver-
volgens worden opgelost door ze weer in kleinere problemen te verdelen. Op de
bodem" van deze
"
aanpak ligt het oplossen van problemen van grootte 1 of kleiner. Die problemen kennen een triviale
oplossing.

We kunnen deze methode natuurlijk ook toepassen op vermenigvuldigingen. De bodem van de
vermenigvuldiging is immers het vermenigvuldigen van individuele cijfers. Hiervoor hebben wij op
de bassisschool tabellen (tafels) geleerd, dus dat kost geen inspanning. In ons voorbeeld ziet dat er
(op het (cid:19)e(cid:19)en na laagste niveau) zo uit:

vermenigvuldig
12
09
34
09
12
81
81
34

schuif
4
2
2
0

i)
ii)
iii)
iv)

resultaat
1080000
30600
97200
2754
1210554

87

We merken hier op dat we een truuk kunnen toepassen analoog aan de truuk die door Stras-
sen is ontwikkeld voor matrixvermenigvuldiging (zie 2.2.1). Het vermenigvuldigen van 2 getallen
van 4 cijfers kost namelijk op deze manier 4 vermenigvuldigingen van getallen van 2 cijfers (de
schuifoperaties daargelaten) als:

34 (cid:2) 81
=
2754
12 (cid:2) 81 (cid:2) 100 =
97200
34 (cid:2) 09 (cid:2) 100 =
30600
12 (cid:2) 09 (cid:2) 10000 = 1080000
1210554

Bijgevolg kost het vermenigvuldigen van twee getallen van n cijfers op deze manier 4log2n =
nlog2 4 = n2, dus in complexiteit winnen we weer niets. Echter met het volgende schema kunnen de
vier vermenigvuldigingen vervangen worden door drie vermenigvuldigingen: (a(cid:2) 100 + b)(c(cid:2) 100 +
d) = a(cid:2) c(cid:2) 100(cid:2) 100 + b(cid:2) c(cid:2) 100 + a(cid:2) d(cid:2) 100 + b(cid:2) d. Echter b(cid:2) c + a(cid:2) d = (a + b)(c + d)(cid:0) ac(cid:0) bd.
Dus als we (a + b)(c + d), ac, en bd uitrekenen, hebben we alles wat we nodig hebben (in drie
vermenigvuldigingen). In getallen:

09 (cid:2) 12 = 108
81 (cid:2) 34 = 2754

(09 + 81)(12 + 34) = 90 (cid:2) 46 = 4140

en

en

981 (cid:2) 1234 = 1080000 + (4140 (cid:0) 108 (cid:0) 2754) (cid:2) 100 + 2754 = 1210554

waardoor de complexiteit daalt tot nlog23 vermenigvuldigingen. Het is geen grote winst, maar
in geval miljoenen van deze vermenigvuldigingen moeten worden gedaan, of heel grote getallen met
elkaar vermenigvuldigd moeten worden, zeker de moeite waard.

4.3.1 De kampioen

In deze sectie zullen we een algoritme presenteren die vooralsnog als de snelste algoritme voor de
vermenigvuldiging wordt beschouwd. De algoritme is gebaseerd op de Fast Fourier transformatie,
in de vorige eeuw bedacht door Cooley en Tukey.

4.3.2 Getallen als polynomen

Kijk naar het getal 10230495. We kunnen het schrijven als

1 (cid:2) 107 + 0 (cid:2) 106 + 2 (cid:2) 105 + 3 (cid:2) 104 + 0 (cid:2) 103 + 4 (cid:2) 102 + 9 (cid:2) 101 + 5:

Elk getal van n cijfers is een polynoom van de graad n (cid:0) 1 uitgerekend in het punt 10. In plaats
van te onderzoeken hoe duur het vermenigvuldigen van getallen is, zouden we dus de algemenere
Hoe duur is het vermenigvuldigen van twee polynomen, en hoe duur is het
vraag kunnen stellen:
"
uitrekenen van een polynoom in een punt?"

88

We merken eerst op dat een polynoom van de graad n (cid:0) 1 geheel bepaald is als we de waarden
van het polynoom in n punten weten. Een lijn (eerstegraadspolynoom) ligt vast als we er twee
punten van kennen, en een parabool ligt vast als we er drie punten van kennen, immers het invullen
van drie waarden voor x en y in een vergelijking van de vorm y = ax2 + bx + c geeft drie lineaire
vergelijkingen met drie onbekenden. Algemener: het invullen van n punten in een vergelijking
y = an(cid:0)1xn(cid:0)1 + an(cid:0)2xn(cid:0)2 + : : : + a0 geeft n vergelijkingen met n onbekenden en dus hoogstens 1
oplossing voor an(cid:0)1; : : : ; a0.
Dus, als we n + m (cid:0) 1 punten van een polynoom weten dat het product is van een polynoom
van de graad n (cid:0) 1 en een polynoom van de graad m (cid:0) 1 dan ligt dat polynoom, omdat het van
de graad hoogstens n (cid:0) 1 + m (cid:0) 1 is, daarmee vast. Wanneer we echter voor een x de waarde van
een polynoom p1 in dat punt weten en we weten de waarde van een polynoom p2 in dat punt, dan
is het heel gemakkelijk te achterhalen wat de waarde van een polynoom p1 (cid:2) p2 in dat punt is.
Vermenigvuldig namelijk alleen die waarden met elkaar.
Als we dus n+m(cid:0)1 punten van p1 hebben en n+m(cid:0)1 punten van p2 in dezelfde rij x-waarden,
dan krijgen we met n+m(cid:0)1 vermenigvuldigingen een verzameling punten die het productpolynoom
volledig vastleggen.
Voorbeeld 4.3.1: In Figuur 4.3 zien we de gra(cid:12)eken van x2 + x + 1 en x3 (cid:0) 2x (cid:0) 1. Het product
van deze polynomen is een vijfdegraads polynoom. Om dit polynoom vast te leggen hebben we zes
punten nodig.

x2 + x + 1 x3 (cid:0) 2x (cid:0) 1

Een vijfdegraadspolynoom ziet eruit als ax5 + bx4 + cx3 + dx2 + ex + f . Om vergelijkingen

oplossen:

x
(cid:0)3
(cid:0)2
(cid:0)1
0
1
2

7
3
1
1
3
7

(cid:0)22
(cid:0)5
0
(cid:0)1
(cid:0)2
3

(cid:2)
(cid:0)154
(cid:0)15
0
(cid:0)1
(cid:0)6
21

(cid:0)243a + 81b (cid:0) 27c + 9d (cid:0) 3e + f = (cid:0)154
(cid:0)32a + 16b (cid:0) 8c + 4d (cid:0) 2e + f = (cid:0)15
0
(cid:0)1
(cid:0)6
21

(cid:0)a + b (cid:0) c + d (cid:0) e + f =
f =
a + b + c + d + e + f =
32a + 16b + 8c + 4d + 2e + f =

Lossen we deze vergelijkingen op, dan vinden we a = 1, b = 1,c = (cid:0)1, d = (cid:0)3, e = (cid:0)3, en

f = (cid:0)1. Het productpolynoom wordt dus

x5 + x4 (cid:0) x3 (cid:0) 3x2 (cid:0) 3x (cid:0) 1:

De algoritme voor polynoomvermenigvuldiging:

reken de polynomen uit in n + m (cid:0) 1 punten
! reken de punten van het productpolynoom uit ! vertaal de punten terug naar co(cid:127)e(cid:14)cienten"
"
dringt zich op. De vraag is alleen: hoe duur zijn de buitenste vertaalslagen?

2

89

Figuur 4.3: x2 + x + 1, x3 (cid:0) 2x (cid:0) 1, en (x2 + x + 1)(x3 (cid:0) 2x (cid:0) 1)

Voor het uitrekenen van polynomen in punten zijn verschillende algoritmen bekend, bijvoorbeeld
x5 + 2x4 + 3x3 + x2 + x + 1 in 2 als 25 + 2(cid:1) 24 + 3(cid:1) 23 + 22 + 2 + 1 of ((((2 + 2)2 + 3)2 + 1)2 + 1)2 + 1. De
snelste algoritmen geven echter toch ongeveer n vermenigvuldigingen voor (cid:19)e(cid:19)en punt. Dat betekent
voor n + m(cid:0) 1 punten nog steeds kwadratische complexiteit. We moeten zoeken naar een methode
waarbij we de evaluatie van polynomen in n punten tegelijkertijd kunnen doen voor minder dan
O(n2) operaties. Dat vereist een stel punten met speciale eigenschappen. Zo’n stel punten is de
verzameling van de complexe n-de machts eenheidswortels.

4.3.3 Complexe n-de machts eenheidswortels
De complexe n-de machts eenheidswortels zijn de oplossingen van de vergelijking xn (cid:0) 1 = 0. In de
re(cid:127)ele getallen heeft deze vergelijking hoogstens 2 oplossingen, namelijk 1 en (cid:0)1 en dan alleen nog
voor even waarden van n. Laten wij echter complexe getallen toe van de vorm a + bi, waarbij a en
b re(cid:127)ele getallen zijn en i een getal met de eigenschap i2 = (cid:0)1, dan heeft de vergelijking plotseling
n oplossingen.

In 1.4.3 zagen we de reeksen voor sinus, cosinus en e-machten:

= P1
= P1
= P1
1(cid:0)x = P1
voor sin en cos. We zien dat cos x + i sin x =P1
P1

ex
sin x
cos x
log 1

m=0(ix)m=m! = eix.

m=0 xm=m!
r=0((cid:0)1)rx2r+1=(2r + 1)!
r=0((cid:0)1)rx2r=(2r)!
j+1 xj=j

r=0((cid:0)1)rx2r=(2r)! + iP1

Laten we het zojuist gede(cid:12)nieerde getal i eens gebruiken en eens invullen ix invullen in de reeksen
r=0((cid:0)1)rx2r+1=(2r + 1)! =

90

Vanwege de periodiciteit van sin en cos geldt nu dus voor elke n en 0 < j < n dat (e2(cid:25)ij=n)n =
cos 2j(cid:25) + i sin 2j(cid:25) = 1. Voor elke n zijn de n verschillende getallen !j(n) = ei2(cid:25)j=n = cos 2(cid:25)j=n +
i sin 2(cid:25)j=n de n verschillende oplossingen van de vergelijking xn (cid:0) 1 = 0. We noemen deze ge-
tallen de complexe n-de machts eenheidswortels en deze getallen hebben een aantal interessante
eigenschappen. Als n er niet to doet laten we n vaak weg uit de notatie en schrijven we !j.

j = !(cid:0)1

Laat ! = !1 = e2(cid:25)i=n, dan is !j = !j.
j (cid:2) !j = !n
1. !n(cid:0)1

2. Voor n > 1: Pn(cid:0)1

j want !n(cid:0)1
k=0 !k

j = 0 want

j = 1.

n(cid:0)1X

k=0

!k

j =

j (cid:0) 1
!n
!j (cid:0) 1

1 (cid:0) 1
!j (cid:0) 1

=

=

0

!j (cid:0) 1

= 0:

3. als !j een 2n-de machts eenheidswortel is, dan is !2

j een n-de machts eenheidswortel, want

!2n
j = (!2

j )n = 1.

4. Voor even n > 0 geldt !n=2 = (cid:0)1 want

n(cid:0)1X

k=0

0 =

!(n=2)k = !0 + !n=2 + : : : + !0 + !n=2 = (n=2)(1 + !n=2)

4.3.4 De Fast-Fourier transform

Precies deze eigenschappen geven genoeg voor het snel evalueren van polynomen in n punten. We
nemen voor het gemak aan dat n een macht van 2 is. Dat is geen beperking van de algemeenheid,
want als n geen tweemacht is, dan ligt er een tweemacht dicht bij n (kleiner dan n(cid:2) 2 en we kunnen
een polynoom altijd uitbreiden tot zijn graad een tweemacht is (door 0-co(cid:127)e(cid:14)cienten op te nemen).
Beschouw nu het polynoom p = an(cid:0)1xn(cid:0)1 + : : : + a0. We kunnen p onderverdelen in een even
polynoom pe en een oneven polynoom po als pe = an(cid:0)2xn(cid:0)2 + : : : + a0 en po = an(cid:0)1xn(cid:0)1 + : : : + a1x.
Verder is po = x(an(cid:0)1xn(cid:0)2 +: : :+a1). We gebruiken nu de eigenschap 3 uit het rijtje eigenschappen
en merken op dat het evalueren van een polynoom in een n de machts eenheidswortel kan worden
gedaan ten koste van de evaluatie van dat polynoom in een n=2-de machts eenheidswortel plus (cid:19)e(cid:19)en
vermenigvuldiging, en dat deze eigenschap recursief is.

Dit betekent dat we de evaluatie van de polynomen kunnen uitstellen totdat er niet zoveel
eenheidswortels zijn (bijvoorbeeld 1) en dan vervolgens de evaluatie van de polynomen daar kunnen
gebruiken om hogerop de evaluatie van grotere polynomen in ten koste van 1 vermenigvuldiging te
krijgen. De algoritme is dan als volgt.
Voor evaluatie van een polynoom van graad n(cid:0)1 in de n-de machts eenheidswortels. Evalueer pe
en po in alle n=2 de machts eenheidswortels en doe telkens 1 extra vermenigvuldiging. Probleem is
dat er natuurlijk maar half zoveel n=2e machts eenheidswortels zijn als n-de machts eenheidswortels,
maar dat probleem wordt opgelost door de periodiciteit van de laatste. In het volgende voorbeeld
lichten we dat toe.

Voorbeeld 4.3.2: Stel we evalueren het vijfde graads polynoom

2x5 + 2x4 + 4x3 + 2x2 + 8x + 1

91

in de achtste macht (cid:19)e(cid:19)enheidswortels en we zijn bij de berekening bij !5 = e2(cid:25)i5=8. We splitsen het
polynoom in

Invullen geeft

We zien dat

en

en

en

pe = 2x4 + 2x2 + 1

po = 2x5 + 4x3 + 8x = x(2x4 + 4x2 + 8):

pe(e2(cid:25)i5=8) = 2(e2(cid:25)i5=8)4 + 2(e2(cid:25)i5=8)2 + 1

po(e2(cid:25)i5=8) = (e2(cid:25)i5=8)(2(e2(cid:25)i5=8)4 + 4(e2(cid:25)i5=8)2 + 8):

pe(e2(cid:25)i5=8) = 2(e2(cid:25)i5=4)2 + 2(e2(cid:25)i5=4) + 1

po(e2(cid:25)i5=8) = (e2(cid:25)i5=8)(2(e2(cid:25)i5=4)2 + 4(e2(cid:25)i5=4) + 8):

We zien dus dat we de vierdemachts (cid:19)e(cid:19)enheidswortels nodig hebben, ware het niet dat er geen vijfde
vierdemachts eenheidswortel bestaat. Gelukkig is echter e2(cid:25)i5=4 = e2(cid:25)i1=4 vanwege de periodiciteit
2
van de (cid:19)e(cid:19)enheidswortels.

p

p
2 (cid:0) 0:5

Voorbeeld 4.3.3: We evalueren het 7e machts polynoom 3 + 2x + 2x2 + 0x3 + 4x4 + 0x5 +
2 (cid:0)
p
3x6 + 1x7 in de 8e machts (cid:19)e(cid:19)enheidswortels, [1; 0:5
0:5

2i;(cid:0)i; 0:5
In een tabel geven we steeds de even en oneven polynomen die uit de recursieve aanroepen
komen, tot de bodem, gevolgd door de waarden die we krijgen door de even polynomen op te tellen
bij het product van de oneven polynomen en de juiste eenheidswortels van het volgende niveau.

2i;(cid:0)1;(cid:0)0:5

p
2i; i;(cid:0)0:5

p
2 + 0:5

p
2 + 0:5

p

p

2i]

3 + 2x + 2x2 + 0x3 + 4x4 + 0x5 + 3x6 + 1x7
odd
even

3x0 + 2x2 + 4x4 + 3x6=

2x1 + 0x3 + 0x5 + 1x7=

3(x2)0 + 2(x2)1 + 4(x2)2 + 3(x2)3

x(2(x2)0 + 0(x2)1 + 0(x2)2 + 1(x2)3)

even

3x0 + 4x2=

odd

2x1 + 3x3=

even

2x0 + 0x2=

odd

0x1 + 1x3=

3(x2)0 + 4(x2)1
even
3x0
3

odd
4x1
4
[7;(cid:0)1]

x((2x2)0 + 3(x2)1)
even
2x0
2

odd
3x1
3
[5;(cid:0)1]
[12;(cid:0)1 (cid:0) i; 2;(cid:0)1 + i]
p
p
2 (cid:0) i + 0:5
[15;(cid:0)1 + 1:5
p
p
2 (cid:0) 1:0 (cid:0) i (cid:0) 0:5
9;(cid:0)1:5

2(x2)0 + 0(x2)1
even
2x0
2

odd
0x1
0
[2; 2]
[3; 2 (cid:0) i; 1; 2 + i]
p
2i; 2 + i;(cid:0)1:5
2 (cid:0) 1 + 0:5
p
2 (cid:0) 0:5
2i; 2 (cid:0) i;(cid:0)1 + 1:5

x(0x2)0 + 1(x2)1)
even
0x0
0

odd
1x1
1
[1;(cid:0)1]

2i + i;
2i + i]

p
p

De complexiteit van de hierboven beschreven algoritme is telkens n vermenigvuldigingen plus
de kosten van de evaluatie van de polynomen van de halve lengte. Waarbij het evalueren van een
polynoom van de graad 0 in alle 1 de machts eenheidswortels uiteraard als eenheidsstap gerekend

2

92

mag worden. In een recurrente betrekking: T (n) = n + 2T (n=2). De oplossing van deze betrekking
is T (n) = O(n log n).

4.3.5 De inverse Fourier transform

We zijn nu halverwege. We kunnen de beide polynomen voor de prijs van n log n vermenigvuldigin-
gen op n punten evalueren, en dan ten koste van n vermenigvuldigingen met elkaar vermenigvuldigen
om n punten van het productpolynoom in handen te krijgen. Dan moeten we echter terug. Geluk-
kig is de terugweg net zo eenvoudig als de heenweg. We beweren dat we de co(cid:127)e(cid:14)cienten van het
productpolynoom in handen kunnen krijgen door dezelfde algoritme toe te passen, maar nu met de
verkregen punten als co(cid:127)e(cid:14)cienten, en de evaluatie van de polynomen in de punten !(cid:0)1
. Om dat
in te zien beschouwen we de Fourier transformatie als matrixvermenigvuldiging. In Figuur 4.4 zien
we de matrix van de Fouriertransformatie en de inverse van die matrix onder elkaar.

j

F (cid:2) a =

1
!1
...

1
1
...
1 !n(cid:0)1

(cid:1)(cid:1)(cid:1)
1
(cid:1)(cid:1)(cid:1) !n(cid:0)1
...
...
(cid:1)(cid:1)(cid:1) !n(cid:0)1
n(cid:0)1

1

F (cid:0)1 =

1
n

1

1
1
1 !(cid:0)1
...
...
1 !(cid:0)1
n(cid:0)1

(cid:1)(cid:1)(cid:1)
(cid:1)(cid:1)(cid:1)
...
(cid:1)(cid:1)(cid:1)

1
(!(cid:0)1
1 )n(cid:0)1
...

(!(cid:0)1

n(cid:0)1)n(cid:0)1

1CCCA

0BBB@

1CCCA

a0
a1
...
an(cid:0)1

1CCCA :

0BBB@

0BBB@

Figuur 4.4: De Fourier transformatie en inverse

Immers

(F (cid:0)1 (cid:2) F )[i; j] = 1

k=0 !k
De entries van deze matrix zijn 1
n
Dit is

n

)k:

Pn(cid:0)1
Pn(cid:0)1
Pn(cid:0)1
k=0 1k = 1
k=0 (!i (cid:2) (!(cid:0)1

Pn(cid:0)1
i (cid:2) (!(cid:0)1
k=0 (!i (cid:2) (!(cid:0)1
Pn(cid:0)1

))k = 1
n

))k

j

j

j

( 1

n
1
n

k=0 !k

m = 0

als i = j en
als i 6= j

:

De algoritme voor de inverse Fourier transformatie kan dus dezelfde zijn en dus is die ook van
dezelfde complexiteit.
In totaal is er dus voor de vermenigvuldiging O(n log n + n + n log n) =
O(n log n) nodig.

Voorbeeld 4.3.4: We gaan het polynoom 1 + 4x + 3x3 vermenigvuldigen met het polynoom
1 + 3x + 4x2 + 2x3 + x4. De uitkomst is het zevende graads polynoom 1 + 7x + 16x2 + 21x3 + 18x4 +
16x5 + 6x6 + 3x7, zoals we vantevoren kunnen berekenen met bijvoorbeeld convolutie. Omdat het
productpolynoom graad 7 heeft, hebben we minstens 8 punten van dat polyoom nodig. De achtste
machts (cid:19)e(cid:19)enheiswortels zijn

p

1
2

[1;

2 +

p

i
2

2; i;(cid:0) 1
2

p

2 +

p

i
2

p

2;(cid:0)1;(cid:0) 1
2

2 (cid:0) i
2

p

2;(cid:0)i;

p

p

1
2

2 (cid:0) i
2

2]:

93

We berekenen eerst de waarden van 1 + 4x + 3x3 op deze wortels met Fouriertransformatie.
Omdat we de achtste machts (cid:19)e(cid:19)enheidswortels gebruiken, doen we net of het polynoom van de
zevende graad is, i.e.,

1 + 4x + 0x2 + 3x3 + 0x4 + 0x5 + 0x6 + 0x7:

Hieruit halen we de eerste even en oneven polynomen,

We halen een x uit po en delen de machten in allebei de polynomen door 2. We krijgen

en

en

Deze polynomen geven vier nieuwe polynomen

Dezelfde operaties geven

pe = 1 + 0x2 + 0x4 + 0x6

po = 4x + 3x3 + 0x5 + 0x7:

pe0 = 1 + 0x + 0x2 + 0x3

po0 = 4 + 3x + 0x2 + 0x3:

pe0e = 1 + 0x2
pe0o = 0x + 0x3
po0e = 4 + 0x2
po0o = 3x + 0x3

pe0e0 = 1 + 0x
pe0o0 = 0 + 0x
po0e0 = 4 + 0x
po0o0 = 3 + 0x

De volgende, laatste, verdeling in even en oneven geeft de bodem van de recursie met \polynomen"
1, 0, 0, 0, 4, 0, 3 en 0. Dit zijn allemaal 0-de graads polynomen en invullen van de 20 de machts
(cid:19)e(cid:19)enheidswortel, 1, transformeert deze polynomen naar evenzoveel waarden. Terugklimmend in de
recursie kunnen we nu deze polynomen paarsgewijs gebruiken om de waarden in de 21-e machts
eenheidswortels, 1 en (cid:0)1 te berekenen. We vinden:

1 + 0 (cid:3) 1 = 1; 1 + 0 (cid:3) (cid:0)1 = 1; 0 + 0 (cid:3) 1 = 0; 0 + 0 (cid:3) (cid:0)1 = 0; 4 + 0 (cid:3) 1 = 4; 4 + 0 (cid:3) (cid:0)1 = 4:

Deze vier kunnen we gebruiken met de vier vierdemachts eenheidswortels,

om de waarden

en

1; i;(cid:0)1;(cid:0)i

[1; 1; 1; 1]

[7; 4 + 3i; 1; 4 (cid:0) 3i]

94

voor de even en de oneven polynomen op het volgende level te krijgen. Tenslotte gebruiken we alle
wortels om het lijstje

p

p

2

[8;

2 +
2

2

+

7i
2

; 1 + i;

2 (cid:0) p

2

+

2

p
7i
2

2

;(cid:0)6;

2 (cid:0) p

2

2

p
(cid:0) 7i
2

2

; 1 (cid:0) i;

2 +
2

p

2

p
(cid:0) 7i
2

2

]

te krijgen.

Op dezelfde manier behandelen we 1 + 3x + 4x2 + 2x3 + x4 en vinden het lijstje
p

p

p

p

p

p
2 + (8 (cid:0) 5

2)i

; 1;(cid:0)

2 + (5
2

2

2 (cid:0) 8)i

;(cid:0)2 (cid:0) i;

p
2 + (8 + 5

2

[11;

2)i

;(cid:0)2 + i;(cid:0)

p

2)i

]:

2 (cid:0) (8 + 5

2

Deze twee lijstjes vermenigvuldigen we met elkaar en krijgen 8 nieuwe waarden

p
[ 88;(cid:0)13:5

(cid:0)6;(cid:0)17 + 13:5

p
p
2 + 10i;(cid:0)3 (cid:0) i;(cid:0)17 + 13:5
2 (cid:0) 17 + 4:5i
p
2 (cid:0) 4:5i
2 + 10i;(cid:0)3 + i;(cid:0)13:5

p
2 (cid:0) 10i + 4:5i
p
2;
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i
2]:

p

p

Deze waarden beschouwen we weer als de co(cid:127)e(cid:14)cienten van een (nu) zevende graads polynoom,

en we verdelen het polynoom weer in een even polynoom

pe = 88 (cid:0) (3 + i)x2 (cid:0) 6x4 (cid:0) (3 (cid:0) i)x6;

en een oneven polynoom
p
po = ((cid:0)13:5

p
2 (cid:0) 17 + 4:5i
p
2 (cid:0) 4:5i

p
((cid:0)17 + 13:5

p
2 + 10i)x + ((cid:0)17 + 13:5
p
2 + 10i)x5 + ((cid:0)13:5

p
2 (cid:0) 10i + 4:5i
p
2)x3+
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i
2)x7:

Net zoals hierboven delen we door x in het oneven polynoom en delen alle machten door 2 om te
krijgen.

pe0 = 88 (cid:0) (3 + i)x (cid:0) 6x2 (cid:0) (3 (cid:0) i)x3
p
po0 = (cid:0)13:5

p
p
2 + 10i + ((cid:0)17 + 13:5
2 (cid:0) 17 + 4:5i
2 (cid:0) 10i + 4:5i
p
p
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i
2 (cid:0) 4:5i
2 + 10i)x2 + ((cid:0)13:5

((cid:0)17 + 13:5

p

p

p
2)x+

2)x3:

Hieruit destilleren we de volgende even en oneven polynomen.

pe0e = 88 (cid:0) 6x2
pe0o = (cid:0)(3 + i)x (cid:0) (3 (cid:0) i)x3
p
p
2 (cid:0) 17 + 4:5i
po0e = (cid:0)13:5
p
po0o = ((cid:0)17 + 13:5

p
2 (cid:0) 10i + 4:5i

2 + 10i + ((cid:0)17 + 13:5
p
2)x + ((cid:0)13:5

p
2 (cid:0) 4:5i

p
p
2 + 10i)x2
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i

2)x3

Dezelfde operaties geven dan weer

pe0e0 = 88 (cid:0) 6x
pe0o0 = (cid:0)(3 + i) (cid:0) (3 (cid:0) i)x
p
p
2 (cid:0) 17 + 4:5i
po0e0 = (cid:0)13:5
p
po0o0 = ((cid:0)17 + 13:5

p
2 (cid:0) 10i + 4:5i

2 + 10i + ((cid:0)17 + 13:5
p
2) + ((cid:0)13:5

p
2 (cid:0) 4:5i

p
p
2 + 10i)x
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i

2)x

Er kan nu nog een keer gedeeld worden

95

En weer opschonen

pe0e0e = 88
pe0e0o = 6x
pe0o0e = (cid:0)(3 + i)
pe0o0o = (cid:0)(3 (cid:0) i)x
p
po0e0e = (cid:0)13:5
p
po0e0o = ((cid:0)17 + 13:5
p
po0o0e = ((cid:0)17 + 13:5
p
po0o0o = ((cid:0)13:5

p
2 (cid:0) 17 + 4:5i
p
2 + 10i
2 (cid:0) 4:5i
p
2 + 10i)x
2 (cid:0) 10i + 4:5i
p
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i

2)
2)x

pe0e0e0 = 88
pe0e0o0 = 6
pe0o0e0 = (cid:0)(3 + i)
pe0o0o0 = (cid:0)(3 (cid:0) i)
p
po0e0e0 = (cid:0)13:5
p
po0e0o0 = (cid:0)17 + 13:5
p
po0o0e0 = (cid:0)17 + 13:5
p
po0o0o0 = (cid:0)13:5

p
2 (cid:0) 17 + 4:5i
p
2 + 10i
2 (cid:0) 4:5i
p
2 + 10i
2 (cid:0) 10i + 4:5i
p
2
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i
2

We hebben weer acht polynomen waarin we achtereenvolgens waarden kunnen invullen. Zoals
we hierboven hebben gezien moeten we nu de (machten van de) inversen van de achtste machts
eenheidswortels gebruiken.
(1 = xn = xi (cid:3) xn(cid:0)i a(cid:13)edien.
p

De inversen van de achtste machts eenheidswortels kunnen we met de hierboven besproken regels

p

p

p

p

p

p

p

[1;

1
2

2 (cid:0) i
2

2;(cid:0)i;(cid:0) 1
2

2 (cid:0) i
2

2;(cid:0)1;(cid:0) 1
2

2 +

2; i;

2 +

2; ]:

1
2

i
2

i
2

De benodigde machten van deze eenheidswortels krijgen we door herhaald kwadrateren:

1 (cid:0)i (cid:0)1
1 (cid:0)1
1

i

De beginwaarden (met 1) geven het lijstje

[ 88; 6;(cid:0)(3 + i);(cid:0)3 + i;(cid:0)13:5

p
(cid:0)17 + 13:5

p
2 (cid:0) 4:5i

p

p
p
2 + 10i;(cid:0)17 + 13:5
2 (cid:0) 17 + 4:5i
p
p
2;(cid:0)13:5
2 (cid:0) 10i + 4:5i
2 (cid:0) 10i;(cid:0)17 + 13:5

2 (cid:0) 4:5i
p

2 + 10i;

p
2 (cid:0) 17 (cid:0) 10i (cid:0) 4:5i

2]

p

Dan met -1 en 1.

Dan met 1, (cid:0)i, (cid:0)1 en i

p
[82; 94]; [(cid:0)6;(cid:0)2i]; [(cid:0)34 + 20i; 27

p
2 + 9i

p
2]; [(cid:0)34 (cid:0) 20i; 27

p
2 + 9i

2]:

[76; 92; 88; 96]; [(cid:0)68;(cid:0)18

2 (cid:0) 18i

p

p

p
2; 40i;(cid:0)36

p
2 + 36i

2]:

96

En tenslotte [8; 56; 128; 168; 144; 128; 48; 24], hetgeen precies een factor 8 verwijderd is van de
co(cid:127)e(cid:14)cienten van het productpolynoom,

1 + 7x + 16x2 + 21x3 + 18x4 + 16x5 + 6x6 + 3x7, zoals verwacht.

2

4.4 Snelle Machtsverhe(cid:14)ng

In 4.5 hieronder zullen we niet alleen grote getallen met elkaar moeten vermenigvuldigen, maar we
zullen zelfs machten van grote getallen moeten berekenen. Gegeven een snelle vermenigvuldigingsal-
goritme is er ook een snelle algoritme om machten te berekenen. Deze algoritme is van het type
verdeel en heers" en is (cid:19)e(cid:19)en van de oudst bekende algoritmen van deze soort. Eerst merken we op
"
dat de na(cid:127)(cid:16)eve berekening van an ongeveer n vermenigvuldigingen van a met zichzelf vereist, en dat
bovendien de operanden in die vermenigvuldiging in ongeveer elke stap twee keer zo lang worden,
zodat zeker na een klein aantal stappen de lengte van de getallen mee moet worden genomen in de
complexiteit van de algoritme. Nu geldt dat an = (an=2)2 als a even is, en an = an(cid:0)1 (cid:2) a als a
oneven is. Dit betekent dat een verdeel-en-heersalgoritme voor an de volgende complexiteit heeft.

8<: 0

T (n) =

T (n=2) + 1
T (n (cid:0) 1) + 1

als n = 1
als n even is
als n oneven is

Dit is een eigenaardige functie. Bijvoorbeeld

T (31) = T (30) + 1 = T (15) + 2 = T (14) + 3 = T (7) + 4 =

= T (6) + 5 = T (3) + 6 = T (2) + 7 = T (1) + 8 = 8

T (32) = T (16) + 1 = T (8) + 2 = T (4) + 3 = T (2) + 4 = T (1) + 5 = 5

Voor T (2n) zien we n halveringsstappen, zodat T (2n) = n, terwijl voor T (2n (cid:0) 1) we n (cid:0) 1

halveringsstappen en n (cid:0) 1 stappen T (i) ! T (i (cid:0) 1), zodat T (2n (cid:0) 1) = 2(n (cid:0) 1). Met inductie:

T (2n+1)
T (2n+1 (cid:0) 1) = T (2n+1 (cid:0) 2) + 1 = T (2(2n (cid:0) 1)) + 1 = T (2n (cid:0) 1) + 2 =

= T (2n) + 1 = n + 1
= 2(n (cid:0) 1) + 2 = 2n

Omdat deze functie niet uiteindelijk niet dalend is, kunnen we niet toepassen wat we in Som 6(in 1.3.2)

op pagina 28 hebben bewezen. We merken echter op dat de functie lineair is, dus misschien
kunnen we boven en ondergrenzen vinden die wel monotoon zijn. Als n > 1 oneven is, dan is
T (n) = T (n(cid:0) 1) + 1 = T ((n(cid:0) 1)=2) + 2 = T (bn=2c) + 2. Als n even is, dan is T (n) = T (bn=2c) + 1,
dus altijd geldt:

T (bn=2c) + 1 (cid:20) T (n) (cid:20) T (bn=2c) + 2:

T wordt dus van beneden, resp. van boven begrensd door de functies T1 en T2 met

(cid:26) 0

Ti(n) =

Ti(bn=2c) + i

als n = 1
anders

Omdat T1 (cid:20) T (cid:20) T2 en beide functies in (cid:18)(log n) zitten geldt ook T (n) 2 (cid:18)(log n). Ofwel we kunnen
machtsverhe(cid:14)ng doen met een aantal vermenigvuldigingen dat lineair is de lengte van de exponent.

97

De e(cid:14)ci(cid:127)ente methode voor vermenigvuldigen hierboven beschreven geeft dat machtsverhe(cid:14)ng in
tijd O(n2 log n) waarin n een bovengrens is voor de lengte van de exponent en de grootste te
vermenigvuldigen getallen.

Een hiervan afgeleide methode om an te berekenen kan ook als volgt beschreven worden.

if Het volgende bit van n = 1 then

1: Schrijf n binair
2: s = 1
3: repeats = s2
4:
5:

s = s (cid:2) a

end if

6:
7: until De bits van n op zijn

Voorbeeld 4.4.1: Bereken 35
5 = 0B101
s = 1;
s2 = 1; s (cid:3) 3 = 3;
s2 = 9;
s2 = 81; s (cid:3) 3 = 243

Bereken 311

11 = 0B1011
s = 1;
s2 = 1; s (cid:3) 3 = 3;
s2 = 9;
s2 = 81; s (cid:3) 3 = 243
s2 = 59049; s (cid:3) 3 = 177147
In deze aanpak besteden we kennelijk niet meer vermenigvuldigingen dan het aantal bits in n, en
verder worden er steeds getallen vermenigvuldigd met a. Verder is het handig op te merken dat
we, als we modulo (cid:19)e(cid:19)en of ander getal m rekenen, we onderweg ook steeds mod m mogen reduceren,
2
waardoor de vermenigvuldigingen niet al te complex worden.

4.4.1

sommen

1. Het product van twee polynomen f en g waarbij de de co(cid:127)e(cid:14)cienten van xk(cid:0)i in f en xi in g met
elkaar vermenigvuldigd worden en vervolgens voor alle i (cid:20) k bij elkaar opgeteld worden om
in het productpolynoom de co(cid:127)e(cid:14)cient van xk te vormen, wordt ook wel
convolutieproduct"
"
genoemd. (Dit begrip heeft in de algebra een nog veel ruimere betekenis.) Met de DFT kunnen
we nu zo’n produkt snel uitrekenen. Gebruik de DFT voor de polynomen met co(cid:127)e(cid:14)cienten
1,2,3,4 en 4,3,2,1.

2. Voor elke verzameling fx0; : : : ; xn(cid:0)1g van re(cid:127)ele getallen is er precies (cid:19)e(cid:19)en n-de graads monadisch
(dwz. de co(cid:127)e(cid:14)cient van de hoogstegraadsterm is 1) polynoom, dat voor precies die waarden
0 wordt, namelijk (x (cid:0) x0)(x (cid:0) x1) : : : (x (cid:0) xn(cid:0)1). Geef een Verdeel-en-heersalgoritme die dit
polynoom in co(cid:127)e(cid:14)cienten geeft in tijd O(n log2 n).

98

4.5 Cryptogra(cid:12)e

Bij het uitwisselen en bewaren van gevoelige gegevens is het van belang dat deze niet tussentijds
door derden kunnen worden gelezen en/of bewerkt. Behalve het letterlijk achter slot en grendel
houden van de gegevens (dat houdt in zorgen dat niemand erbij kan door de deur waarachter zich
de gegevens bevinden gesloten te houden), is ook de versleuteling van de gegevens van belang.
Een goed cryptosysteem kan ervoor zorgen dat, zelfs als een derde persoon fysiek toegang krijgt
tot de data, zij er niets mee kan doen. Cryptosystemen hebben de eigenschap dat geauthoriseerde
personen gemakkelijk, dat wil zeggen computationeel eenvoudig, toegang hebben tot de data, terwijl
niet geauthoriseerde personen moeilijk (bij voorkeur geen) toegang hebben tot de data. Aangezien
aangenomen moet worden dat beiden toegang hebben tot de bron van de (bewerkte) data, moeten
geauthoriseerde personen dus beschikken over een hoeveelheid extra informatie, die de brondata
zinvol maakt.

Deze extra informatie wordt sleutel genoemd. Als meerdere personen toegang moeten hebben
tot de informatie, of als het bijvoorbeeld over informatie gaat die over een onbetrouwbare lijn
moet worden verstuurd wordt het ingewikkeld. Dan moeten meerdere personen zo’n sleutel delen,
verschillende sleutels moeten toegang bieden tot dezelfde informatie, of de informatie moet op
verschillende manieren versleuteld kunnen worden. In het laatste geval kan de ene partij versleutelde
informatie versturen zonder kennis te hebben van de sleutel van de andere partij. In het eerste geval
is de versleuteling symmetrisch (de sleutel die nodig is om te versleutelen is dezelfde als de sleutel
nodig om de informatie terug te vinden). De laatste situatie is asymmetrisch, de sleutel nodig
om de informatie te versleutelen is een andere dan die nodig is om de informatie terug te winnen.
In het eerste geval is het noodzakelijk de sleutel geheim te houden bij de partijen die informatie
uitwisselen (dit systeem wordt daarom \private key" genoemd) in het tweede geval is het niet altijd
nodig de sleutel die gebruikt wordt om te versleutelen geheim te houden. Deze zou door meerdere
partijen kunnen worden gebruikt om een versleutelde boodschap te sturen, mits deze versleuteling
wel de eigenschap heeft dat zij alleen met de juiste decodeersleutel kan worden teruggedraaid (het is
gebruikelijk de codeersleutel publiek te maken en daarom worden zulke systemen wel \public key"
genoemd).

4.5.1 Private Key

One Time Pad

De enige werkelijk veilige methode voor versleuteling waarbij beide partijen een sleutel delen is
ook een bijzonder simpele, de zogenoemde one-time pad. Hierbij kiezen beide partijen een string
random gegenereerde bits als sleutel die net zo lang is als de te coderen boodschap. Vervolgens
wordt de versleutelde boodschap berekend door bitsgewijs de XOR te nemen met de sleutel. De
ontvangende partij neemt bitsgewijs de XOR met dezelfde sleutel en krijgt de oorspronkelijke bood-
schap terug. Omdat de XOR van een random bitstring met IEDERE bitstring weer een random
bitstring oplevert, kan een afgeluisterde boodschap nooit worden gedecodeerd. Nadeel van deze
methode is wel dat een zeer lange sleutel eerst via een veilig kanaal moet worden uitgewisseld. In
de praktijk is deze methode daarom onbruikbaar.

99

kortere sleutels

Hoe lang de sleutel moet zijn om (enige) bescherming te bieden hangt af van de gebruikte ver-
sleutelingsalgoritme en van de computationele kracht van de tegenstander. Sleutels worden daarom
langer naarmate die computationele kracht (en de eigen computationele kracht) groeit, en versleute-
lingsalgoritmen worden ingewikkelder. Aangezien het uitwisselen van geheime sleutels een zeldzame
en dure operatie is, wordt dezelfde sleutel vaak hergebruikt, veelal zelfs in (cid:19)e(cid:19)en en dezelfde bood-
schap. Deze boodschap wordt daarom onderverdeeld in blokken van hetzelfde aantal bits, waarop
de versleuteling wordt toegepast. Vanwege deze onderverdeling worden dergelijk algoritmen
block
"
cypers" genoemd. Er zijn veel block cyphers bekend1, en veel van deze zijn gebaseerd op een zoge-
noemd Feistel netwerk beschreven door Horst Feistel van IBM in 1973. Een Feistel netwerk is een
algoritme die een blok data van een bepaald aantal bits versleutelt in een aantal rondes, waarbij de
volgende bewerking in iedere ronde wordt toegepast.

1. verdeel het blok in twee helften;

2. pas een rondefunctie F toe op de rechterhelft;

3. neem de XOR van de versleutelde rechterhelft en de linkerhelft; Dat is de nieuwe linkerhelft.

4. wissel de linker en rechterhelft om.

Ontsleuteling van de boodschap gebeurt door het toepassen van de versleutelingsalgoritme in

omgekeerde volgorde, met gebruikmaking van F (cid:0)1 als rondefunctie.

4.5.2 Sleutel Delen

Een van de eerste benodigdheden bij het gebruik van een private key cryptosysteem is het delen
van een sleutel. Partijen A en B kunnen zo’n sleutel natuurlijk vantevoren afspreken, vervolgens uit
elkaar gaan en de sleutel gaan gebruiken, maar geen enkele sleutel kan veilig onafgebroken worden
gebruikt. Regelmatig moet een sleutel worden vernieuwd om het systeem veilig te houden. Nieuwe
sleutels kunnen natuurlijk worden uitgewisseld door elkaar fysiek te ontmoeten en een nieuwe sleutel
af te spreken. Dit is echter altijd duur en lang niet altijd uitvoerbaar. Ook kan natuurlijk zo lang de
eerste sleutel nog veilig is, een nieuwe sleutel worden aangemaakt en gecodeerd worden verzonden.
Dit heeft echter het nadeel dat een deel van de veiligheid die de sleutel heeft wordt aangewend
om een nieuwe sleutel te versturen (en dus niet voor het coderen van boodschappen) en houdt
bovendien het risico in dat, omdat je niet zeker kunt weten wanneer een sleutel niet meer kan
worden gebruikt, de sleutel door derden is gevonden voor dat een nieuwe sleutel wordt verstuurd
(waardoor de nieuwe sleutel al meteen is gevonden).

Di(cid:14)e en Helman [DH76], naar een idee van Paul Merkle gebruikten in 1976 de volgende
methode om een geheime sleutel te delen over een onveilig kanaal. Neem een groot priemge-
tal p. Een getal a kleiner dan p heet een voortbrenger of primitief element van 1; : : : ; p als
f1; : : : ; pg = fa; a2; a3; : : : ; ap(cid:0)1g De machten van a lopen dan (mod p) langs alle getallen mo-
dulo p. Voor elk priemgetal p bestaat er minstens (cid:19)e(cid:19)en zo’n a. Stel dat er een p, priemgetal, en een

1onder andere: 3-Way,AES, Akelarre, Anubis, Blow(cid:12)sh, C2, Camellia, CAST-128, CAST-256, CMEA, CS-Cipher,
DEAL, DES, DES-X, FEAL, FROG, G-DES, GOST, Hasty Pudding Cipher, ICE, IDEA, IDEA NXT, Iraqi, KA-
SUMI, KHAZAD, Khufu and Khafre, Libelle, LOKI89/91, LOKI97, Lucifer, MacGu(cid:14)n, Madryga, MAGENTA,
MARS, MISTY1, MMB, NewDES, Noekeon, RC2, RC5, RC6, REDOC, Red Pike, S-1, SAFER, SEED, Serpent,
SHACAL, SHARK, Skipjack, SMS4, Square, TEA, Triple DES, Two(cid:12)sh, XTEA

100

a voortbrenger van 1; : : : ; p gegeven zijn. Twee partijen A en B kunnen nu als volgt een sleutel
uitwisselen over een publiek kanaal. A kiest een willekeurig getal XA < p en berekent YA = aXA
mod p. B kiest een willekeurig getal XB < p en berekent YB = aXB mod p. De waarden YA en
YB worden vervolgens uitgewisseld, en XA en XB worden geheim gehouden. A berekent (YB)XA
mod p en B berekent (YA)XB mod p. Zo krijgen ze allebei dezelfde waarde K in handen. Immers

K =

(YB)XA mod p

= (aXB mod p)XA mod p
=
=
= (aXA mod p)XB mod p
=

(aXB )XA mod p
(aXA )XB mod p

(YA)XB mod p

Omdat andere partijen niet de beschikking hebben over de X waarden is de publiek gemaakte in-
formatie, aangenomen dat het vinden van de discrete logaritme modulo p computationeel ondoenlijk
is, waardeloos.

4.5.3 Public Key

Hoewel het vermenigvuldigen van getallen een doel op zich is voor rekenautomaten is het ver-
menigvuldigen van echt grote getallen zeer veel meer in de belangstelling komen te staan na de
introductie van public key cryptosystemen als Rivest-Shamir-Adleman (RSA) uit 1978 [RSA78].
Het principe achter RSA is gebaseerd op de aanname dat de inverse operatie van vermenigvuldi-
ging, het ontbinden van een getal in zijn factoren een moeilijke operatie is, vooral wanneer het getal
groot is (tegenwoordig zo’n vierhonderd cijfers) en zelf het product is van twee priemgetallen. De
best bekende algoritme voor het ontbinden van een getal in factoren is tegenwoordig de zogenoemde
number (cid:12)eld sieve (zie bijvoorbeeld [Pom96]). De snelste methoden tot nu toe zijn echter nog steeds
exponentieel en daarom kunnen we bij voldoende grote getallen er vanuit gaan dat het lang duurt
om een factorisatie te vinden.

RSA

Bekijk alle getallen a kleiner dan N waarvoor gcd(a; N ) = 1. Deze vormen een groep G omdat:

1. 1 2 G, van elk element in G

2. De inverse modN zit ook in G

3. Voor elke a en b in G, zit ab mod N ook in G.

Een deelverzameling van G die aan dezelfde eisen voldoet heet een subgroep. Neem bijvoorbeeld
de verzameling G = f1; 3; 7; 9; 11; 13; 17; 19g. Dan is G een groep met vermenigvuldiging modulo
20 als groepsoperatie en S = f1; 3; 7; 9g is dan een subgroep. Voor een element a uit een groep
en een subgroep S is de verzameling van alle vermenigvuldigingen van a met een element uit
S een coset. Bijvoorbeeld 11S = f11; 13; 17; 19g. Als s 2 S dan sS (cid:26) S en aangezien sS en
S evenveel elementen hebben is dus sS = S. Dus als aS \ bS 6= ; dan zijn er s en s0 in S
waarvoor as = bs0 en dus a(sS) = b(s0S). Cosets zijn dus disjunct of hetzelfde. In ons geval levert
vermenigvulgiging van S met 1, 3, 7, 9, 11, 17 en 19 respectievelijk de cosets f1; 3; 7; 9g, f3; 9; 1; 7g,

101

f7; 1; 9; 3g, f9; 7; 3; 1g, f11; 13; 17; 19g, f13; 19; 11; 17g, f17; 11; 19; 13g, en f19; 17; 13; 11g op. Omdat
elk element in minstens (cid:19)e(cid:19)en coset zit (vermenigvuldig met 1) krijgen we: De cosets van een subgroep
partitioneren een groep. Met onze eerder gevonden eigenschap: \het aantal elementen in een coset
is gelijk aan het aantal elementen van de subgroep" vinden we dan. Het aantal elementen van een
subgroep moet een deler zijn van het aantal elementen van een groep.

Bijzonder zijn de machten van een element. a; a2; a3; : : :. Er moet gelden an = am voor (cid:19)e(cid:19)en of
andere n > m omdat G eindig is, dus an(cid:0)m = 1. De orde van de subgroep 1; a; a2; : : : ; an(cid:0)m(cid:0)1
moet een deler zijn van jjGjj. Als p een priemgetal is, dan heeft p geen delers gemeen met kleinere
getallen en aangezien p(cid:0) 1 het aantal getallen in de groep is, gelt ap(cid:0)1 = 1 mod p voor alle getallen
kleiner dan p. Dit is bekend als de kleine stelling van Fermat.

RSA encryptie gebruikt deze eigenschap voor twee priemgetallen p en q. Als a geen factoren

gemeen heeft met p of q dan is aq(cid:0)1 niet deelbaar door p en ap(cid:0)1 niet deelbaar door q, dus

en ook

ofwel

Voor elk geheel getal s geldt dan

(aq(cid:0)1)p(cid:0)1 = 1 mod p

(ap(cid:0)1)q(cid:0)1 = 1 mod q

a(p(cid:0)1)(q(cid:0)1) = 1 mod pq:

a1+s(p(cid:0)1)(q(cid:0)1) = a mod pq:

We willen graag vermenigvuldiging modpq gebruiken om te coderen. Stel dat we een c hebben
die geen deler gemeen heeft met (p (cid:0) 1)(q (cid:0) 1), en die dus een element is van de groep G(p(cid:0)1)(q(cid:0)1)
en die dus een inverse heeft in G(p(cid:0)1)(q(cid:0)1). Noem die inverse d, dan is cd = 1(mod(p (cid:0) 1)(q (cid:0) 1))
dus cd = 1 + s(p (cid:0) 1)(q (cid:0) 1), of

acd+s(p(cid:0)1)(q(cid:0)1) = a mod pq:

Dus als ac het gecodeerde bericht is, dan is acd mod n = a het ongecodeerde bericht.

Het recept voor het krijgen van een bruikbaar cryptosysteem is dus.

1. Genereer twee grote priemgetallen p en q. Meestal worden deze random gekozen omdat de
kans een priemgetal te tre(cid:11)en onder de getallen kleiner dan n vrij groot is. Er zijn ongeveer
n= log n priemgetallen kleiner dan n, dus de kans voor een willekeurig getal is al 1= log n,
maar voor speciale getallen als 3 mod 4 is de kans dat je een priemgetal treft nog aanzienlijk
groter.

2. Kies een getal e dat relatief priem is met (p (cid:0) 1)(q (cid:0) 1). Ook hier kun je volstaan met een
random getal waarbij je met de uitgebreide algoritme van Euclides razendsnel kunt testen dat
je inderdaad een getal hebt gevonden dat relatief priem met (p (cid:0) 1)(q (cid:0) 1) is en ook nog een
d kunt vinden die de inverse van e is.

3. Publiceer n en e en gebruik d voor het decoderen.

102

Voorbeeld 4.5.1: Kies twee priemgetallen 3 en 5, dan is n = 3 (cid:2) 5 = 15 en (cid:30)(15) = 2 (cid:2) 4 = 8.
De enige twee getallen kleiner dan 8 die relatief priem zijn met 8 zijn 3 en 5 en die zijn hun eigen
inverse, zoals bijvoorbeeld blijkt uit de uitgebreide euclidische algoritme:

8 = 1 (cid:2) 5 + 3
5 = 1 (cid:2) 3 + 2
3 = 1 (cid:2) 2 + 1

Dus 1 = 3 (cid:0) 2 = 3 (cid:0) (5 (cid:0) 3) = (8 (cid:0) 5) (cid:0) (5 (cid:0) (8 (cid:0) 5)) = 2 (cid:3) 8 (cid:0) 3 (cid:3) 5, waaruit volgt dat (cid:0)3 mod 8
de inverse is mod8 van 5 dus 5 is zijn eigen inverse mod8. Inderdaad, als we bijvoorbeeld 7 willen
versturen, dan is 75 mod 15 = 16807 = 7. Niet elk priemgetal werkt even prettig.
Naarmate de priemgetallen groter worden, krijgen we meer ruimte in de groep, maar worden de
berekeningen ook ingewikkelder. Als bijvoorbeeld p = 7 en q = 11. Dan is (p(cid:0)1)(q(cid:0)1) = 6:10 = 60.
Dan is 7 is een getal met gcd(7; 60) = 1 en 43 (cid:2) 7 = 1 mod 60. Nu is bijvoorbeeld 147 = 42 mod 77
en 4243 = 14 mod 77.

Hier moeten we echter al machten tot 43 verhe(cid:11)en, waardoor onderweg grote getallen kun-
nen ontstaan. Gelukkig kunnen we onderweg ook steeds modpq reduceren waardoor dit probleem
beperkt blijft.

2

4.5.4 Priemgetallen

Voor het testen van de primaliteit van een getal bestaat een polynomiale tijd algoritme [AKS04]
Aangezien de macht van het polynoom nogal groot is (maar dalend) wordt deze algoritme nog niet
veel gebruikt in industri(cid:127)ele toepassingen. In de praktijk is het ook voldoende met redelijke zekerheid
te weten dat de getallen die gebruikt worden voor het RSA systeem priemgetallen zijn. We zullen
daarom alleen kort de meest in gebruik zijnde methode voor het veri(cid:12)(cid:127)eren van de primaliteit van
een getal in deze tekst bespreken. Deze veri(cid:12)catie gaat met behulp van een algoritme die gebruik
maakt van een random generator. De algoritme heeft, als hij gebruikt wordt op een invoer die niet
een priemgetal is, een redelijke kans te ontdekken dat de invoer niet priem is (ongeveer 1/2). Enige
malen herhalen van de algoritme met nieuwe willekeurig getrokken getallen maakt dus de kans dat
de invoer een priemgetal is groter (nauwkeuriger, enige malen herhalen van de algoritme maakt de
kans dat de algoritme niet de uitvoer geen priemgetal zou geven onder de aanname dat de invoer
geen priemgetal is kleiner; natuurlijk is de invoer wel of juist niet een priemgetal en is er geen sprake
van kansen).

De test is gebaseerd op de stelling van Fermat die (toegepast op priemgetallen) zegt.
Stelling 4.5.1 Als n een priemgetal is, dan geldt voor elke b < n dat bn(cid:0)1 = 1 mod n.

De kracht van deze test is dat je kunt bewijzen dat als n geen priemgetal is, dan geldt bn(cid:0)1 = 1
mod n voor hoogstens de helft van de getallen kleiner dan n. Dit bewijs geven we hier niet, maar
kan op veel plaatsen gevonden worden in standaard tekstboeken.

De deterministische algoritme voor primaliteitstest, waarover we het boven hadden, maakt naast

de stelling van Fermat nog gebruik van een eigenschap van binomiaalcoe(cid:14)cienten

103

k

(cid:0)n
p dan n, dus dan valt n uit de teller van de breuk in(cid:0)n
zijn dan n is n ook geen deler meer van(cid:0)n

(cid:1) = 0 voor alle k < n dan en slechts dan als n een priemgetal is. Immers, als n een priemgetal
(cid:1) dus deelbaar door n en
(cid:1) en, aangezien alle andere factoren kleiner
(cid:1) 6= 0 mod n. We kunnen deze eigenschap dus als

is en n! = n(n(cid:0)1):::(n(cid:0)k+1)
dus gelijk aan 0 mod n. Aan de andere kant, als n geen priemgetal is, dan heeft n een deler kleiner

, dan heeft k! geen factoren van n en dan is(cid:0)n

(cid:1) of(cid:0)n

k!

k

p

De oplossing voor dit probleem, bedacht door Agrawal et al.,

primaliteitstest gebruiken, ware het niet dat dit tot een exponenti(cid:127)ele algoritme leidt.
is dat de equivalentie voor
priemgetallen nog iets verder gaat. Er geld namelijk dat (x (cid:0) a)n = (xn (cid:0) a)(modn; xr (cid:0) 1) of
(x (cid:0) a)n (cid:0) (xn (cid:0) a) = nf + (xr (cid:0) 1)g voor polynomen f en g. Agrawal et al. bewezen ook in hun
paper dat r niet groter is dan log5 n.

p

p

De volgende algoritme bewijst dan de primaliteit van een getal (of zijn samengesteldheid).

1: input n
2: Kijk of n = ab voor gehele a en b, zo ja samengesteld
3: Zoek de kleinste r met orde tenminste log2 n
4: if 1 < ggd(a; n) < n voor zekere a (cid:20) r then samengesteld
5: end if
6: if n (cid:20) r then priem
7: end if

8: for a = 1 ; a < bp(cid:30)(r) log nc do

if (X + a)n 6= X n + 1 mod (X r (cid:0) 1; n) then samengesteld
end if

9:
10:
11: end for
12: priem

We roepen in herinnering dat de orde van een getal r modulo n de kleinste macht s is zodat
In regel 2 hoeven maar een paar a’s en b’s te worden getest (b (cid:20) log n en de
p
rs = 1 mod n.
vraag of a = b
n voor (cid:19)e(cid:19)en of andere a kan met binary search snel worden beantwoord). Zoals eerder
opgemerkt, kan bewezen worden dat r klein is in de lengte van n, zodat regel 6 alleen van toepassing
is op kleine waarden van n.

4.5.5

sommen

1. Op veel plaatsen (bijvoorbeeld www.prime-numbers.org) kunnen integers van beperkte grootte
gevonden worden die priem zijn, en tevens kunnen zelf ingevoerde getallen op priemaliteit
worden getest. Schrijf een programma dat een random getal trekt dat met grote kans priem
is, en test het vervolgens op zo’n site. (Getallen van de vorm 3 mod 4 zijn vaak priem.) Test
het vervolgens met behulp van Fermat’s stelling een paar keer).

2. Genereer nog een priemgetal als in de vorige opgave en gebruik deze priemgetallen om een

RSA systeem op te zetten.

4.6 Beveiliging van gegevens

Cryptogra(cid:12)sche methoden kunnen gebruikt worden voor verschillende vormen van gegevensbevei-
liging. Computers zijn tegenwoordig vaak via netwerken met elkaar verbonden en wisselen over

104

die netwerken gegevens met elkaar uit. Niet elk pakketje data dat door computers wordt uitge-
wisseld moet door iedereen die toevallig ook op die lijn aanwezig is kunnen worden gelezen, en als
we een pakketje data ontvangen van een computer, dan willen we graag weten van welke computer
dat pakketje afkomstig is. We kunnen de computer aan de andere kant van de lijn niet zien dus
zouden we graag enige vorm van identi(cid:12)catie verlangen voordat we bijvoorbeeld een opdracht van
die computer aanvaarden. Een derde vorm is nog commitment. Stel bijvoorbeeld dat de computer
van een beleggingsmaatschappij een aandelenhandelaar opdracht geeft groot in te kopen in een
bepaald bedrijf. Vervolgens gaat het slecht met dat bedrijf en de aandelen kelderen. De beleggings-
maatschappij zou nu kunnen beweren dat de opdracht nooit verstuurd is en dat de handelaar deze
opdracht zelf verzonnen heeft.

Cryptogra(cid:12)sche methoden, in het bijzonder de public key cryptosystems, bieden voor al deze
problemen een oplossing en we zullen hier schetsen hoe deze oplossingen werken. Het beveiligen
van data tegen ongewild lezen door derden is de standaardtoepassing, dus zullen we dat onderwerp
niet nogmaals behandelen.

4.6.1

Identi(cid:12)catie

Als we een opdracht van persoon P krijgen om uit te voeren, zouden we graag willen vaststellen
dat de persoon P inderdaad is wie ze zegt te zijn. De opdracht zelf zal gecodeerd zijn met onze
eigen publiek gemaakte sleutel cm, dus deze zullen we kunnen decoderen met onze eigen, geheim
gehouden, sleutel dm. Hoe weten we dat de boodschap afkomstig is van P ?

P heeft, net als alle andere deelnemers, in het publieke domein een sleutel cp gedeponeerd, of
deze sleutel is daar gezet door een vertrouwde derde partij. Verder heeft P haar eigen geheime
decodeersleutel dp. De identi(cid:12)catie van de boodschap M wordt nu bereikt met het omgekeerde
coderingsproces. P verstuurt de boodschap (P )dp als onderdeel van M . P dp kan nu worden gelezen
met behulp van de codeersleutel van P , die publiek is ((P dp )cp = P ). Niemand anders had deze
boodschap kunnen versturen zonder kennis van dp

4.6.2 Commitment

Een soortgelijk schema kan worden gebruikt voor commitment. De boodschap M =
Koop 5000
"
aandelen" kan worden gecodeerd met de publieke sleutel cp maar ook ondertekend met de hierboven-
beschreven identi(cid:12)catieprocedure. Aangezien de identi(cid:12)catie uniek is kan de gecodeerde boodschap
ook dienen als bewijs dat de boodschap verzonden is. De ontvanger kan immers niet zelf de identi-
(cid:12)catie geproduceerd hebben.

4.6.3

sommen

1. Gebruik het RSA systeem uit som 2 om een document van een handtekening te voorzien.

105

106

Deel II

Complexiteitstheorie

107

In dit deel van de tekst abstraheren we van speci(cid:12)eke algoritmen voor problemen en kijken naar
de complexiteit van de problemen zelf. Om uitspraken te doen over alle mogelijke algoritmen die
voor een probleem kunnen bestaan, en de complexiteit daarvan hebben we een eenvoudig maar
generiek toepasbaar model voor berekening nodig. Hiervan zijn diverse voorbeelden voorhanden,
die allemaal modulo de juiste overhead uitwisselbaar zijn. Vervolgens kunnen we problemen onder-
verdelen in complexiteitsklassen. De klasse NP en de volledige problemen in die klasse spelen in
dit deel een speciale rol.

109

110

Hoofdstuk 5

Modellen voor Berekening

In het eerste deel van deze tekst hebben we een informeel model voor berekening gebruikt. We
hebben de complexiteit van algoritmen opgehangen aan zogenoemde spil-operaties (pagina 17) die
niet nader genoemde kosten hadden, maar waarvan we aannamen dat ze op een andere computer
ook konden worden uitgevoerd voor kosten die niet meer dan een constante keer zo groot zijn,
waarbij de aanname dan ook nog was dat die constante beperkt zou zijn. In dit deel van de tekst
zullen we wat preciezer worden over het model dat we voor de berekening gebruiken, omdat we het
hier over problemen hebben en bewijzen willen gaan geven die voor alle algoritmen gelden die bij
die problemen horen. In het bijzonder willen we van problemen graag bewijzen dat er geen e(cid:14)ci(cid:127)ente
algoritmen voor bestaan. Natuurlijk mag zo’n bewijs nooit afhangen van de speci(cid:12)eke computer
waarop zo’n algoritme wordt uitgevoerd. We zullen dus in het bijzonder een probleem als ondoenlijk
classi(cid:12)ceren als er geen e(cid:14)ci(cid:127)ente algoritme bestaat voor dit probleem op een redelijk machinemodel.
Voor e(cid:14)(cid:127)ente algoritmen hebben we in het eerste deel al betoogd, dat deze klasse beperkt is tot
de algoritmen waarvan de tijdgrenzen beperkt zijn tot polynomen. In ieder geval houden we vast
dat een algoritme waarvan de rekentijd niet begrensd is door een polynoom niet e(cid:14)ci(cid:127)ent is. In het
kader van de machinemodellen zullen we naar analogie een klasse van machinemodellen aanwijzen
die elkaar kunnen simuleren in polynomiaal begrensde tijd. Dat wil zeggen dat wat op de ene
machine in n stappen kan worden uitgevoerd, kan op de andere machine in p(n) stappen worden
uitgevoerd voor p een polynoom van bij voorkeur lage graad. Als een machine bijvoorbeeld in
log n stappen kan doen wat onze machine in n stappen doet, dan zullen we die machine niet
zien als een redelijke machine. De uitspraak
alle redelijke machinemodellen simuleren elkaar in
"
polynomiale tijd begrensde overhead en constante factor overhead in ruimte" staat bekend als
de sequential computation thesis. Omdat dit nogal wat ruimte inneemt zullen we deze uitspraak
voortaan aanduiden met

redelijkheidsaanname".
"

5.1 Redelijke Machinemodellen

Er zijn talloze voorbeelden van redelijke machinemodellen. Twee hiervan zullen we in dit hoofdstuk
bespreken. De Random Acces Machine en de Turing Machine.

111

5.1.1 De Random Access Machine

Een in veel boeken gebruikt model voor berekening is de Random Access Machine, omdat het model
veel lijkt op in de praktijk nog steeds gebruikte machines. De Random Access Machine (Figuur 5.1)
bestaat uit een centrale verwerkingseenheid, de processor, aangevuld met een onbegrensd geheugen
dat bestaat uit een onbegrensd aantal registers. In elk register kan een natuurlijk getal worden op-
geslagen. De Random Access Machine heeft een programma bestaande uit genummerde instructies.
De machine begint altijd met het uitvoeren van instructie nummer 1 en stopt als zij de instructie
HALT tegenkomt. Verder heeft zij de volgende set instructies.

Figuur 5.1: Random Access Machine

LOAD i : Haal wat er in register i zit op en sla dat op in de processor

STORE i : Stop wat er in de processor staat in register i.

ADD i : Tel wat er in de processor staat op bij wat er in het register i staat en sla dat op in de

processor.

processor.

SUB i : Trek wat er in register i staat af van wat er in de processor staat en sla dat op in de

JUMP a : Spring naar opdrachtregel a.

JGTZ a : Als wat er in de processor staat groter is dan 0 spring naar opdrachtregel a, ga anders

door met de volgende opdrachtregel.

Verder kunnen alle getallen in het programma worden voorafgegaan door een (cid:3) wat een indirectie
inhoudt. Dat betekent dat niet dat getal moet worden gebruikt maar de inhoud van het register dat
door dat getal wordt aangeduid. Bijvoorbeeld JGT Z (cid:3) 0 betekent, als de inhoud van de processor
groter dan 0 is, dan spring je naar de opdrachtregel die het nummer draagt van het getal dat in
register 0 is opgeslagen. Ook kunnen direct getallen in de processor worden geladen door het getal

112

vooraf te laten gaan door een #. Dus LOAD #20 betekent dan \stop 20 in de processor". Om
het model compleet te maken zal de Random Access Machine niet alleen stoppen als de instructie
HALT bereikt wordt, maar ook als er een onzinnige opdracht verwerkt moet worden, bijvoorbeeld
het springen naar een opdrachtregel die niet bestaat of het a(cid:13)agen van een register waar al 0 in
staat. Dit is de zogenoemde CRASH opdracht.

Een maat voor de tijd die door een Random Access Machine wordt besteed aan het uitvoeren van
een programma is de opdrachtregel. Elke uitvoering van een opdrachtregel is (cid:19)e(cid:19)en stap. In sommige
gevallen wordt ook de lengte van de operanden van ADD en SUB instructies geteld, omdat in
een register nu eenmaal een willekeurig groot getal staat en in een realistisch machinemodel niet
willekeurig grote getallen in (cid:19)e(cid:19)en stap bij elkaar kunnen worden opgeteld.

Tijd

Geheugen

Een maat voor het gebruikte geheugen van een Random Access Machine is de hoeveelheid gebruikte
registers. Aan het begin van de berekening is de inhoud van elke register 0 als er een getal in zo’n
register wordt geschreven, dan telt vanaf dat moment het register mee in de hoeveelheid gebruikt
geheugen. In sommmige gevallen wordt ook de som van de logaritmen van de inhouden van de
registers die niet nul zijn geteld als geheugen. Dit is om rekening te houden met het feit dat in een
register een willekeurig natuurlijk getal kan worden opgeslagen.

5.1.2 De Turing Machine

E(cid:19)en van de eerste modellen voor berekenbaarheid is de Turing machine, voor de eerste keer gepresen-
teerd in het artikel
On computable numbers, with an application to the Entscheidungsproblem."
"
door Alan M. Turing in 1936 [Tur36]. V(cid:19)o(cid:19)or de presentatie van het Turing machine model was
de vraag wat precies een algoritme of algoritmische bewerking is een centraal onderwerp van dis-
cussie. Het verschil tussen algoritmisch en niet algoritmisch denken is onderwerp van (cid:12)loso(cid:12)sch
debat. Turing ging uit van de volgende vooronderstelling. Zie de wiskundige als een automaat die
een vel ruitjespapier tot zijn beschikking heeft. Het ruitjespapier is in vier richtingen onbegrensd,
maar de wiskundige kan slechts een beperkt aantal ruitjes (zeg (cid:19)e(cid:19)en) tegelijkertijd lezen. Als zij een
ruitje gelezen heeft, kan zij dat onthouden, een nieuwe waarde in het zojuist gelezen ruitje schrijven
en naar een andere plaats op het papier bewegen. Het aantal waarden dat zij kan onthouden is
begrensd door (cid:19)e(cid:19)en of andere constante.

Tegenwoordig wordt het ruitjespapier vervangen door een tweezijdig onbegrensde band (zie Fi-
guur 5.2). In elke cel van de band kan per bezoek (cid:19)e(cid:19)en symbool geschreven worden en het onthouden
van een symbool wordt gekarakterizeerd doordat de machine (wiskundige) in een begrensd aantal
toestanden kan zijn. Het programma dat de machine uitvoert is dan steeds:
Als in toestand p
"
symbool a gelezen wordt, dan komt de machine in toestand q, schrijft symbool b en beweegt naar
links of naar rechts." Het programma eindigt als er een combinatie gelezen symbool/toestand actu-
eel is waarvoor geen opvolger in het programma staat, ofwel het gaat net zolang door tot het niet
meer verder kan.

113

Figuur 5.2: Het standaard Turing machinemodel

Representaties

Formeel bestaat het Turing machine model uit:

1. Een eindige verzameling toestanden Q. Een speciale toestand q0 2 Q is aangemerkt als de

begintoestand .

B.

2. Een eindige verzameling bandsymbolen (cid:6) deze verzameling omvat altijd het blanco symbool

3. Een toestandsovergangsfunctie (cid:14) : Q (cid:2) (cid:6) 7! Q (cid:2) (cid:6) (cid:2) fL; R;;g

Bij aanvang van de berekening bevat de band een aaneengesloten eindige rij niet blanco symbolen en
staat het eerste symbool van links op de posititie waar zich de tapekop bevindt. In sommige gevallen
wordt de Turing machine nog uitgebreid door een aantal van de toestanden
eindtoestanden" te
"
noemen en af te spreken dat de Turingmachine stopt als zij in (cid:19)e(cid:19)en van deze eindtoestanden komt.
Dit is echter niet noodzakelijk.

Voorbeeld 5.1.1: Er zijn verschillende manieren om een Turingmachine te representeren, we zullen
dit aan de hand van drietal voorbeelden laten zien waarbij in elk voorbeeld het programma gebruikt
wordt dat bij zijn invoer die uit 0 en 1 bestaat 1 optelt. Aangezien de kop wegens aanname op het
eerste niet blanco symbool van links staat, moet zij eerst naar rechts tot het einde van de invoer
lopen om aan die kant te proberen 1 bij de invoer op te tellen. De Turingmachine begint links op
de band bij het eerste symbool. Dat is een 1 of een B. Als het een B is, dan schrijft zij een 1 en
stopt. In het andere geval gaat de machine over in toestand q1 en beweegt naar rechts. In toestand
q1 beweegt de Turingmachine net zo lang naar rechts totdat een B wordt gelezen. Dan keert de
machine om en komt in toestand q2. In toestand q2 wordt elke 1 onder de kop veranderd in een 0.
De (cid:19)e(cid:19)erste 0 of B die tegengekomen wordt, verandert in een 1, waarna de machine stopt.

1. Allereerst kunnen we natuurlijk de Turing machine representeren door de toestandsovergangs-

114

functie expliciet te geven. Dat ziet er als volgt uit.

2. Een andere veelgebruikte manier is het schrijven van de toestanden en de symbolen in een

tabel, waarbij de opdrachten de entries van de tabel zijn.

3. Tenslotte is er nog de gra(cid:12)sche manier van representeren.

(cid:14)(q0; 1) = hq1; 1; Ri
(cid:14)(q0; B) = hqF ; 1; Ri
(cid:14)(q1; 0) = hq1; 0; Ri
(cid:14)(q1; 1) = hq1; 1; Ri
(cid:14)(q1; B) = hq2; B; Li
(cid:14)(q2; 0) = hqF ; 1; Li
(cid:14)(q2; 1) = hq2; 0; Li
(cid:14)(q2; B) = hqF ; 1; Li

0
(cid:0)

1

B

q0
q1
q2

q1; 1; R qF ; 1; R
q1; 1; R q1; 0; L q2; B; L
qF ; 1; L q2; 0; L qF ; 1; L

X=X=R;X2f0;1g

1=1=R

q0

qF

B=1=R
X=1=R;X2f0;Bg

0=1=R

q1

q2

1=0=L

Al deze methoden zijn equivalent en komen in de literatuur ongeveer even vaak voor.

2

Een paar variaties van Turingmachines

In het hieronderstaande stuk over de simulatie van een Turingmachine op een RAM zullen we gaan
beschrijven hoe een Turingmachine met een (cid:19)e(cid:19)enzijdig oneindige band op een RAM kan worden
gesimuleerd. We hebben echter juist hierboven afgesproken dat de Turingmachineband tweezijdig
oneindig is. Gelukkig is het Turingmachinemodel een zeer vergevingsgezind model wat betreft
wijzigingen in de standaard. De vele bekende variaties hebben allemaal de eigenschap dat ze elkaars
berekeningen e(cid:14)cient kunnen simuleren. We bespreken er enkele, waaronder de tweezijdige band
op een (cid:19)e(cid:19)enzijdige band. We stellen twee Turingmachines M1 en M2 in de onderstaande paragraphen
voor. Hier is telkens M1 de Turingmachine waarvan een berekening op M2 gesimuleerd gaat worden.

Meer tracks op (cid:19)e(cid:19)en tape Als voorbeeld nemen we een tape die uit twee sporen bestaat, een
bovenspoor en een onderspoor. De toestandsovergang is nog steeds afhankelijk van de bandinhoud,
maar nu worden twee symbolen gelezen en geschreven. Het is duidelijk dat elke berekening die op een

115

/
/
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:11)
(cid:11)
o
o
i
i
turingmachine met een (cid:19)e(cid:19)entracksband kan worden uitgevoerd in dezelfde hoeveelheid stappen ook
op een Turingmachine met een tweetracksband kan worden uitgevoerd. De simulerende machine
zal immers slechts (cid:19)e(cid:19)en van beide tracks gebruiken. De omgekeerde bewering is ook waar. De
tweetracks Turingmachine heeft een bepaald bandalfabet (cid:6). Gegeven M1 bouwen we een (cid:19)e(cid:19)entracks
Turingmachine M2 met een groter (maar nog steeds eindig) bandalfabet (cid:0), zo dat (cid:0) precies (j(cid:6)j (cid:2)
j(cid:6)j + 1=2), voor elk paar uit (cid:6) (cid:2) (cid:6) (cid:19)e(cid:19)en. We hebben nu een codering voor elk paar symbolen uit
(cid:6) (cid:2) (cid:6), en kunnen deze code gebruiken om het programma van M1 te vertalen.

E(cid:19)enzijdig oneindige band Nu we hebben vastgesteld dat meerdere tracks op een band op (cid:19)e(cid:19)en
band gesimuleerd kunnen worden kunnen we dit gebruiken om een tweezijdig oneindige band op
een (cid:19)e(cid:19)enzijdige band te simuleren. Hiertoe markeren we het begin van de band met een speciaal
teken en gebruiken we verder een (cid:19)e(cid:19)enzijdig oneindige band met twee sporen. Deze tapecel zal in de
simulatie niet worden gebruikt, maar alleen worden gebruikt om te zien of in de simulatie van de
berekening van M1 de tapekop van M1 zich links of rechts van een speciaal aangewezen cel, die we
de oorsprong" zullen noemen bevindt. Het bovenste spoor stelt de linkerkant van de tweezijdig
"
oneindige band voor terwijl het onderste spoor de rechterkant van de tweezijdig oneindige band
voorstelt. De toestandsverzameling van M2 is twee keer zo groot als die van M1 om aan te geven
of de machine links van de oorsprong of rechts van de oorsprong is. Aan (cid:19)e(cid:19)en van beide kanten
van de oorsprong (bijvoorbeeld rechts) beweegt M2 zich hetzelfde als M1 en leest en schrijft het
onderste spoort. Als M1 door de oorsprong naar de linkerkant gaat, dan beweegt M2 zich steeds
in tegengestelde richting en leest en schrijft het bovenste spoor. Zo voeren ze in essentie dezelfde
berekening uit.

Meer koppen op een band Een machine met meerdere koppen op een band kan meerdere
symbolen tegelijkertijd lezen en interpreteren. Vervolgens kunnen de koppen meerdere symbolen
in (cid:19)e(cid:19)en stap schrijven en de koppen kunnen tegelijkertijd een beweging naar links en naar rechts
uitvoeren. Om dit te simuleren rusten we M2 uit met een band met twee sporen. In het onderste
spoor houden we de symbolen van M1 bij en in het bovenste spoor zetten we een speciaal symbool,
(cid:3), als we willen aangeven dat (cid:19)e(cid:19)en van de gesimuleerde koppen zich op die plaats op de band bevindt.
Nu bestaat de simulatie van (cid:19)e(cid:19)en berekeningsstap op M1 uit een veeg van links naar rechts totdat
alle informatie over symbolen die onder de gesimuleerde koppen verzameld is. Vervolgens komt
een tweede update veeg, waarbij de markers((cid:3)) naar links of naar rechts geplaatst worden en de
symbolen die onder de markers stonden vervangen worden door nieuwe.

Om te laten zien dat deze simulatie e(cid:14)ci(cid:127)ent is, merken we op dat de koppen van M1 per stap
niet meer dan 2 cellen verder uit elkaar kunnen komen ((cid:19)e(cid:19)en kop beweegt naar links en de andere
naar rechts), en dus in n stappen niet verder dan 2n uit elkaar kunnen komen. Elke veeg kost dus
O(n) stappen op M2 (Misschien is er wat locaal heen en weer geschuif nodig om de markers te
updaten). Gevolg is dat simulatie van n stappen op M1 niet meer dan O(n2) stappen op M2 kan
kosten.

Meer banden De simulatie van meer banden op 1 band is eigenlijk dezelfde als die van meer
koppen met 1 kop. Voor k banden nemen we 2k sporen en zetten op de oneven sporen (van onderen
af) de symbolen van M1, terwijl we op de even sporen markers zetten voor de plaats van de koppen.
Een paar vegen zorgt, net als in het vorige geval, voor de update van de informatie. Net als in het
vorige geval is de ruimte die een veeg moet overbruggen ook weer begrensd door O(n), dus kost de
simulatie van n stappen ook hier niet meer dan O(n2).

116

91

90

89

88

87

86

85

84

83

82

92

57

56

55

54

53

52

51

50

81

93

58

31

30

29

28

27

26

49

81

94

59

32

13

12

11

10

25

48

79

95

60

33

14

24

47

78

96

61

34

15

23

46

77

97

62

35

16

22

45

76

3

4

5

2

1

6

9

8

7

98

63

36

17

18

19

20

21

44

75

99

64

37

38

39

40

41

42

43

74

65

66

67

68

69

70

71

72

73

Figuur 5.3: De spiraalmethode voor de tweedimensionale band

v

e

r

o

e

o

s

e

c

c

u

s

a

m u

s

u

s

t

o

o

i

"

d

a

t

e

t

"

a

t

i

"

Figuur 5.4: veel banden op (cid:19)e(cid:19)en band

117

Tweedimensionale band De tweedimensionale band laat zich op de 1 dimensionale band simule-
ren door een handige nummering van de cellen van het platte vlak. Er zijn verschillende oplossingen
voor het probleem denkbaar.

1. We kunnen voor elke cel op M2 een aantal aangrenzende cellen reserveren waarin we de
coordinaten van deze cel in de band van M1 bijhouden. Aangezien deze coordinaten op M1
niet meer dan met 1 per stap kunnen groeien volgt dat deze coordinaten in n stappen niet
meer dan log n tapecellen in beslag kunnen nemen, dus dat de tape van M1 niet meer dan
n log n groot zal zijn. Bijgevolg kost de update per stap niet meer dan n log n. De simulatie
van n stappen kan dus in O(n2 log n).

2. We kunnen een spiraalmethode voor de nummering van de cellen in het platte vlak bijhouden.

3. We kunnen het platte vlak onderverdeeld denken in stroken. Zo houden we een vierkant bij
op de band van M2 waarin de simulatie zich afspeelt. Telkens wanneer M1 zich buiten het
vierkant begeeft, worden alle stroken met 1 cel uitgebreid.

5.1.3 Simulaties tussen RAMS en Turingmachines

Turingmachines en RAMs kunnen elkaars berekeningen uitvoeren, waarbij de overhead zowel in tijd
als in geheugen begrensd is.

Een Turingmachineberekening op een RAM

Bij de simulatie van een Turingmachineberekening op een RAM maken we gebruik van de indirecte
adresseermogelijkheid van de RAM. De machine die we simuleren is een (cid:19)e(cid:19)enbands Turingmachine
met een halfoneindige band. De inhoud van de cellen van de Turingmachine slaan we op in registers
1; 2; : : :, en in register 0 houden we een getal bij dat de positie van de kop betekent. Een beweging van
de Turingmachine naar rechts simuleren we door de inhoud van register 0 met 1 te verhogen, en een
beweging naar links door de inhoud van het register met 1 te verlagen. De bandalfabetsymbolen
worden 1 op 1 afgebeeld naar natuurlijke getallen. Het schrijven van een nieuw bandsymbool
onder de kop kan gebeuren door een STORE (cid:3)0 instructie en het lezen van een bandsymbool
door een LOAD (cid:3)0 instructie. Verder worden toestandsovergangen gesimuleerd door kleine stukjes
programma van de volgende vorm:

(cid:3)0
Qi0
1
Qi1
1
Qi2

LOAD
JZERO
SUB
JZERO
SUB
JZERO
: : :
SUB

q :
q + 1
q + 2 :
q + 3 :
q + 4 :
q + 5 :
q + :: :
q + 2k (cid:0) 1 :
q + 2k :
q + 2k + 1 :

1
JZERO Qik(cid:0)1
JUMP
Qik

Als het register geladen wordt, dan bevindt tenminste (cid:19)e(cid:19)en van de k symbolen uit het bandal-
fabet (inclusief het blanco symbool, dat wordt gesymboliseerd door de 0, eerste instructie) zich in
het register. Door het register telkens af te lagen en naar de juiste plaats in het programma te
springen als de inhoud 0 geworden is, kunnen we een stap van de Turingmachine simuleren. Op de

118

overeenkomstige plaats in het RAM programma wordt vervolgens de juiste waarde met indirecte
adressering in het juiste register opgeslagen en wordt tapekop beweging gesimuleerd door register 0
aan te passen. De simulatie van een stap van de Turingmachine kost een constant aantal stappen op
de RAM (begrensd door de grootte van het bandalfabet), derhalve kan de simulatie van n stappen
van de Turingmachine in O(n) stappen op de RAM gedaan worden.

Een RAM berekening op een Turingmachine

Bij de simulatie van de RAM op de Turingmachine, moeten we de inhoud van de registers, van
de RAM opslaan op de band van de Turingmachine. We gebruiken een driebands Turingma-
chine voor de simulatie. Op de eerste band houden we de inhoud van de registers bij in de vorm
##b1b2 : : : bn#bn+1 : : : bm##, waarbij de eerste serie bits een binaire representatie is van het regis-
teradres, en het tweede adres de inhoud van het register voorstelt. Een LOAD instructie is nu het
kopi(cid:127)eren van een gedeelte van de inhoud van band 1 naar band 2, een STORE instructie het om-
gekeerde, waarbij het opzoeken van het juiste adres met een bit voor bit vergelijking kan gebeuren.
De diverse vormen van JUMPs houden een toestandsverandering in, de Turingmachine gaat naar
het overeenkomstige deel van zijn programma. ADD en SUB kunnen op een Turingmachine worden
uitgevoerd, hiervoor is een implementatie van de overeenkomstige algoritme in Turingmachinecode
noodzakelijk, maar dit kan lineair in het aantal bits van de inhoud van het register. De duurste
operatie heeft plaats wanneer aan een register een extra bit moet worden toegevoegd. De rest
van de band moet dan worden opgeschoven. Omdat we een extra band daarvoor hebben, kan dit
gebeuren met een aantal bewerkingen dat begrensd wordt door de lengte van de band, het totaal
aantal cellen dat in gebruik is. Om hier een afschatting van te krijgen bedenken we het volgende.
Het aantal registers dat in gebruik is, is natuurlijk begrensd door het aantal stappen dat gesimu-
leerd moet worden. De inhoud van de registers wordt begrensd doordat in elke stap ten hoogste de
inhoud van twee registers bij elkaar opgeteld kan worden. Aan het begin van het programma zijn
de enige aanwezige getallen de getallen die in het programma zijn opgeschreven het grootste getal
is daardoor begrensd door (cid:19)e(cid:19)en of andere constante c. In n stappen is dus het grootste getal dat we
kunnen maken cn. Dit getal kan in O(n) bits gerepresenteerd worden.

Het gevolg is dat de duurste operatie, het opschuiven van de band, O(n) stappen op de Turing-
machine kost. Bijgevolg kunnen n operaties van de RAM in O(n2) stappen op de Turingmachine
worden gesimuleerd.

5.2 Onredelijke Machinemodellen

Dat we een klasse van redelijke machinemodellen invoeren, doet vermoeden dat er ook een klasse
van onredelijke machinemodellen bestaat. We zullen enige aandacht hieraan besteden, hoewel deze
modellen niet in deze tekst centraal staan.

5.2.1 Onbegrensd Parallellisme

De eerste klasse van onredelijke machinemodellen is die van de machines met onbegrensd parallel-
lisme. De hoeveelheid hardware in het universum is begrensd en het zou redelijk zijn te vooron-
derstellen dat we in polynomiaal begrensde tijd slechts polynomiaal veel hardware aan het werk
kunnen zetten. Dat ligt echter niet in het standaardmodel opgesloten. Als we beschikken over een
onbegrensd aantal processoren, dan zou je je een berekening kunnen voorstellen die begint met een

119

processor 0 die twee andere processoren aan het werk zet, in de tweede stap van de berekening zet-
ten die twee andere processoren dan elk weer twee nieuwe processoren aan het werk enzovoort. In
polynomiaal veel tijd kun je dan exponentieel veel processoren aan het werk hebben. Een Random
Access Machine met deze eigenschap wordt Parallel RAM (PRAM) genoemd. In het PRAM model
hebben alle processoren toegang tot hetzelfde werkgeheugen (de registers) en kunnen ze dus in die
registers waarden aan elkaar doorgeven. Zo kunnen exponentieel veel processoren tegelijkertijd aan
hetzelfde probleem gezet worden.

Verderop in 7.1 zullen we een klasse van problemen invoeren waarvan het onwaarschijnlijk
is dat ze in redelijke (polynomiale) tijd op een redelijk machinemodel kunnen worden berekend.
Standaardprobleem in deze klasse is de klasse van ware boolese formules met kwantoren, QBF.
De problemen in deze klasse bestaan uit proposities F (x1; : : : ; xn) voorafgegaan door afwisselende
kwantoren 9 en 8. De vraag is voor een gegeven formule Q1x1Q2x2 : : : QnxnF (x1; : : : ; xn) of zij
waar is of niet. Een PRAM kan zoiets gemakkelijk uitrekenen. Neem voor het gemak even aan
dat Qi = 9 als i even is en Qi = 8 als i oneven is. Het programma van processor Pi doet dan het
volgende:

1. Als 2n (cid:20) i (cid:20) 2n+1 dan beschouwt Pi de laatste n bits van zijn index als n binaire waarheids-
waarden voor x1; : : : ; xn. Die vult zij in in F (x1; : : : ; xn) en ziet of deze toewijzing F waar
maakt. Is dat het geval dan schrijft zij een 1 in register i, en anders een 0.

2. Als i < 2n, dan schrijft Pi de waarde (cid:0)1 in registers P2i en P2i+1 en start Pi de processoren
P2i en P2i+1 vervolgens leest zij elke stap registers P2i en P2i+1 uit totdat daar 0 of 1 in staat.
De machine start doordat P1 deze actie uitvoert.

3. Als i een oneven getal is dan schrijft Pi een 1 in register i als registers 2i en 2i + 1 allebei een
1 krijgen, anders 0. Als i een even getal is, dan schrijft Pi een 1 in register i als tenminste
(cid:19)e(cid:19)en van 2i en 2(i + 1) een (cid:19)e(cid:19)en krijgen. Dwz Pi berekent dus de 8 resp de 9 van de waarden
van P2i en P2i+1

De PRAM berekent zo de waarde van een QBF uit en gebruikt daarvoor ongeveer O(n) stappen.

5.2.2 Oneerlijk tellen

Van Random Access Machines hebben we gezegd dat in elke cel van het geheugen een willekeurig
natuurlijk getal kan worden opgeslagen. Aangezien er oneindig veel natuurlijke getallen bestaan is
het natuurlijk onredelijk om aan te nemen dat hele grote natuurlijke getallen in (cid:19)e(cid:19)en geheugencel
kunnen worden opgeslagen.
In een bandcel van een Turingmachine kan immers maar (cid:19)e(cid:19)en enkel
symbool worden opgeslagen. Omdat in een polynomiaal aantal stappen niet al te grote getallen
kunnen worden gemaakt door een RAM, is het niettemin mogelijk de berekeningen van een polyno-
miale tijd begrensde RAM op een polynomiale tijd begrensde Turing machine te simuleren, zoals we
hebben gezien in 5.1.3. Dat komt omdat een enkele optelling niet veel meer kan doen dan een getal
verdubbelen, en verdubbelen van een getal geeft slechts (cid:19)e(cid:19)en extra bit over een binair bandalfabet.
Anders wordt de situatie als we de RAM ook laten vermenigvuldigen en voor de vermenig-
vuldiging van willekeurig grote getallen slechts (cid:19)e(cid:19)en operatie in rekening brengen. Dan kunnen de
aanwezige getallen met elkaar vermenigvuldigd worden en kan in n stappen het getal 22n
gemaakt
worden. Dit getal neemt exponenti(cid:127)ele ruimte in als het gerepresenteerd moet worden op een Tu-
ringmachineband en derhalve kan RAM die in (cid:19)e(cid:19)en stap vermenigvuldigingen van willekeurig grote

120

getallen kan uitvoeren niet in polynomiale tijd door een Turing machine worden gesimuleerd. Dit
model van Random Access Machine noemen we Multiplication RAM of ook wel MRAM.

Net als bij de PRAM wordt kan van de MRAM worden aangetoond dat deze een berekening
van een machine die mogelijk veel krachtiger is dan de polynomiale tijd begrensde Turing machine
kan simuleren in polynomiale tijd. Het gaat om de polynomiaal geheugen begrensde machine.
Een Turing machine heeft een accepterende berekening als de initi(cid:127)ele con(cid:12)guratie bij een bepaalde
invoer in minder dan exponentieel veel stappen een accepterende con(cid:12)guratie kan bereiken. Dit
kan worden aangetoond door alle con(cid:12)guraties in een matrix te schrijven en te laten zien dat deze
matrix wanneer hij ongeveer exponentieel vaak met zichzelf vermenigvuldigd wordt een 1 krijgt
op de plaats die het pad van de begincon(cid:12)guratie naar de accepterende con(cid:12)guratie aangeeft.
Een MRAM kan zo’n matrixvermenigvuldiging in (cid:19)e(cid:19)en stap doen. Omdat niet alle tussenliggende
matrices hoeven te worden berekend|telkens de gevonden matrix kwadrateren is voldoende|
hoeven er niet exponentieel veel vermenigvuldigingen gedaan worden (de matrix moet nog wel
als (cid:19)e(cid:19)en getal in een register worden voorgesteld, en matrixvermenigvuldiging moet nog worden
aangepast, maar dat zijn details), maar slechts polynomiaal veel. Details van dit bewijs zijn, zoals
de lezer zich misschien kan voorstellen, behoorlijk ingewikkeld (zie [HS76]).

Voor zowel de MRAM als de PRAM is het onbekend of er ook werkelijk een probleem is dat door
een MRAM kan worden opgelost (taal die kan worden herkend) dat niet in polynomiale tijd door
een Turing machine kan worden opgelost. Immers, voor een vermenigvuldiging kan een recursieve
procedure worden opgeschreven waarvan de te bewerken onderdelen slechts half zo groot zijn als
de oorspronkelijke. In polynomiaal veel recursieve stappen kunnen dus exponentieel grote getal-
len worden opgeknipt tot onderdelen van lengte 1 die dan gemakkelijk ook op een Turingmachine
met elkaar vermenigvuldigd kunnen worden. In totaal kan het geheugengebruik worden beperkt
tot polynomiale afmetingen, omdat de stukken kort zijn en de recursiediepte beperkt. Het is dus
niet op voorhand uitgesloten dat de berekening van een MRAM kan worden gesimuleerd door een
Turingmachine in polynomiaal geheugen. Omdat het probleem of polynomiaal geheugenbegrensde
Turingmachines gesimuleerd kunnen worden door polynomiale tijdbegrensde Turingmachines nog
steeds open is, kunnen we dus ook niet zonder meer zeggen dat de MRAM een onredelijk machine-
model is.

5.2.3 Sommen

1. Pas het programma van de Turingmachine uit voorbeeld 5.1.2 zo aan dat het werkt op een

machine met half-oneindige band.

2. Hoeveel kost de simulatie van (cid:19)e(cid:19)en stap van machine M1 die een tweedimensionale band heeft
op machine M2 als we de spiraalmethode van nummering van cellen gebruiken? Wat als we de
strokenzaagmethode gebruiken (in dit geval is een analyse van de uitgesmeerde complexiteit
aan de orde).

3. Een EDIT RAM is een random access machine die kan werken met text(cid:12)les en de volgende

operaties heeft:

(a) Een symbool uit een (cid:12)le lezen bij een textpointer (cursor)

(b) Een symbool in een (cid:12)le schrijven op de plaats van een textpointer

(c) Een texpointer aan het einde van een (cid:12)le schrijven

121

(d) Een texpointer op een plaats in de (cid:12)le zetten die overeenkomt met een getal in een

register

(e) Vervangen van text1 door text2 overal tegelijkertijd in een (cid:12)le

(f) Aan elkaar plakken van (cid:12)les

(g) Delen van text(cid:12)les copi(cid:127)eren aan de hand van de positie van textpointers

(h) Delen van (cid:12)les verwijderen die door de positie van textpointers bepaald worden.

Al deze operaties kunnen in (cid:19)e(cid:19)en stap door de Edit-RAM gedaan worden. Laat zien dat de
Edit-RAM in polynomiale tijd de waarheid van een QBF kan bepalen.

122

Hoofdstuk 6

Centrale Complexiteitsklassen

Alle redelijke machinemodellen kunnen elkaar simuleren in Polynomiale Tijd, is onze centrale aan-
name waar het machinemodellen betreft. Als we dus uitspraken willen doen over problemen en
de complexiteitsklassen waar ze in thuis horen, dan zullen we in ieder geval alle problemen die in
complexiteit niet meer dan een polynoom verschillen in dezelfde complexiteitsklasse moeten plaat-
sen. Deze complexiteitsklasse noemen we P. De klasse P zal als het ware de 0 vormen van onze
voorlopige hierarchie van complexiteitsklassen. Een plafond zullen we vooralsnog niet de(cid:12)ni(cid:127)eren,
maar om een speelbaar veld van complexiteitsklassen te verkrijgen zullen we minstens moeten zien
dat er een complexiteitsklasse bestaat die niet gelijk is aan P. In Hoofdstuk 1 van Deel I maakten
wij onderscheid tussen problemen waarvoor polynomiaal begrensde algoritmen bestaan en proble-
men waarvoor alleen exponenti(cid:127)ele tijd begrensde algoritmen bekend zijn. Dat was uiteraard niet
toevallig. We zullen zien dat de klasse van problemen waarvoor alleen exponenti(cid:127)ele tijd begrensde
algoritmen bekend zijn, die we EXP zullen noemen, ook problemen bevat waarvoor geen polyno-
miale tijd begrensde algoritmen bestaan en dus dat deze klasse werkelijk verschilt van de klasse
P.

Als machinemodel nemen we de Turingmachine. Er zijn twee duidelijke complexiteitsmaten aan
een Turingmachineberekening te geven, tijd en geheugen. Een variant van de Turingmachine, de zo-
genoemde nondetermistische Turingmachine zal verderop in het verhaal ook een rol spelen. Bij een
nondeterministische Turingmachine is er geen sprake van een toestandsovergangsfunctie, maar van
een toestandsovergangsrelatie. Bij een bepaalde con(cid:12)guratie zijn er meerdere vervolgcon(cid:12)guraties
mogelijk. Een nondeterministische Turingmachine heeft op een bepaalde invoer meerdere mogelijke
berekeningen. We spreken af dat een nondeterministische Turingmachine de invoer x accepteert
als er een berekening op x mogelijk is die accepteert. Dit heeft het voordeel dat we expressies als
(9x)[P (x)] met een algoritmisch model kunnen representeren. Vele vragen uit de AI, bijvoorbeeld
de vraag of er een pad is waarlangs de robot van A naar B kan komen, kunnen dan als algorit-
misch probleem worden gesteld. Doorgaans is dan de nondeterministische algoritme van geringe
complexiteit. Er hoeft alleen aangetoond te worden dat de oplossing bestaat gegeven de oplossing.
Dat voor het vinden van de oplossing vaak niets beters te vinden is dan exhaustive search is er de
oorzaak van vele interessante onderzoeksgebieden in de AI.

Het verband tussen tijd en geheugen is bijzonder interessant. Vaak kunnen we door wat meer
geheugen te gebruiken (bijvoorbeeld bij zoeken en sorteren) belangrijke tijdwinst boeken. Geheugen
is echter ook duurder dan tijd. Tijd krijg je vanzelf meer door te wachten. Geheugen moet je gaan

123

kopen. Tegenwoordig hebben we vaak de beschikking over hoeveelheden geheugen waarvan we
vroeger slechts konden dromen. Databases van meer dan een petabyte zijn geen uitzondering meer
en schijven van terabytes zijn zo langzamerhand retail artikelen. Op zoveel detail zullen we hier
echter niet ingaan. We zullen net als met tijd ook de geheugencomplexiteit beschouwen als functie
van de lengte van de invoer. Polynomiaal geheugen wordt dan aangegeven met PSPACE. Ook hier is
een nondeterministische variant, maar in 7.2 zullen we de opmerkelijke stelling tegenkomen dat voor
geheugengebruik het nondeterministische model geen extra rekenkracht geeft. Het is duidelijk dat
een grens op het geheugen liberaler is dan een zelfde grens op de tijd. Immers in (cid:19)e(cid:19)en stap kunnen we
niet meer dan (cid:19)e(cid:19)en nieuwe geheugencel aanspreken. Derhalve kunnen we in polynomiaal geheugen
altijd minstens evenveel als in polynomiale tijd. Aan de andere kant heeft een Turingmachine,
omdat deze een eindig aantal toestanden, en een eindig alfabet heeft niet meer dan exponentieel
veel verschillende con(cid:12)guraties op een bepaalde geheugengrens. Vandaar dat in exponenti(cid:127)ele tijd
minstens net zoveel gedaan kan worden als in polynomiaal geheugen.

Vanwege de simulatie van machinemodellen is wat betreft geheugencomplexiteit logarithmisch
geheugen de kleinste maat die onafhankelijk van het machinemodel gepresenteerd kan worden.
Complexiteitsklassen die een centrale rol spelen noteren we in Figuur 6.1 in oplopende volgorde van
inclusie. De klasse volgend op deze hierarchy is PRIM, de klasse van primitief recursieve functies,
waarin tijd en geheugengrenzen worden losgelaten.

LOGSPACE
NLOGSPACE

P
NP

PSPACE

EXP
NEXP

EXPSPACE

DEXP

...

ELEMENTARY

logaritmisch begrensd geheugen

nondeterministisch logaritmisch begrensd geheugen

polynomiaal begrensde tijd

nondeterministisch polynomiaal begrensde tijd

polynomiaal begrensd geheugen

exponentieel begrensde tijd

nondetermistisch exponentieel begrensde tijd

exponentieel begrensd geheugen

dubelexponentieel begrensde tijd (22p(n)

)

...

|{z}
tijd begrensd door 222(cid:1)(cid:1)(cid:1)

n

Figuur 6.1: Complexiteitsklassen

6.1 Polynomiale en Exponenti(cid:127)ele Tijd

Om aan te tonen dat er problemen zijn die wel in exponenti(cid:127)ele tijd op te lossen zijn, maar niet
in polynomiale tijd, moeten we tenminste (cid:19)e(cid:19)en probleem de(cid:12)ni(cid:127)eren dat op geen enkele machine in
polynomiale tijd is op te lossen. Wegens onze aanname dat redelijke machines elkaar in polynomiale
tijd kunnen simuleren, zijn we in de gelukkige omstandigheid dat we dat alleen maar voor Turing
machines hoeven te doen. Dan nog hebben we een probleem. Er bestaan oneindig veel Turing
machines en er bestaan oneindig veel polynomen, dus hoe maken we een probleem dat door geen
van die oneindig veel Turing machines in tijd begrensd door (cid:19)e(cid:19)en van die polynomen kan worden
opgelost? De oplossing hiervoor is codering, of
de Universele Turing Machine". We maken een
"

124

Turing machine die elke andere Turing machine kan simuleren in tijd begrensd door een polynoom
in de tijd waarin de te simuleren machine de berekening volooit. Dan hoeven we alleen nog maar
een probleem te verzinnen dat voor geen enkel polynoom p in tijd begrensd door p op die universele
machine kan worden opgelost, en we zijn klaar.

6.1.1 De Universele Turing Machine

Zoals we in 5.1.2 hebben gezien kunnen we een Turing machine programma dat bestaat uit een
verzameling toestanden Q en een toestandsovergangsfunctie (cid:14) beschrijven door een opsomming van
de vorm hq0; a; q1; b; Ri : : : te geven. We zullen deze opsomming coderen als lijst getallen die straks
door onze universele machine gebruikt kan worden om de berekening gedaan door deze machine na
te spelen. Dus, laat de toestands verzameling Q = fq0; : : : ; qkg zijn en het bandalfabet f0; 1; Bg.
We coderen L als 0, en R als 1. Voor natuurlijk getal i, laat bin(i) de binaire representatie van i zijn.
Een instructie qi; a ! qj; b; R, met a; b 2 f0; 1; 2g, waarin 2 de representatie van het blanco symbool
is, kan dan bijvoorbeeld geschreven worden als bin(i)#a#bin(j)#b#1. Als we elke instructie inst,
op deze manier naar een representatie rep(inst) vertalen in het alfabet f0; 1; #g dan kunnen we
het hele programma schrijven als rep(inst1)# : : : repinstn#. Tot slot kunnen we elke 0 vervangen
door 00, elke 1 door 11 en elke # door 01 en een 1 voor de hele codering zetten om een (cid:19)e(cid:19)enduidige
afbeelding van Turing machines in de natuurlijke getallen te krijgen. Om van deze representatie
een bijectie te maken spreken we af dat binair geschreven natuurlijke getallen die niet, als hierboven
beschreven, een zinvol Turing machine programma coderen altijd een Turing machine programma
coderen dat de lege verzameling herkent. Ook de invoer van een Turing machine kan op deze
manier worden meegenomen. Een representatie rep(prog) van een Turing machine programma als
boven beschreven kan met een natuurlijk getal i gecombineerd worden asl rep(prog)###bin(i).
Opnieuw vertalen we 0 naar 00, 1 naar 11 en # naar 01 en krijgen zo een representatie in de
binaire getallen van de paren programma,invoer. Een Turing machine, die we de universele Turing
machine noemen, kan als zij een getal als invoer op de band aantreft, dit getal op de hier beschreven
manier interpreteren als paar (programma, invoer), en het aldus beschreven programma op de invoer
simuleren.

Voorbeeld 6.1.1: Als voorbeeld vertalen we het programma uit Voorbeeld 5.1.2 naar een binaire
string. De toestandsovergangsfunctie zag er als volgt uit.

(cid:14)(q0; 1) = hq1; 1; Ri
(cid:14)(q0; B) = hqF ; 1; Ri
(cid:14)(q1; 0) = hq1; 0; Ri
(cid:14)(q1; 1) = hq1; 1; Ri
(cid:14)(q1; B) = hq2; B; Li
(cid:14)(q2; 0) = hqF ; 1; Li
(cid:14)(q2; 1) = hq2; 0; Li
(cid:14)(q2; B) = hqF ; 1; Li

125

We hebben te maken met vier toestanden. Deze krijgen representaties bin(0), bin(1), bin(2)
en bin(3): 00, 01, 10 en 11. Het bandalfabet is f0; 1; Bg, wat we coderen als: 00, 01 en 10. De
bewegingen L en R coderen we vervolgens als 0 en 1. De instructies zien er na deze coderingen uit

als:

00#01#01#01#1
00#10#11#01#1
01#00#01#00#1
01#01#01#01#1
01#10#10#10#0
10#00#11#01#0
10#01#10#00#0
10#11#11#01#0

(cid:14)(q0; 1) = hq1; 1; Ri
(cid:14)(q0; B) = hqF ; 1; Ri
(cid:14)(q1; 0) = hq1; 0; Ri
(cid:14)(q1; 1) = hq1; 1; Ri
(cid:14)(q1; B) = hq2; B; Li
(cid:14)(q2; 0) = hqF ; 1; Li
(cid:14)(q2; 1) = hq2; 0; Li
(cid:14)(q2; B) = hqF ; 1; Li

Nu schrijven we alle instructies achter elkaar en krijgen de string:

00#01#01#01#1#00#10#11#01#1#01#00#01#00#1#01#01#01#01#1
01#10#10#10#0#10#00#11#01#0#10#01#10#00#0#10#11#11#01#0

die we kunnen vertalen naar de binaire rij:

000001001101001101001101110100000111000111110100110111010011
01000001001101000001110100110100110100110100110111
0011011100011100011100010001110001000001111101001101
0001110001001101110001000001000111000111110111110100110100

2
Ook begrensde berekeningen kunnen op een dergelijke manier door de universele Turing machine
worden uitgevoerd. Als de Turing machine door (cid:19)e(cid:19)en of andere functie f in tijd begrensd wordt,
dan kunnen we deze functie meecoderen door in plaats van het paar programma#invoer het drietal
programma#invoer#f als getal te coderen, mits er voor f een e(cid:14)ci(cid:127)ente codering bestaat. In het
geval dat f een polynoom is, dan is alleen het rijtje co(cid:127)e(cid:14)ci(cid:127)enten van de machten van x nodig om
het polynoom (cid:19)e(cid:19)enduidig vast te leggen. De universele Turing machine kan in dat geval beginnen
met f (jxj) uit te rekenen op een aparte band en dit getal na elke gesimuleerde stap met 1 a(cid:13)agen.
Als dit getal gelijk wordt aan 0, is de gesimuleerde berekening ge(cid:127)eindigd. We spreken af dat, als
de Turing machine bij het bereiken van de 0 op de tijdband nog niet geaccepteerd heeft, de invoer
wordt verworpen. Op deze manier krijgen we geklokte Turing machines. Het is duidelijk dat er
bij hanteren van geschikte tijdgrenzen, geen verschil bestaat in de complexiteitsklassen gede(cid:12)nieerd
door geklokte Turing machines en tijdbegrensde Turing machines. Kijk bijvoorbeeld naar de klasse
P. Voor elke taal in P is er een geklokte machine die deze taal herkent. Immers er is een polynomiaal,
begrensde machine die die taal herkent. Laat p(n) de tijdgrens zijn. Als we zo’n machine nemen en
hem p(n) of groter begrenzen hebben we de gewenste geklokte machine. Omgekeerd is het evident
dat elke p(n) geklokte Turing machine een taal in P herkent.

Deze codering en simulatie is een stap die we moeten beschrijven voor het volgende onderwerp,
maar is ook een stap waaraan de informaticus natuurlijk al lang gewend is. Elk programma dat de
informaticus schrijft wordt in de machine (bijvoorbeeld door de compiler) gerepresenteerd als een
lange aaneengesloten binaire rij en dus als een getal. Het aantal manieren waarop dit kan gebeuren
is groot. Het is zelfs denkbaar een programma te representeren als een rij met daarin maar (cid:19)e(cid:19)en
symbool, zo’n representatie noemen we een tally representatie. Echter, de tally representatie heeft
als nadeel dat ze exponentieel langer is dan representaties waarin meer dan 1 symbool gebruikt
wordt, terwijl deze laatste representaties onderling niet meer dan een constante factor van elkaar
in lengte verschillen.

126

6.1.2 Het Padding Lemma
In de vorige sectie hebben we laten zien dat er een 1 (cid:0) 1-relatie bestaat tussen Turingmachine pro-
gramma’s en binair geschreven natuurlijke getallen. Er bestaat uiteraard ook een 1(cid:0)1 relatie tussen
Turing machine programma’s en functies van de natuurlijke getallen naar f0; 1g door te zeggen dat
het resultaat van de berekening 1 is dan en slechts dan als de Turing machine eindigt in een accep-
terende toestand (of (cid:127)uberhaupt eindigt) en anders 0. Elke functie naar f0; 1g is de representatie
van een deelverzameling van het origineel van die functie. Als het origineel een verzameling strings
is, dan representeert zo’n functie een taal, door te zeggen dat alles wat afgebeeld wordt op 1 in de
taal zit, en alles wat afgebeeld wordt op 0 niet in de taal zit. Zo kan dus elk natuurlijk getal een
taal of een probleem representeren. Deze representatie is echter zeer redundant. Elke taal wordt
door oneindig veel Turing machine programma’s gerepresenteerd. Immers, stel dat programma prog
een taal L representeert, dan wordt L ook gerepresenteerd door programma prog#bin(i) voor elk
natuurlijk getal i. Deze observatie, die in de berekenbaarheidstheorie bekend staat als het Pad-
ding Lemma, is een belangrijk hulpmiddel bij een belangrijke techniek om complexiteitsklassen te
scheiden, de diagnonalisatie.

6.1.3 P 6= EXP

Om aan te tonen dat EXP werkelijk verschilt van P zullen we een taal maken die door een Turing
machine M in exponenti(cid:127)ele tijd herkend wordt, maar die door geen enkele Turing machine in
polynomiale tijd herkend kan worden. Hiervoor is het handig dat we in de vorige subsectie hebben
aangetoond dat er een 1-1 verband bestaat tussen Turing machines en natuurlijke getallen, tussen
paren Turing machines-input en natuurlijke getallen en zelfs tussen drietallen Turing machine-input-
polynoom en natuurlijke getallen, m.a.w. dat we elk natuurlijk getal kunnen interpreteren als een
drietal, Turing machine, invoer, polynoom en vervolgens de executie van die Turing machine op
die invoer voor een aantal stappen begrensd door dat polynoom kunnen simuleren. Aangezien elk
drietal is af te beelden op een natuurlijk getal krijgen we door alle getallen als invoer te bekijken
een opsomming van alle talen in P, c.q. van machines die een taal herkennen. De techniek die we
hiervoor gebruiken is die van de diagonalisatie, voor het eerst gebruikt door G. Cantor. Cantor
bewees dat er meer re(cid:127)ele getallen zijn dan natuurlijke getallen als volgt. Neem aan dat er net zoveel
re(cid:127)ele getallen als natuurlijke getallen zijn. Dan kun je de re(cid:127)ele getallen tussen 0 en 1 op volgorde
zetten (zie (cid:12)guur 6.2). Die re(cid:127)ele getallen kun je voorstellen door een decimale punt gevolgd door
een oneindige rij nullen en eenen (een binaire breuk). Nu kan ik een nieuw getal maken door langs
de diagonaal van die opsomming te lopen en overal waar een 0 staat een 1 noteren en omgekeerd.
Mijn nieuwe getal krijgt dus een 1 op plaats i als er een 0 op plaats (i; i) staat in de opsomming en
een 0 als er een 1 op die plaats staat. Dat nieuwe getal is (cid:19)o(cid:19)ok een getal tussen 0 en 1, maar staat
nergens in die rij. Dus kan zo’n opsomming niet gemaakt worden.

Voordat we diagonalisatie over tijdbegrensde klassen presenteren zullen we de gelegenheid te
baat nemen om te laten zien dat er problemen zijn die helemaal niet door Turingmachines kunnen
worden opgelost, functies die niet kunnen worden uitgerekend, of talen die niet kunnen worden
herkend. Zulke problemen heten onbeslisbaar of onberekenbaar en er zijn er veel van. Je kunt dat
op (minstens) twee manieren inzien.

Allereerst geeft Cantor’s diagonaalargument een rechtstreeks, maar niet constructief, bewijs.
Elke Turingmachine herkent maar (cid:19)e(cid:19)en taal, berekent maar (cid:19)e(cid:19)en functie of lost maar (cid:19)e(cid:19)en probleem
op. Dus zijn er hoogstens zoveel berekenbare functies als er Turingmachines bestaan en dat zijn er
hoogstens zoveel als er natuurlijke getallen zijn, vanwege onze codering hierboven. Aan de andere

127

000100100100100010010......
010101001010010010001......
100101111010111100001......
111010010111000101011......
010101101110101001011......
010010010010101010011......

1
2
3
4
5
6
...

diag: 101110.....

Figuur 6.2: Cantor’s diagonaal

kant is elke functie van de natuurlijke getallen naar f0; 1g op te vatten als een oneindige rij 0’en en
1’en net zoals in Cantor’s diagonaalargument, en omgekeerd, bijv. de rij f (0)f (1)f (2) : : : = 101 : : :.
Tussen de functies van de natuurlijke getallen naar f0; 1g moeten dus functies zitten die niet door
Turingmachines kunnen worden uitgerekend.

Er is nog een tweede bewijs, door Turing in 1936 gegeven, dat ook een diagonaalargument is,
maar meer lijkt op de bewijzen die we ook voor complexiteitsklassen kunnen gebruiken. Kijk naar
de taal HALT die gede(cid:12)nieerd is als paren getallen. hx; yi 2 HALT als en alleen als het programma
x, dwz het getal x opgevat als Turingmachineprogramma, in eindige tijd stopt op invoer y. Er is
geen Turingmachineprogramma, dat altijd stopt en het antwoord JA geeft op hx; yi als hx; yi in
HALT zit en NEE als dat niet zo is.

Het bewijs hiervoor lijkt (en is ook) een bewijs uit het ongerijmde dat, als je nauwkeurig kijkt,

ook een diagonaalargument is. Het gaat als volgt.

Stel dat er wel zo’n machine zou zijn. Noem hem MH . Maak dan een nieuwe machine MD die

als volgt werkt.
1: input x
2: Simuleer MH op invoer hx; xi
3: if MH zegt JA then
4:
5: else
6:
7: end if

Loop

Stop

MD is ook een Turingmachine, dus is er (cid:19)e(cid:19)en of ander getal xD dat het programma van MD
codeert, maar kijk wat er gebeurt als MD invoer xD krijgt. Er zijn twee mogelijkheden: MD stopt
op invoer xD, dat kan als MH NEE zegt tegen invoer hxD; xDi, maar dan heeft MH het fout. Dus
mag MD niet stoppen op invoer xD, maar dat kan alleen als MH JA zegt tegen hxD; xDi en dus
heeft MH het dan ook fout. De conclusie moet zijn dat een machine MH als door ons gedroomd
niet kan bestaan.

Ons bewijs dat er een taal in EXP is die niet in polynomiale tijd herkend kan worden loopt ook
over de diagonaal van Turingmachine/polynoom en invoer paren, en is eigenlijk hetzelfde bewijs als
hierboven, met meer administratie.

We stellen ons voor dat we een (cid:12)guur met een x en een y as hebben waarlangs de natuurlijke
getallen staan. Langs de x as interpreteren we de getallen als de combinatie van natuurlijk ge-
tal/polynoom, en langs de y as interpreteren we de getallen gewoon als natuurlijke getallen. De
machine die we voorstellen krijgt x als invoer en voert het programma in Figuur 6.3 uit.

128

1: input x;
2: schrijf op een aparte band 2jxj keer een 1.
3: Laag het aantal 1 af en vervang in de volgende stappen steeds een 1 door een B. Als deze band

tussentijds leeg raakt, stop en verwerp (of accepteer, er is teveel tijd gebruikt).

4: Vat x op als programma P .
5: Simuleer P op invoer x.
6: if P verwerpt voordat de tellerband leeg is then
7:
8: end if
9: Verwerp;

accepteer

Figuur 6.3: Een taal in EXP (cid:0) P

We beweren enerzijds dat dit programma voor invoer lengte n in tijd O(2n) loopt en anderzijds
dat er geen enkel programma M , en polynoom p bestaat, zo dat M precies de invoeren accepteert
die dit programma accepteert in tijd begrensd door p. De eerste bewering is evident, aangezien we
een geklokte Turing machine gebruiken die na ongeveer 2n stappen stopt. Deze Turing machine
moet daarvoor eerst wel 2n berekenen, maar dat kan gemakkelijk in 2n stappen (hoe?). Anderzijds
kunnen we aannemen dat er (cid:19)e(cid:19)en of ander polynoom q is, z(cid:19)o dat M de taal herkend door bovenstaand
programma herkent in q(jxj). Het padding lemma zegt dat we het programma M oneindig vaak
voorkomen, dus zeker ook een keer met 2jMj >> q(jMj). Voor deze M kunnen we eens kijken wat
M doet met x = M . M decodeert M en draait dit 2jMj (cid:21) q(jMj) stappen op invoer M . V(cid:19)o(cid:19)ordat
de extra band leeg is heeft M de invoer geaccepteerd of niet. M accepteert nu echter alleen als M
verwerpt, en dat is een tegenspraak.

6.1.4

sommen

1. Een functie f heet tijdconstrueerbaar als er een Turingmachine bestaat en voor elke n een
invoer van lengte n waarop M precies f (n) toestandsovergangen doormaakt en dan stopt.
Laat zien dat de volgende functies tijdconstrueerbaar zijn. Laat zien dat n, n2, 2n en n!
tijdconstrueerbaar zijn. Zijn er ook functies die niet tijdconstrueerbaar zijn?

2. Toon aan dat het programma uit Figuur 6.3 zo kan worden aangepast dat ermee bewezen wordt
dat er een taal bestaat die wel in tijd O(nlog n herkend kan worden maar niet in polynomiale
tijd.

3. Pas het programma zo aan dat ermee bewezen wordt dat er een taal is die in geheugen n2

herkend kan worden die niet in geheugen O(log n) herkend kan worden.

6.2 NP Problemen

Exponenti(cid:127)ele tijd begrensde algoritmen zijn alleen interessant voor zeer kleine instanties. Meestal
komt het uitvoeren van een exponenti(cid:127)ele tijd begrensde algoritme neer op het bekijken van alle
mogelijke oplossingen van een probleem en daaruit de goede of meest geschikte oplossing te selec-
exhaustive search" of, in het Russisch,
teren. Wij kennen deze procedure ook wel onder de naam
"

129

perebor". Het bewijzen dat een probleem alleen kan worden opgelost door het toepassen van ex-
"
haustive search wordt in het algemeen geaccepteerd als een bewijs dat het probleem ondoenlijk is en
dat alleen zeer kleine instanties van het probleem kunnen worden opgelost. Ook wordt zo’n bewijs
geaccepteerd als een excuus om te zoeken naar algoritmen die niet in alle gevallen een oplossing
voor het probleem geven en/of slechts een benadering van de optimale oplossing. De problemen
die bewijsbaar niet kunnen worden opgelost vallen buiten het bereik van deze tekst. Problemen
waarvoor zo’n bewijs niet bestaat, maar wel een e(cid:14)ci(cid:127)ente benaderingsalgoritme komen verderop in
deze tekst nog wel aan de orde.

We komen eerst toe aan de identi(cid:12)catie van een klasse van problemen die er alle schijn van
hebben dat ze tot de klasse van zeer moeilijke problemen horen, maar waarvoor tot op heden geen
bewijs bestaat dat dat zo is. Van al deze problemen weten we dat ze kunnen worden opgelost met
exhaustive search. Tot op heden weten we echter niet of ze alleen maar met exhaustive search
kunnen worden opgelost. Deze problemen zijn sterk aan elkaar verwant en de vraag of exhaustive
search de enige mogelijke oplossing is, is bovendien dringend. Het zijn namelijk problemen die
in de praktijk vaak voorkomen. Voordat we de eigenschappen van deze problemen in detail gaan
ontleden, bekijken we eerst een aantal voorbeelden. Hiervoor gebruiken we een vast formaat. Eerst
geven we de naam waaronder het probleem bekend is, vervolgens beschrijven we de invoer van het
probleem zoals deze aan de Turing machine wordt voorgesteld en tenslotte stellen we de vraag die
door de Turing machine moet worden beantwoord. Dit antwoord is altijd van de ja/nee vorm. De
Turing machine moet accepteren of verwerpen. We geven eerst een voorbeeld van hoe zo’n probleem
gesteld wordt.

naam: KRAL
gegeven: Het Tora Bora gebergte bevat een groot aantal grotten en n vliegende draken. Van
elke draak is een deelverzameling grotten bekend waarin hij zich kan bevinden. Als een
draak zich in de grot bevindt wanneer een ridder binnenkomt, is de ruimte te krap om goed
te bewegen en is de draak kansloos. Als de ridder zich in de grot bevindt wanneer de draak
binnenkomt, vult de draak de grot met vuur en is de ridder kansloos. In het boek KRAL staan
voor ieder uur van de dag m drietallen. Als je van elk drietal twee getallen kunt wegstrepen
zodat n verschillende getallen overblijven, zijn dat de grotten waarin zich op dat uur van de
dag een draak bevindt.

gevraagd: Kan de koningin van het land n ridders erop uitsturen die op een bepaald uur van

de dag alle draken tegelijkertijd verslaan?

We zullen veel van deze problemen in deze tekst behandelen. De bovengegeven representatie
is een makkelijke manier om de problemen te de(cid:12)nieren. Elk probleem is altijd een oneindige
verzameling van instanties (voor elk gebergte kan het aantal draken, grotten en ridders vari(cid:127)eren),
en we zijn geinteresseerd in hoe moelijk een eventuele algoritme is die voor elke instantie van
het probleem gebruikt kan worden (eindige problemen zijn, vanwege onze eerder aannamen over
constanten natuurlijk niet interessant). We kunnen lang niet alle interessante problemen van deze
vorm behandelen. Dat zijn er eenvoudig te veel. In ieder geval zullen wel de volgende problemen
in onze te behandelen lijst voorkomen.

1. naam: Traveling Salesperson

gegeven: Een volledige graaf G = (V; E) met een gewichtsfunctie g : E 7! R, en een getal

gevraagd: Heeft G een Hamilton circuit waarvan het totale gewicht kleiner dan K is?

K

2. naam: Kleurbaarheid

130

gegeven: Een graaf G = (V; E) en een getal K
gevraagd: Bestaat er een functie c : V 7! K, zo dat voor geen paar (v; w) 2 E geldt

c(v) = c(w)?

3. naam: Boedelscheiding

4. naam: Exacte Overdekking

gegeven: Een verzameling getallen fw1; : : : ; wng

gegeven: Een stel deelverzamelingen S1; : : : ; Sm van U = f1; : : : ; ng

gevraagd: Bestaat er een indexverzameling I (cid:18) f1; : : : ; ng zodat geldtP
gevraagd: Bestaat er een indexverzameling I (cid:18) f1; : : : ; mg zo dat S
gevraagd: Bestaat er een indexverzameling I zo datP

gegeven: Een verzameling getallen fw1; : : : ; wng en een getal b

voor alle i 6= j geldt Si \ Sj = ;?

i2I wi = b?

5. naam: Knapsack

i2I wi =P

i =2I wi?

i2I Si = U terwijl

gegeven: Een graaf G = (V; E) en een getal K
gevraagd: Is er een deelverzameling V 0 (cid:18) V met jjV 0jj (cid:20) K zo dat voor elk paar (v; w) 2 E

6. naam: Knoopoverdekking

geldt fv; wg \ V 0 6= ;?

7. naam: Vervulbaarheid

gegeven: Een propositie van n boolese variabelen F (x1; : : : ; xn)
gevraagd: Is er een toewijzing van waarheidswaarden aan fx1; : : : ; xng die F waar maakt?

8. naam: Hamilton Circuit
gegeven: Een graaf G
gevraagd: Heeft G een enkelvoudige cykel langs alle knopen?

9. naam: Clique

gegeven: Een graaf G = (V; E) en een getal K
gevraagd: Heeft G een volledige ondergraaf van grootte tenminste K

10. naam: Onafhankelijke Verzameling

gegeven: Een graaf G = V; E en een getal K
gevraagd: Heeft G een onafhankelijke verzameling van grootte minstens K?

11. naam: Betegeling

gegeven: Een N (cid:2) N vierkant met kleuren aan de rand, en een verzameling gekleurde

tegels

gevraagd: Kan het vierkant met deze verzameling tegels worden volgelegd?

Deze lijst kan nog eindeloos worden verlengd met problemen van dezelfde soort. In 1979 hebben
Michael Garey en David Johnson [GJ79] de toenmalige stand van zaken opgetekend in hun boek
en een lijst van ongeveer 500 van deze problemen daarin opgenomen. Sindsdien is deze lijst op alle
gebieden van de wetenschap alleen maar gegroeid.

Wat is de eigenschap die deze problemen bindt? Het zijn meerdere eigenschappen.
(cid:15) Allereerst kun je veel van deze problemen in de (cid:19)e(cid:19)en of andere vorm in de praktijk tegenkomen.

{ Het kleurbaarheidsprobleem bijvoorbeeld staat voor een hele reeks van verdelingsproble-
men van een aantal zaken in een beperkt aantal deelverzamelingen die geen punt gemeen

131

hebben. Als bijvoorbeeld een aantal transacties op een computersysteem moet worden
doorgevoerd waarvan sommige dezelfde resources gebruiken (en dus niet tegelijkertijd
gestart kunnen worden) is de vraag met hoeveel kleuren zo’n verzameling gekleurd kan
worden precies de vraag in hoeveel batches deze verzameling transacties kan worden
uitgevoerd.

{ De vraag naar een exacte overdekking komt voor in het vliegverkeer, waar een vliegtuig
behalve passagiers ook vliegpersoneel kan vervoeren naar een ander vliegveld waar een
vliegtuig op ze staat te wachten. Een overdekking met minimale overlap is er dan (cid:19)e(cid:19)en
waarin zo weinig mogelijk crews (en dus zoveel mogelijk betalende passagiers) worden
vervoerd.

{ Een knoopoverdekking zoek je als je een vertegenwoordigende verzameling wilt vinden die
voor iedereen in de gemeenschap het woord kan voeren en een onafhankelijke verzameling
als je een deelverzameling van zoekt waarin niemand met iemand anders in de verzamling
ruzie heeft (handig voor een feestje).

(cid:15) Verder hebben al deze problemen gemeen dat er geen algoritmen bekend zijn om de op te
lossen anders dan de exhaustive search|probeer alle mogelijke oplossingen en kies degene die
werkt (als er (cid:19)e(cid:19)en is). Er is echter voor geen van deze problemen een bewijs dat dat de enige
mogelijke manier is om ze op te lossen.

(cid:15) Tenslotte komen we bij de de(cid:12)nierende eigenschap van deze problemen. Dat is de volgende.
Als een oplossing voor zo’n probleem gegeven wordt, dan is eenvoudig, in polynomiale tijd, te
controleren dat het een oplossing is.

{ Als we bijvoorbeeld een functie krijgen die voor elke knoop in een graaf een kleur geeft,
kunnen we gemakkelijk controleren dat deze functie aan elk tweetal knopen dat aan een
kant vastzit verschillende kleuren toewijst.

{ Als we een aantal kanten in een gewogen graaf krijgen kunnen we gemakkelijk controleren
dat deze kanten een enkelvoudig pad langs alle knopen vormen en dat bovendien de som
van de gewichten van deze kanten beneden een bepaalde grens ligt.

{ Het meest algemene voorbeeld van dit soort problemen is wel de wiskundige stelling.
Het kan lang, soms wel 300 jaar, duren om voor een interessante wiskundige stelling een
bewijs te vinden. Als zo’n bewijs echter eenmaal gevonden is, kan elke wiskundige met
voldoende scholing controleren dat het bewijs correct is in redelijke tijd. Dat er bewijzen
in de literatuur zijn die incorrect zijn hoewel ze uitvoerig gecontroleerd zijn, ligt aan de
vaak informele stijl van bewijsvoering. Als een bewijs in stricte logische formules gegeven
wordt, dan is het controleren van zo’n bewijs alleen het mechanisch nagaan van de ene
regel na de andere dat bewijsregels correct zijn toegepast. Zo’n controle zou door een
(Turing) machine gedaan kunnen worden.

Om de probleemstelling te formaliseren hebben we een speciale variant van de Turingmachine|
de nondeterministische Turing machine|nodig. We kwamen deze variant al eerder tegen in Hoofd-
stuk 6.1. We zullen dit model nu wat aandachtiger beschouwen.

132

6.3 Het Nondeterministische Model

Er is een aantal manieren om het nondeterministische model van de berekening in te voeren. De een-
voudigste vorm is die waarbij we een deterministische variant van de Turing machine een vantevoren
op de band gegeven paar, probleem-oplossing laten controleren. Hierbij voeren we de beperking
dan wel in dat de lengte van de oplossing polynomiaal is in de lengte van het probleem, zodat ook
de lengte van de Turing machine berekening polynomiaal is in de lengte van het probleem.

De meest gebruikelijke karakterisering van nondeterminisme is het Turing machinemodel, waar-
bij de toestandsovergangsfunctie wordt veranderd in een relatie. In plaats van (cid:19)e(cid:19)en mogelijke opvolger
van het paar q, a is er nu een aantal mogelijke opvolgers, en de Turing machine mag in elke stap
een keuze maken tussen de mogelijke opvolgers. Zo een serie van keuzes eindigt dan na polynomiaal
veel stappen in een accepterende of verwerpende toestand, en elk van de rijen van keuzen is nu een
mogelijke berekening op de invoer. We spreken af dat de Turingmachine accepteert, als er een rij
keuzen bestaat die eindigt in een accepterende toestand.

Een derde manier om nondeterminisme te karakterizeren is met een existentiele quantor over een
verzameling van strings in lengte begrensd door een polynoom in de lengte van de probleemstelling.
We veronderstellen dat er een (deterministisch) polynomiale tijd berekenbaar predicaat R bestaat
dat op invoer x; y het antwoord 0 of 1 kan geven en krijgen een karakterizering van nondeterminisme
in de expressie (9y)[jyj (cid:20) p(jxj) ^ R(x; y)].

Al deze manieren om nondeterminisme te beschrijven zijn equivalent, en het is aan de lezer om
een keuze te maken die het best bij de intu(cid:127)(cid:16)tie past. In deze tekst zullen we voor het nondetermi-
nistische Turing machinemodel kiezen, voornamelijk om historische redenen.

Het is niet nodig de lengte van de oplossing begrensd te houden tot polynomiale afmetingen. Als
we de lengte van de oplossing exponentieel laten groeien, krijgen we de nondeterministische variant
van exponenti(cid:127)ele tijd (NEXP), maar ook grotere lengtes geven karakterizering van nondeterminis-
tische klassen (dubbel, drievoudig, tot en met n-voudig nondeterministisch exponenti(cid:127)ele tijd). De
eerste klasse waarbij nondeterminisme en determinisme gelijk zijn is de klasse ELEMENTARY, waar
een rekentijd wordt toegestaan die een herhaalde macht van twee is (222:::
) en waarbij het aantal
herhalingen lineair is. Uiteraard kunnen nondeterministische berekeningen gesimuleerd worden op
een deterministische machine die exponentieel veel meer rekentijd heeft. Immers, deze machine kan
alle mogelijke nondeterministische keuzen (cid:19)e(cid:19)en voor (cid:19)e(cid:19)en proberen om te zien of misschien (cid:19)e(cid:19)en van
deze keuzen eindigt in een accepterende toestand. Als we dus de klasse van problemen waarvoor
een nondeterministische polynomiale tijd begrensde Turing machine bestaat aanduiden met NP,
dan krijgen we voor de tot nu toe bekeken klassen de inclusierelatie P (cid:18) NP (cid:18) EXP. Aangezien we
hebben aangetoond dat P 6= EXP moet (cid:19)e(cid:19)en van beide inclusies echt zijn, het is echter tot op heden
onbekend welke.

6.4 Reductie

Stel dat we in de winkel een programma kopen voor het oplossen van lineaire vergelijkingen. Het
programma is een implementatie van de snelst bekende algoritme en het lost problemen van de
vorm Ax = b op, waarbij A een matrix is, b een vector en x het rijtje onbekenden. Thuisgekomen
willen we natuurlijk graag dit programma inzetten om het ons al tijden ergerende probleem op te
lossen, maar het werkt niet. Als we de kleine lettertjes in de gebruiksaanwijzing lezen, komen we
erachter dat het programma alleen werkt voor symmetrische matrices, en er is ook geen garantie.
Immers in onze
Niet goed, geld kwijt. Het probleem is echter veel minder groot dan het lijkt.

133

kast hebben we nog een algoritme voor matrixvermenigvuldiging, dat ook werkt voor matrix-vector
vermenigvuldiging en we herinneren ons nog van de lessen lineaire algebra, dat we een matrix A
symmetrisch kunnen maken door hem te vermenigvuldigen met zijn getransponeerde AT . In plaats
van Ax = b op te lossen, lossen we nu het probleem AT Ax = AT b op en vinden de gezochte
oplossing.

We hebben het probleem van het oplossen van een stelsel van lineaire vergelijkingen vertaald in
het probleem van het oplossen van een stelsel lineaire vergelijkingen waarvan de co(cid:127)e(cid:14)cientenmatrix
symmetrisch is. Behalve dat dit betekent dat we onze felbegeerde oplossing in handen krijgen, zegt
dit ook iets over het probleem van het oplossen van een stelsel lineaire vergelijkingen. We hebben
te maken met twee problemen. Het algemene probleem van het oplossen van een stelsel lineaire
vergelijkingen en het speci(cid:12)eke probleem van het oplossen van een stelsel lineaire vergelijkingen met
een symmetrische co(cid:127)e(cid:14)cientenmatrix. Meestal kunnen we alleen maar zeggen dat het algemene
probleem minstens zo moelijk moet zijn als het speci(cid:12)eke probleem. Immers een algoritme die een
oplossing geeft voor het algemene probleem geeft ook een oplossing voor het speci(cid:12)eke probleem.
Omdat we nu echter beschikken over een vertaling van het algemene probleem naar het speci(cid:12)eke
probleem, kunnen we ook zeggen dat het algemene probleem niet moeilijker is dan het speci(cid:12)eke
probleem. Immers gegeven een instantie van het algemene probleem, en een algoritme voor het
speci(cid:12)eke probleem, kunnen we de vertaling en deze algoritme schakelen om zo een oplossing voor
deze instantie te krijgen. De vertaling die we hebben gevonden, reduceert onze zoektocht naar
een oplossing voor het algemene probleem naar het zoeken naar een oplossing voor het speci(cid:12)eke
probleem. De reductie moet wel aan een paar voorwaarden voldoen. Stel we hebben een reductie
van probleem A, het bronprobleem, naar probleem B, het doelprobleem. Deze reductie geeft voor
elke x een vertaling f (x) zo dat uit een oplossing voor f (x) gemakkelijk een oplossing voor x kan
worden afgeleid.

1. De reductie zelf mag niet al te ingewikkeld zijn.

In het bijzonder mag de reductie nooit
gebruik maken van eigenschappen van de oplossing voor probleem A, omdat je om die te in
handen te krijgen eerst die oplossing zou moeten berekenen.

2. Het resultaat van de reductie, de vertaling, mag niet veel langer zijn dan het originele pro-
bleem. Anders is de samenstelling van de vertaling en de e(cid:14)ci(cid:127)ente algoritme voor het probleem
waarnaartoe wordt gereduceerd geen e(cid:14)ci(cid:127)ente algoritme voor het originele probleem meer,
zoals we hadden bedoeld. De e(cid:14)ci(cid:127)ente algoritme is immers e(cid:14)ci(cid:127)ent in de lengte van de
vertaling.

Aan deze voorwaarden wordt voldaan door te eisen dat de vertaling/reductie polynomiale tijd
begrensd is. Immers in polynomiale tijd kan de reductie niet meer dan polynomiaal veel uitvoer
genereren. Als zowel de vertaling/reductie polynomiale tijd begrensd is als de algoritme voor het
doelprobleem, dan is de samenstelling van de vertaling en deze algoritme een polynomiale tijd
algoritme voor het bronprobleem.

6.5 NP-volledigheid

Het nondeterministische Turing machinemodel is (in polynomiale tijd begrensd) het de(cid:12)ni(cid:127)erende
model voor de complexiteitsklasse NP. Problemen in deze klasse worden gede(cid:12)ni(cid:127)eerd door een
Turing machine en een polynoom. Het polynoom, uitgerekend in de lengte van de invoer geeft een
tijdgrens (is grens op het aantal stappen). Als er een berekening van de (nondeterministische) Turing

134

machine bestaat die eindigt met \ja" en die korter is dan de tijdgrens, dan zeggen we dat de Turing
machine de invoer accepteert, of ook wel dat de invoer een instantie van het probleem is, of ook wel
element van de verzameling die het probleem beschrijft. Dit betekent dat het aantal problemen in
NP (net zoals overigens in alle andere door ons bekeken complexiteitsklassen ) aftelbaar is. Ieder
paar Turing machine-polynoom de(cid:12)nieert een probleem in NP en omgekeerd bestaat er voor elk
probleem in NP zo’n paar.

We weten niet of NP problemen herbergt die exponenti(cid:127)ele rekentijd vergen. Elk lang genoeg
tijdsinterval (denk aan een jaar) ziet wel een voorstel voor zo’n probleem, maar het bewijs is meestal
van de vorm
...en daarom is er geen andere mogelijkheid een oplossing te vinden dan alle mogelijke
"
oplossingen te proberen." Zulke bewijzen zijn|tot nu toe|allemaal fout gebleken. Er is echter
een deelklasse van problemen in NP waarvan het niet duidelijk is, en zo langzamerhand vanwege
alle pogingen onwaarschijnlijk wordt, dat ze deterministisch polynomiale tijd begrensde algoritmen
hebben. Deze deelklasse heeft bovendien de eigenschap dat alle problemen die erin zitten allemaal
wel, of juist allemaal niet een deterministische polynomiale tijd begrensde algoritme hebben. In het
bijzonder geldt voor deze klasse dat als voor (cid:19)e(cid:19)en van deze problemen een polynomiale tijd algoritme
zou bestaan, dan bestaat er een polynomiale tijd algoritme voor alle problemen in NP. We noemen
deze problemen NP-volledig, omdat ze de volledige complexiteit van de klasse NP in zich dragen.
Hoe zouden we van een probleem in NP bewijzen dat het deze eigenschap heeft? Hiertoe
gebruiken we het hierboven ge(cid:127)(cid:16)ntroduceerde middel van de reductie. Als we een polynomiale tijd
berekenbare functie f hebben, zo dat voor elke x en twee deelverzamelingen A en B van f0; 1g(cid:3)
geldt x 2 A dan en slechts dan als f (x) 2 B, dan is elke algoritme die y 2 B kan beslissen een
algoritme die x 2 A kan beslissen door y = f (x) te kiezen. Als voor een probleem A in NP geldt dat
er zo’n reductie f naar B bestaat, dan geldt B 2 P ) A 2 P. Om aan te tonen dat een probleem
B dus lid is van onze klasse van NP-volledige problemen hoeven we dus alleen maar aan te tonen
dat er zo’n reductie fA bestaat voor elke A in NP. Er zijn echter, zoals boven opgemerkt, aftelbaar
oneindig veel problemen in NP, zodat we dit bewijs liever niet per stuk leveren. We beschrijven
een schema voor de reductie, liever dan de reductie zelf, waarin elk afzonderlijk probleem in NP
kan worden ingevuld om een reductie van dat probleem naar ons probleem te krijgen. Om zo’n
schema te krijgen maken we gebruik van de eigenschap dat er een nondeterministische polynomiaal
begrensde Turing machine voor probleem A bestaat als A een probleem in NP is.
Neem dus aan dat er zo’n Turing machine MA bestaat en polynoom p, zodat voor elke x geldt
x 2 A dan en slechts dan als er een berekening van MA op invoer x bestaat van niet meer dan p(jxj)
stappen die eindigt in een accepterende berekening. We transformeren het drietal: programma van
MA dat een binair getal is, een beschrijving van het polynoom p, dat een ander binair getal is, en de
invoer x naar een binaire rij y zodanig dat y 2 B dan en slechts dan als MA invoer x kan accepteren
in tijd begrensd door p(jxj). Dit is het plan. Rest nog een geschikt probleem B te kiezen.

Het probleem B wordt het eerder genoemde probleem

naam: SATISFIABILITY
gegeven: Een propositie F (x1; : : : ; xn)
gevraagd: Is er een toewijzing van waarheidswaarden aan x1; : : : ; xn die F waar maakt

.

Allereerst stellen we vast dat dit zeker een probleem in NP is. Immers een nondeterministische
Turing machine kan in n opeenvolgende keuzen een toewijzing van waarheidswaarden bepalen,
waarna in een deterministische fase deze toewijzing gecontroleerd kan worden. Equivalent: een
gegeven oplossing kan in O(n2) stappen door een deterministische Turingmachine gecontoleerd

135

Q0

x0

x1

: : :

: : :

: : : xn(cid:0)1 xn

s
(cid:15)
s0

t

t
(cid:15)

Qi

Qj

QF

Figuur 6.4: Plaatje van de Turingmachineberekening met instructie (cid:14)(qi; s) = hs0; qj; Ri

worden.
Laat dus A een probleem in NP zijn en MA een Turing machine die voor gegeven polynoom
p op invoer x een accepterende berekening MA(x) van lengte p(jxj) heeft dan en slechts dan als
x 2 A. We merken terzijde op dat we kunnen aannemen dat de accepterende berekening MA(x)
niet slechts begrensd wordt door p(jxj), maar precies lengte p(jxj) heeft, dit kunnen we bereiken
door het programma van MA te wijzigen. Tevens merken wij op dat in tijd p(jxj) niet meer dan
p(jxj) bandcellen kunnen worden gebruikt en dus nemen we aan dat in de berekening precies p(jxj)
bandcellen gebruikt worden. Nu zien we dat er een accepterende berekening van MA op invoer x
bestaat precies als we het vierkant van Figuur 6.4 kunnen invullen met symbolen uit het bandalfabet
S, de toestandsverzameling Q en een merkteken dat aangeeft waar de kop is zodanig dat:

1. In elke plaats in het bandvierkant precies (cid:19)e(cid:19)en symbool uit het alfabet staat

2. In elke rij in het toestandsvak precies (cid:19)e(cid:19)en toestand staat

3. In elke rij precies (cid:19)e(cid:19)en cel is gemerkt als plaats van de bandkop

4. Voor elk paar opeenvolgende rijen geldt dat op de plaats waar de bandkop niet is de symbolen

in dezelfde kolom gelijk zijn

5. Voor elk paar opeenvolgende rijen i, en i + 1 geldt als de bandkop op plaats i; j is dan is de
bandkop op plaats i+1; j, of op i+1; j +1 of op i+1; j(cid:0)1 en deze plaats is in overeenstemming
met de toestand in rij i, het symbool op plaats i; j en het programma van MA.

136

6. Voor elk paar rijen i, i + 1 geldt dat als de bandkop op plaats i; j is, dan is het symbool op
plaats i + 1; j in overeenstemming met het symbool op plaats i; j, de toestand in rij i en het
programma van MA.

7. De eerste jxj bandsymbolen op rij 1 zijn de symbolen van x.
8. De laatste toestand in rij p(jxj) is de accepterende toestand.

Als deze condities allemaal vervuld zijn, dan heeft de machine een accepterende berekening op
invoer x van lengte p(jxj). We zullen nu laten zien dat we deze eisen kunnen vertalen in proposities
die alleen waargemaakt kunnen worden als aan deze voorwaarden voldaan kan worden. De eis dat
een er een accepterende berekening van de juiste lengte op invoer x bestaat, laat zich dan vertalen
in het bestaan van een vervulling voor de conjunctie van deze proposities. We voeren de volgende
boolese variabelen in:

1. Voor elk symbool uit het bandalfabet (cid:6) = f(cid:27)1; : : : ; (cid:27)mg voeren we de variabelen Sijk in met
i 2 f1; : : : ; mg, j; k 2 f1; : : : ; p(jxj)g. Voor elk vakje in het symbolenvierkant van Figuur 6.4
(cid:19)e(cid:19)en variabele, met de betekenis dat als Sijk waargemaakt wordt om de uiteindelijke formule
waar te maken, dan is in de accepterende berekening (cid:27)i op plaats j; k ingevuld.

2. Voor elke toestand uit de toestandsverzameling Q = fq1; : : : ; qrg een variabele Qij met i 2
f1; : : : ; rg en j 2 f1; : : : ; p(jxj)g met de betekenis dat als Qij waargemaakt wordt om de
uiteindelijke formule waar te maken, dan is in de accepterende berekening qj in rij i ingevuld.
3. Voor i; j 2 f1; : : : ; p(jxj)g een variabele Tij met de betekenis dat als Tij waargemaakt wordt
om de uiteindelijke formule waar te maken, dan is in de accepterende berekening in rij i het
merkteken voor de kop op plaats j gezet.

x1^: : :^xn vervangen worden doorV

i xi, x1_: : :_xn doorW

Om de formules overzichtelijk te houden, voeren we een aantal afkortingen in. Zo zal bijvoorbeeld
i xi en (xi_xj)i6=j als afkorting worden
gebruikt voor de kwadratische hoeveelheid paren waarop dit past, gekoppeld door conjunctie. Ook
zullen we operatoren = en ! gebruiken hoewel deze niet in de propositielogica voorkomen, maar
uiteraard (e(cid:14)ci(cid:127)ent) in de propositielogica kunnen worden uitgedrukt. Immers xi = yj d.e.s.d.a.
(xi ^ yj) _ (xi ^ yj) en xi ! yj d.e.s.d.a. xi _ yj. Achtereenvolgens kunnen we nu de eisen voor een
accepterende berekening vertalen in proposities:

jk[(Sijk _ Si0jk)i6=i0]
i(Qij _ Qij0)j6=j0
i(Tij _ Tij0)j6=j0

1. V
2. V
3. V
4. V
5. V
6. V

i

jk

W
i Sijk enV
W
j Qij enV
j Tij enV
W
ijk Qij ^ Tik ^ Sik‘ ) [V
ij Tij ! [Sijk = Si+1jk]
j(cid:20)n S0j = xj ^V

i

MA.

7. Qp(jxj) = QA.

j>n S0j = B.

137

mj0k0 Si+1km ^ Qi+1j0 ^ Ti+1k0] overeenkomstig het programma van

Als deze propositie een vervulling heeft, dan staat in de Figuur 6.4 in elk vakje precies (cid:19)e(cid:19)en
symbool, vanwege 1. Op elk moment is de machine in precies (cid:19)e(cid:19)en toestand vanwege 2. De bandkop
is op elk moment op precies (cid:19)e(cid:19)en plaats vanwege 3. Onder elkaar staande symbolen zijn gelijk als de
tapekop niet op die plaats is vanwege 4. Als onder elkaar staande symbolen van elkaar verschillen
dan is dat in overeenstemming met het programma vanwege 5. De symbolen op de eerste rij
zijn symbolen van x aangevuld met blanco symbolen, vanwege 6, en de laatste toestand is de
accepterende vanwege 7. Kortom, als de door deze reductie geproduceerde formule een vervulling
heeft, dan heeft het drietal programma, polynoom, invoer van waaruit hij geproduceerd is een
accepterende berekening.

De reductie is zeker polynomiaal begrensd. Voor een gegeven machine M , een invoer x en een
polynoom p is de grootste van de zeven formules ongeveer kwadratisch (paren variabelen) in het
aantal variabelen. Het aantal variabelen is zelf maximaal kwadratisch in p(jxj), hetgeen in totaal
een O(p(jxj)4) begrensde reductie geeft. Voor kleine Turingmachineprogramma’s is deze grens toch
al te groot om een zinnig voorbeeld op te schrijven. Het minimale aantal te gebruiken bandsymbolen
is 3 (0,1,B), zodat 10 bandcellen bij 10 tijdstappen al 300 variabelen Sijk, wat dan ongeveer 900
paren in de eerste zin zou opleveren. Helaas moeten we dus hier wat betreft het toelichten van de
reductie met een voorbeeld verstek laten gaan.

6.5.1 Meer NP-volledige problemen

Een reductie zoals we zojuist gezien hebben is een reductieschema dat voor alle problemen in NP
tegelijkertijd werkt. Zo’n reductie noemen we ook wel een masterreductie. Vanwege de schakel-
baarheid van polynomen (een polynoom van een polynoom is opnieuw een polynoom) hoeven we
niet elke keer om de volledigheid van een probleem te bewijzen zo’n algemene reductie te geven.
Immers, als we een reductie f hebben van probleem A naar probleem B en een reductie g van
probleem B naar probleem C dan geeft dit een reductie van probleem A naar probleem C om-
dat we een gegeven instantie x eerst met f vertalen naar een instantie f (x) met de eigenschap
x 2 A $ f (x) 2 B en we vervolgens f (x) met g reducerent tot g(f (x)) met de eigenschap dat
g(f (x)) 2 C $ f (x) 2 B $ x 2 A. Omdat g en f polynomiale tijd begrensd zijn, is gf dat ook en
is gf een polynomiale tijd begrensde reductie van A naar C.

Deze observatie zullen we eerst gaan gebruiken om te laten zien dat een variant van SATISFI-

ABILITY genaamd 3-SAT ook een NP-volledig probleem is.

naam: 3SAT
gegeven: Een formule F (x1; : : : ; xn) in conjunctieve normaalvorm met ten hoogste drie optre-

dens van variabelen per zin

gevraagd: Is er een toewijzing van waarheidswaarden die F waar maakt?
De reductie vertaalt een willekeurige formule F naar een formule F 0 in conjunctieve normaalvorm
(dat is een conjuctie van disjuncties waarin alleen variabelen of hun ontkenning staan) met de
eigenschap dat F 0 waargemaakt kan worden d.e.s.d.a. F waargemaakt kan worden. De reductie
gaat in twee stappen. Eerst vertalen we een willekeurige formule naar een formule in conjunctieve
normaalvorm en vervolgens vertalen we deze formule naar een formule waarin precies drie optredens
van variabelen per zin staan.
Gegeven een formule F . We nemen aan dat F syntactisch correct is. Omdat de operatoren ^ en
_ geen verschillen in prioriteit hebben is een formule als x1^x2_x3 niet syntactisch correct, maar een
formule als (x1^x2)_x3 is dat wel, evenals x1^(x2_x3). We kunnen aannemen dat F van de vorm

138

F = (F1)_ : : :_ (Fk) is of van de vorm F = (F1)^ : : :^ (Fk) met de eigenschap dat voor i = 1; : : : ; k
de formules Fi minder diep genest zijn (dwz minder haakjesparen hebben) dan de formule F . De
reductie gaat dus met inductie naar het aantal haakjesparen, waarbij we ervoor zorgen dat, als
er nog maar 1 niveau haakjes in de formule staat de formule in conjunctieve normaalvorm staat.
De formule F = (F1) ^ : : : ^ (Fk) is al van de gewenste vorm, zodat we ons in dat geval met de
subformules kunnen gaan bezighouden. Deze zijn echter van de form Fi = (G1) _ : : : _ (Gk) en
worden dus op dezelfde manier behandeld als F wanneer deze van de vorm F = (F1) _ : : : _ (Fk)
zou zijn. We behandelen dus alleen dit geval. We voeren k nieuwe variabelen y1; : : : ; yk in met de
eigenschap dat F alleen waargemaakt kan worden als tenminste 1 van deze variabelen waargemaakt
kan worden, en bovendien dat als yi waar is, dat dan ook Fi waar is. De nieuwe formule wordt.

(y1 _ : : : yk) ^ (y1 _ (F1)) : : : ^ (yk _ (Fk))

Het deel van de formule (y1 _ : : : _ yk) is van de juiste vorm. Alleen de stukken yi _ (Fi) zijn
dat nog niet. Bovendien is het aantal haakjes in het tweede deel van de formule toegenomen. Dat
is echter schijn. We merken op dat (Fi) van de vorm ((Gi
)) is en dat elke (Gi
j)
)) is. De formules (yi _ (Fi)) kunnen dus geschreven worden als
van de vorm ((H ij
(yi_(((H i1
1 )_: : :_(H ir
))^: : :^((H ir
))). Merk op dat de zichtbare haakjesdiepte|die
dus (cid:19)e(cid:19)en niveau dieper is dan die van de formule F waarmee we begonnen nu vier is. Deze formule
is echter equivalent met ((yi _ (H i1
1 ) _ : : : _ (H i1
)) ^ : : : ^ (yi _ (H ir
))) waarvan
de zichtbare haakjesdiepte slechts twee is. E(cid:11)ectief is de diepte van de structuur dus met (cid:19)e(cid:19)en
haakjespaar afgenomen.

1 ) _ : : : _ (H ir

1 ) _ : : : _ (H ij

1 )_: : :_(H i1

1) ^ : : : ^ (Gi

ki1

kir

kir

kij

k1

ir

De lezer met enige achtergrond in de logica zou kunnen opmerken dat vertalingen van con-
junctieve naar disjunctieve normaalvormen en omgekeerd ook gedaan kunnen worden met de zoge-
noemde wetten van de Morgan. Voor ons betoog is deze transformatie echter niet geschikt omdat
ze niet e(cid:14)cient is. Bekijk als voorbeeld de formule (x1 ^ x2)_ (x3 ^ x4). Passen we de distributieve
wet van de Morgan toe, dan wordt deze formule als volgt in een equivalente conjunctie vertaald.

1. (x1 ^ x2) _ (x3 ^ x4)
2. (x1 _ (x3 ^ x4)) ^ (x2 _ (x3 ^ x4))
3. (x1 _ x3) ^ (x1 _ x4) ^ (x2 _ x3) ^ (x2 _ x4).
We zien dat de formule die eerst twee haakjesparen lang was, nu vier haakjesparen lang is ge-
worden, dus in lengte verdubbeld. Dit fenomeen kent deze operatie voor de distributie van elke
variabele. Voor n variabelen wordt de formule dus 2n keer zo lang. Het verschil met de bovenbe-
schreven methode is dat we elke nieuw ingevoerde variabele slechts (cid:19)e(cid:19)en keer over alle subformules
hoeven te distribueren. Voor elke nieuwe variabele wordt de formule dus ten hoogste n sybmolen
langer. Aangezien we slechts n symbolen per stap invoeren wordt dus per stap de formule slechts n2
symbolen langer, en aangezien we in elke stap een haakjespaar kwijtraken gebeurt dit hoogstens n
keer. In totaal kan de lengte van de formule dus met O(n3) bits toenemen door onze transformaties.
We zullen tenslotte laten zien dat een formule die in conjunctieve normaalvorm staat kan worden
getransformeerd naar een equivalente formule waarin elke zin precies drie variabelen heeft. Eerst
bekijken we de zinnen van de vorm Z = (x1 _ : : : _ xn) met n > 3. Voor deze zinnen voeren we
een nieuwe variabele z in en veranderen de zin in Z0 = (x1 _ x2 _ z) ^ (z _ x3 _ : : : _ xn). Als Z
waargemaakt kan worden, kan 1 van de variabelen x1 of x2 waargemaakt worden of (cid:19)e(cid:19)en van de
variabelen x3; : : : ; xn. In het eerste geval maken we z niet waar en in het tweede geval maken we z

139

waar, zodat ook Z0 waargemaakt kan worden met de zelfde toewijzing aan xi. Als Z0 waargemaakt
kan worden, dan moet z waar of niet waar gemaakt worden. In het eerste geval concluderen we dat
ook (cid:19)e(cid:19)en van x3; : : : ; xn waargemaakt kan worden en in het tweede geval dat x1 of x2 waargemaakt
kan worden. In beide gevallen kan dus ook Z waargemaakt worden.
Tot slot merken we op dat in de zin (y1 _ y2 _ y3) ^ (y1 _ y2 _ y3) ^ (y1 _ y2 _ y3) ^ (y1 _ y2 _ y3)
de variabele y3 altijd onwaar gemaakt moet worden om een vervulling te kunnen bereiken. Twee
van zulke variabelen kunnen dan altijd worden gebruikt om zinnen van lengte (cid:19)e(cid:19)en of twee tot de
gewenste lengte aan te vullen.

Vertex Cover, Independent Set en Clique

De drie volgende problemen die we zullen gaan bekijken zijn grafenproblemen die bijzonder dicht
bij elkaar liggen. Dat wil zeggen dat de reductie van het ene naar het andere probleem zeer direct
is en weinig ingewikkelde constructies behoeft. Allereerst hebben we echter de uitspraak nodig
dat (cid:19)e(cid:19)en van deze problemen NP-volledig is, en dat behoeft wel enig werk. We kiezen voor vertex
cover waarvoor we een reductie geven van het zojuist ge(cid:127)(cid:16)denti(cid:12)ceerde probleem 3SAT. Eerst de
probleemstelling.

naam: VERTEX COVER
gegeven: Een Graaf G = (V; E) en een getal k
gevraagd: Bestaat er een deelverzameling V 0 (cid:18) V met de eigenschap dat jjV 0jj (cid:20) k en voor elke

e in E geldt e \ V 0 6= ;?

Gegeven een formule F met variabelen x1; : : : ; xn en zinnen C1; : : : ; Cm waarbij elke Ci van de
vorm (‘i1 _ ‘i2 _ ‘i3) is met ‘ij = xij of ‘ij = xij . Dan maken we een graaf G als volgt. Voor elke
variabele xi voeren we twee knopen in xi1 en xi2 die we verbinden met een kant. Voor elke zin Cj
voeren we drie knopen in yj1 , yj2 en yj3 waarvan we een driehoek maken. Als xi in Cj voorkomt
op de kde plaats (k (cid:20) 3), dan verbinden we xi1 met yjk en als xi in Cj voorkomt op de kde plaats
dan verbinden we xi2 met yjk .

Stel nu dat F vervulbaar is. Dan kunnen we dus een n-tal ‘1; : : : ; ‘n aanwijzen, zodat in elke
Cj minstens (cid:19)e(cid:19)en van deze ‘i voorkomt. Dat betekent, dat voor elke driehoek tenminste (cid:19)e(cid:19)en van
de kanten die tussen de driehoeken en de knopen lopen aan beide kanten een ‘i hebben staan. We
nemen van deze knopen degene die bij de paren hoort op in de vertex cover, alsmede de andere
twee knopen van de driehoek. We hebben nu van de paren (zonodig door aan te vullen) (cid:19)e(cid:19)en knoop,
en van elke driehoek twee knopen in de vertex cover. Totaal dus n + 2m knopen. Er geldt dat
elke kant in de paren en de driehoeken een eindpunt in de vertex cover heeft. Van de kanten die
tussen de paren en de driehoeken lopen zit of het eindpunt in de driehoek in de vertex cover, of
het eindpunt in het paar, zodat onze vertex cover volledig is.

Stel omgekeerd dat onze graaf een vertex cover van grootte n + 2m heeft. Van elk paar zit
tenminste (en ook ten hoogste) (cid:19)e(cid:19)en punt in de vertex cover en van elke driehoek zitten ten minste
(en ook ten hoogste) twee punten in de vertex cover. Alle kanten hebben per de(cid:12)nitie tenminste
(cid:19)e(cid:19)en eindpunt in de vertex cover. Omdat van elke driehoek tenminste (cid:19)e(cid:19)en punt niet in de vertex
cover zit, moet het wel zo zijn dat voor de kant die tussen dit punt en de paren loopt het andere
eindpunt in de vertex cover zit. We kunnen dus bij de paren n punten vinden (van ieder paar (cid:19)e(cid:19)en),
zodat deze n punten samen verbonden zijn met alle driehoeken. Dat wil zeggen dat de optredens
waarmee deze n punten gelabeled zijn in alle Cj voorkomen of dat we door deze optredens waar te

140

maken, de hele formule waar kunnen maken.
Voorbeeld 6.5.1: Laat gegeven zijn de formule F (x1; x2; x3) = (x1 _ x2 _ x3) ^ (x1 _ x2 _ x3). De
reductie transformeert dit tot de volgende graaf.

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

In deze graaf hebben we kanten die tussen twee delen van de graaf lopen (van de variabelen
2

naar de zinnen) onderbroken getekend voor de duidelijkheid.

Nu we de volledigheid van VERTEX COVER hebben aangetoond, kunnen we ook de volledigheid

van INDEPENDENT SET en CLIQUE bewijzen. Eerst de probleemde(cid:12)nities.

naam: INDEPENDENT SET
gegeven: Een graaf G = (V; E) en een getal k
gevraagd: Bestaat er een deelverzameling V 0 (cid:18) V met jjV 0jj (cid:21) k zo dat tussen de knopen van

V 0 geen kant zit (f(v; v0) : v; v0 2 V 0g \ E = ;)?

naam: CLIQUE
gegeven: Een graaf G = (V; E) en een getal k
gevraagd: Bestaat er een deelverzameling V 0 (cid:18) V met jjV 0jj (cid:21) k z(cid:19)o dat tussen elk paar knopen

in V 0 een kant zit (GjV 0 is een volledige ondergraaf)?

Eerst merken we op dat beide problemen in NP zitten. Gegeven een collectie van k knopen is
het immers vrij eenvoudig te controleren dat tussen elk paar geen, of juist wel, een kant aanwezig
is. Vervolgens zien we in dat de reductie tussen de beide problemen ook bijzonder simpel is.
Als afbeelding van G nemen we in beide gevallen de graaf G, de complementaire graaf.
In de
complementaire graaf is elke kant verwijderd en tussen elk paar knopen waartussen geen kant liep
is een kant aangebracht. Ofwel als G = (V; E), dan is G = (V; E) met E = V (cid:2) V (cid:0) E. Elke
independent set in G wordt een clique in G en omgekeerd.

De reductie van VERTEX COVER naar INDEPENDENT SET is ook een bijzonder simpele
reductie. Hiervoor veranderen we de graaf niet eens, we vinden alleen een andere waarde voor k.
Immers, als er een verzameling V 0 met cardinaliteit hoogstens k is zo dat alle kanten een eindpunt
in V 0 hebben, dan heeft geen kant beide eindpunten in V (cid:0) V 0, ofwel V (cid:0) V 0 is een independent
set. Dus een graaf G heeft een VERTEX COVER van grootte hoogstens k dan en slechts dan als
G een independent set heeft van grootte minstens jjV jj (cid:0) k.

Rondjes in Grafen

Grafen worden vaak gebruikt om geogra(cid:12)sche problemen te representeren, waarbij paden in gra-
fen dan de bereikbaarheidsrelatie aangeven. In het eerste deel van deze tekst hebben we ons al
afgevraagd hoe moeilijk het is om de kortste weg tussen twee punten te vinden. Dat bleek een al-
goritmisch relatief eenvoudig probleem te zijn. Hier zullen we inzien dat het vinden van de langste

141

Figuur 6.5: Euler’s eilanden in K(cid:127)onigsberg

weg tussen twee punten algoritmisch vele malen moeilijker ligt. Een rondje langs alle punten in een
graaf vinden zonder in herhaling te vallen, zullen we leren kennen als een NP-volledig probleem.
Het komt vaker voor dat moeilijke en eenvoudige algoritmische problemen dicht bij elkaar liggen. Zo
zagen wij bijvoorbeeld dat 3-SAT een NP-volledig probleem is, omdat we elke formule in conjunc-
tieve normaalvorm kunnen terugbrengen tot een formule waarin elke zin slechts drie optredens van
variabelen kent. De oplettende lezer zal hebben opgemerkt dat de daar gepresenteerde reductie niet
kan worden doorgezet totdat elke zin nog maar twee optredens van variabelen heeft. Dit heeft een
diepere betekenis, zoals we in de opgaven zullen zien. Ook in deze sectie zijn er subtiele verschillen
tussen e(cid:14)cient oplosbare en NP-volledige problemen. Het verschil tussen kortste pad/langste pad
noemden we al, maar we willen toch ook het voorbeeld van een volledige enkelvoudige cykel die alle
kanten slechts 1 keer gebruikt hier niet voorbijlopen.

naam: EULER CYCLE
gegeven: Gegeven een graaf G
gevraagd: Is het mogelijk een pad te vinden dat alle kanten precies (cid:19)e(cid:19)en keer gebruikt?

In het stadje K(cid:127)onigsberg (tegenwoordig Kalingrad) in voormalig oost Pruisen waren zeven brug-
gen over de rivier die door de stad loopt. De burgers wandelden vaak op zondagmiddag van (cid:19)e(cid:19)en
van de oevers naar de eilanden en dan naar de andere oever en dan terug. De overtuiging heerste
dat het onmogelijk is om al deze zeven bruggen over te gaan zonder (cid:19)e(cid:19)en van de bruggen twee keer
te gebruiken (zie Figuur 6.5.1). Euler loste niet allen dit probleem op, maar ook het algemenere
geval, door te bewijzen dat een ronde in een graaf die elke kant precies (cid:19)e(cid:19)en keer gebruikt (vanaf
toen Eulerronde genoemd) alleen mogelijk is als elke knoop in de graaf een even graad heeft. Het
bewijs is een eenvoudig inductiebewijs dat in elke grafentheorietekst gevonden kan worden. Voor de
complexiteit van het probleem EULER CYCLE betekent dit dat het daarmee een deterministisch
polynomiale tijd oplosbaar probleem geworden is. Immers, we hoeven slechts te controleren of elke
knoop in de graaf een even graad heeft.

Het probleem wordt echter ineens veel moeilijker als we in de de(cid:12)nitie het woord kant door

knoop vervangen.

naam: HAMILTON CIRCUIT

142

v

w

v

w

Figuur 6.6: Deelgraaf voor kanten uit G.

gegeven: Een graaf G = (V; E)
gevraagd: Is het mogelijk een permutatie van de knopen te vinden vi1 ; : : : ; vin zo dat deze

volgorde een enkelvoudig pad langs alle knopen voorstelt?

Opnieuw merken we eerst op dat dit een probleem in NP is. Immers gegeven zo’n permuta-
tie is het eenvoudig te controleren dat elke knoop precies (cid:19)e(cid:19)en keer voorkomt en dat tussen twee
opeenvolgende knopen in de rij een kant in G zit.

Het probleem is echter ook NP-volledig. Hiertoe beschrijven we een deterministisch polynomiale
tijd begrensde reductie van het probleem VERTEX COVER.
Gegeven een graaf G = (V; E) en een getal k, maken we een graaf G0 met de eigenschap dat als
G een vertex cover heeft van grootte hoogstens k, dan heeft G0 een Hamilton circuit. Onze graaf
G0 bestaat uit k zogenoemde keuzeknopen die ons elk uit de verzameling knopen van G een knoop
laten kiezen. Verder voeren we voor elke kant in G een deelgraafje van G0 in, zoals in Figuur 6.6.
Deze deelgraafjes kunnen op precies drie manieren doorlopen worden zonder een knoop over te

slaan en zonder een knoop twee keer aan te doen. Zie (cid:12)guur 6.7

1. Je kunt eerst een keer links langs alle onder elkaar liggende knopen lopen en vervolgens bij

een volgende keer rechts langs alle knopen.

2. Je kunt de eerste twee knopen van boven van de linkerkant pakken, vervolgens naar de eerste
knoop rechtsboven oversteken, dan alle knopen aan de rechterkant langslopen, en tenslotte
naar de derde knoop linksboven oversteken en de laatste twee knopen van de linkerkant
meenemen.

143

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

...

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

...

1

2

3

Figuur 6.7: 3 manieren om de deelgraaf te doorlopen

144

(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
G
G
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
W
W
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
W
W
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
G
G
(cid:15)
(cid:15)
3. Je kunt het bovenstaande pad ook gespiegeld volgen. Dus eerst de twee bovenste knopen

rechts, dan het hele linkerrijtje en vervolgens de laatste twee knopen rechts.

Als zo’n deelgraaf een kant (v; w) representeert, verbinden we in de hele graaf alle deelgrafen
die een kant (v; w0) representeren in een lang pad met de linkerkant van deze deelgraaf. Evenzo
verbinden we alle deelgrafen die een kant (v0; w) voorstellen in een lang pad met de rechterkant van
deze graaf. Een knoop wordt zo ge(cid:127)(cid:16)denti(cid:12)ceerd met een pad in de graaf. Tenslotte zijn al dit soort
paden verbonden met de k keuze knopen.

Als nu G een vertex cover van grootte k heeft, kun je in keuzeknoop 1 beginnen en vervolgens
alle deelgrafen doorlopen die een eindpunt in de vertex cover hebben (dus alle kanten) op drie
manieren:

1. Als beide eindpunten in de vertex cover zitten, dan wordt de deelgraaf twee keer doorlopen.

2. Als het linkereindpunt in de vertexcover zit, komen we aan de linkerkant binnen, nemen

vervolgens alle knopen op en gaan we er ook aan de linkerkant weer uit.

3. Idem voor de rechterkant.
Omgekeerd, als G0 een Hamilton circuit heeft kan elke deelgraaf maar op (cid:19)e(cid:19)en van de drie manieren
doorlopen worden. Aan de manier waarop een deelgraaf doorlopen wordt, kunnen we zien welke
knopen in de vertex cover horen. Het feit dat de hele graaf doorlopen wordt, garandeert een vertex
cover van grootte hoogstens k.

Als we eenmaal de NP-volledigheid van Hamilton circuit hebben aangetoond kunnen we van

daaruit weer de NP-volledigheid van het beroemde handelsreizigerprobleem aantonen.

naam: HANDELSREIZIGER
gegeven: Een volledige graaf K = (V; E), een gewichtsfunctie w : E 7! R, en een getal B
gevraagd: Heeft K een Hamilton circuit waarvan het totale gewicht kleiner dan of gelijk is aan

B

Ook dit is een probleem in NP, want als ons een Hamilton circuit gegeven wordt, is het eenvou-
dig te controleren dat het inderdaad een Hamilton circuit is, en na optellen van de gewichten te
constateren dat het totale gewicht kleiner dan of gelijk aan B is.

Het is echter ook een NP-volledig probleem. Om dit te laten zien gebruiken we de volgende
reductie van Hamilton circuit. Laat een graaf G = (V; E) gegeven zijn op n knopen. Een Hamilton
circuit in G heeft precies n kanten. We geven alle kanten in G gewicht 1, en maken G vervolgens
volledig. Alle nieuwe kanten krijgen gewicht n+1. Noem de nieuwe graaf K. Als nu gevraagd wordt
\Heeft K een Hamilton circuit waarvan het totale gewicht kleiner dan of gelijk is aan n, dan kan
het antwoord alleen maar bevestigend zijn indien ook G een Hamilton circuit heeft. Omgekeerd:
als G een Hamilton circuit heeft, dan vormen de kanten in dit Hamilton circuit een Hamilton circuit
in K waarvan het totale gewicht precies n is.
circuit heeft, of hK; ni 2 TSP , G 2 HAM.

We concluderen dus dat K een tour heeft van lengte n dan en slechts dan als G een Hamilton

Passen en Verdelen

Met passen en meten wordt de meeste tijd versleten", is een oude wijsheid. Uit een berg onderdelen
"
waarbij geen nette bouwtekening gegeven is, is het lastig iets zinnigs samen te stellen, zo dat zoveel

145

mogelijk onderdelen gebruikt worden. Iedereen die wel eens een meubelstuk bij een doe het zelf
zaak gekocht heeft, met lego gespeeld heeft, of een legpuzzel heeft opgelost, kent dit probleem. In
dit gedeelte zullen we een aantal van dit soort problemen bekijken. Een masterprobleem is dat
van het leggen van legpuzzels. We zullen zien dat een sterke vereenvoudiging van dit probleem nog
NP-volledig is. Het wordt als volgt geformuleerd.

naam: BEGRENSDE BETEGELING
gegeven: Een N (cid:2) N vierkant met kleuren aan de rand en een verzameling tegeltypen, met een

1 (cid:2) 1 oppervlakte die ook gekleurde randen hebben

gevraagd: Is het mogelijk het vierkant zo vol te leggen, dat tegels niet gedraaid worden en

aanliggende tegels langs aanliggende randen dezelfde kleur hebben?

Uiteraard is ook BEGRENSDE BETEGELING een probleem in NP immers, gegeven een in-
vulling van het vierkant kunnen we gemakkelijk controleren dat dit vierkant aan alle eisen voldoet.
BEGRENSDE BETEGELING is ook een NP-volledig probleem. Om dit te bewijzen gebruiken
we opnieuw het middel van de master reductie. Gegeven een willekeurige nondeterministische Tu-
ring machine M , een polynoom p en een invoer x construeren we een betegelingsprobleem dat een
oplossing heeft dan en slechts dan als M invoer x in ten hoogste p(jxj) stappen kan accepteren.

Om technische redenen nemen we aan dat het programma van M zodanig is dat er geen instructie
in staat waar M zowel naar links als naar rechts kan bewegen. Dit is geen beperking van de
algemeenheid. Verder nemen we aan dat elke accepterende berekening van M eindigt in de meest
linker bandcel in toestand qF met onder de kop het blanco symbool. Verder zorgen we er met een
extra instructie voor dat de laatste con(cid:12)guratie van M zo vaak als nodig herhaald kan worden.
De reductie gaat als volgt. We gebruiken kleuren die we de namen geven van achtereenvolgens
de bandsymbolen si, de toestanden qi en de combinaties van toestanden en bandsymbolen hqi; sji.
Tenslotte hebben we nog (cid:19)e(cid:19)en speciale kleur die we \wit" (w) zullen noemen. Het vierkant dat moet
worden gevuld heeft afmetingen p(jxj) (cid:2) p(jxj). Nu geven we de eerste n plaatsen langs de rand de
kleur die overeenkomt met de symbolen van x, en langs de onderrand van het vierkant plaatsen we
in het eerste vakje de kleur hqF ; wi. Nu gebruiken we de volgende tegels:

1. Voor elk bandsymbool si (inclusief si = w) hebben we een tegel die zowel aan de bovenrand

als aan de benedenrand de kleur si heeft.

2. Voor elke instructie qi; sj 7! qk; s‘R hebben we een tegel die aan de bovenrand de kleur hqi; sji

draagt, aan de onderrand de kleur s‘ en aan de rechterzijkant de kleur qk

3. Idem voor elke instructie qi; sj 7! qk; s‘L, maar dan met de kleur qk aan de linkerzijkant.
4. Voor elke tegel van de vorige twee typen en elk bandsymbool si hebben we een tegel met aan
de bovenrand de kleur si, aan de linker (resp. rechter) zijkant de kleur qk en aan de onderrand
de kleur hqk; sii.

Als er nu een berekening van M bestaat die accepteert in p(jxj) stappen, dan kunnen we uit de
achtereenvolgende con(cid:12)guraties van M een kleuring van het vierkant a(cid:13)ezen. Omgekeerd de(cid:12)nieert
elke kleuring van het vierkant ook (cid:19)e(cid:19)en op (cid:19)e(cid:19)en een accepterende berekening van M van lengte precies
p(jxj).

De NP-volledigheid van BEGRENSDE BETEGELING kunnen we gebruiken om het volgende
probleem in de rij verdeelproblemen NP-volledig te bewijzen. Het gaat hier om een gegeven aantal
deelverzamelingen waarmee we een gebied willen overdekken waarbij het aantal plaatsen dat dubbel

146

gedekt wordt zo klein mogelijk gehouden wordt. Een bekende toepassing van dit probleem is het
roosteren van (cid:13)ight crews. Vliegtuigen kunnen niet nadat ze geland zijn meteen weer opstijgen,
omdat er allerlei technische controles moeten worden uitgevoerd, het vliegtuig moet worden bijge-
tankt, soms moet worden omgebouwd van passagiers naar vrachtvliegtuig enzovoort. Evenzo kan
de crew niet altijd meteen met hetzelfde of met een ander vliegtuig weer opstijgen zodra ze geland
zijn. Soms moet er worden gegeten of worden overnacht of willen ze zomaar een paar dagen vrij.
Het gevolg hiervan is dat vliegpersoneel vaak met een vliegtuig van dezelfde of een andere maat-
schappij moet worden vervoerd naar een andere luchthaven om daar weer een vliegtuig te gaan
besturen. Een luchtvaartmaatschappij wil uiteraard zoveel mogelijk van de beschikbare stoelen
verkopen en dus graag zo weinig mogelijk van het eigen personeel vervoeren. Zaak is dus om de
uit te voeren vluchten zoveel mogelijk te bezetten met (cid:19)e(cid:19)en enkele crew. De andere constraint is
natuurlijk dat elke vlucht wel minimaal (cid:19)e(cid:19)en crew moet hebben. In onze notatie wordt dit probleem
(als beslissingsprobleem) als volgt geformuleerd.

naam: EXACTE OVERDEKKING
gegeven: Een universum U = f1; : : : ; ng en een verzameling deelverzamelingen Si (cid:18) U .

gevraagd: Bestaat er een indexverzameling I z(cid:19)o datS

i2I Si = U en (8i 6= j 2 I)[Si \ Sj = ;]?
Uiteraard is ook dit een probleem in NP. Gegeven de indexverzameling kunnen we gemakkelijk
controleren dat elk element van het universum precies (cid:19)e(cid:19)en keer voorkomt. Het probleem is ook NP-
volledig. Hiervoor produceren we een reductie van begrensde betegelingen. Gegeven een begrensd
betegelingsprobleem met een N (cid:2) N vierkant en tegeltypen Ti. We noteren een verzameling kleuren
HC die langs horizontale randen kunnen voorkomen, een verzameling VC van kleuren die langs
verticale randen kunnen voorkomen. Nu bekijken we de bovenrand van het vierkant en introduceren
de verzameling RB = fhh0; ii; kii : ki is de i-de kleur langs de bovenrand g. Evenzo voor de
onderrand van het vierkant RO = fhN + 1; i; HC (cid:0) kii : ki is de i-de kleur langs de onderrand g.
Voor de linkerrand van het vierkant introduceren we de verzameling RL = fh0; i; kii : ki is de i-de
kleur langs de linkerrand g. Voor de rechterrand van het vierkant introduceren we de verzameling
RR = fhN + 1; i; VC (cid:0) kii : ki is de i-de kleur langs de rechterrand g. Tot slot: stel dat er een
tegeltype Tk is met kleuren bk, ok, ‘k, rk respectievelijk aan de boven-, onder-, linker- en rechterkant.
Dan introduceren we de verzamelingen Tkij = fhi; j; HC(cid:0)bki;hi+1; j; oki;hi; j; VC(cid:0)‘ki;hi; j+1; rkig
voor i; j 2 f1; : : : ; Ng. Het universum is U = fhi; j; HCi;hi; j; VCig voor i; j 2 f1; : : : ; N + 1g.

Als het vierkant met tegels kan worden overdekt kunnen we aan het tegeltype Tk dat op plaats i; j
ligt a(cid:13)ezen welke deelverzameling Tkij moet worden gekozen. Aan de andere kant, als een volledige
overdekking kan worden gerealiseerd door verzamelingen Tkij en Tk0i+1j in de overdekking te kiezen,
dan betekent dat, dat er tegels Tk en Tk0 zijn die de kleur bk langs de onder, resp bovenrand hebben
en die dus op coordinaten i; j en i + 1; j gelegd kunnen worden voor gegeven i en j, ofwel dat er
een kleuring van het vierkant mogelijk is.

De volgende twee problemen in de rij passen en meten zijn koppelingsproblemen. We hebben
gegeven dat bepaalde elementen in groepen kunnen voorkomen, maar natuurlijk is voor elk element
niet (cid:19)e(cid:19)enduidig bepaald in welke groep dit element terechtkomt. Dit probleem is oorspronkelijk
bekend onder de naam
In deze (ouderwetse) vorm ging het erom
paren aan elkaar te koppelen, zodat de totale verzameling paren een stabiele koppeling voor zou
stellen. We hebben dit probleem eerder gezien in 3.4.1 en daar gezien dat het een eenvoudig
oplosbaar probleem is. De situatie wordt heel anders wanneer we het probleem uitbreiden van
paren naar trio’s. De complexiteit van het probleem springt dan ineens van P naar NP-volledig.
We zetten de twee probleemstellingen even onder elkaar om te zien hoe weinig de twee van elkaar

stabiele huwelijksprobleem".
"

147

verschillen.

naam: MATCHING
gegeven: U = f1; : : : ; mg, m (cid:21) n en een verzameling paren fPigm
gevraagd: Is er een indexverzameling I met jjIjj = n zo dat elke u 2 U precies (cid:19)e(cid:19)en keer op elke

i=1, Pi 2 U (cid:2) U

co(cid:127)ordinaatplaats voorkomt inS
op elke co(cid:127)ordinaatplaats voorkomt inS

i2I Pi?

i2I Di ?

naam: 3-DIMENSIONAL MATCHING
gegeven: U = f1; : : : ; mg, m (cid:21) n en een verzameling drietallen fDigm
gevraagd: Is er een indexverzameling I, met jjIjj = n zo dat zo dat elke u 2 U precies (cid:19)e(cid:19)en keer

i=1, Di 2 U (cid:2) U (cid:2) U

Zoals vaker gebeurt bij de overgang van 2 naar 3|zoals we hierboven gezien hebben bij SATIS-
FIABILITY en zoals we verderop zullen zien bij kleurenproblemen|zien we een verandering van
de complexiteit van het probleem van doenlijk naar ondoenlijk. De bovengrens voor het probleem
blijft polynomiaal. Immers, 3-DIMENSIONAL MATCHING is een probleem in NP. Wanneer ons
zo’n indexverzameling gegeven wordt, kunnen we gemakkelijk nagaan dat voor alledrie de coordi-
naten de projectie van de verzamgeling drietallen op die coordinaat een permutatie van de getallen
1; : : : n is. Dat 3-DIMENSIONAL MATCHING ook een NP-volledig probleem is tonen we aan door
een reductie van EXACTE OVERDEKKING naar 3-DIMENSIONAL MATCHING te geven.
Gegeven een exact overdekkingsprobleem met U = f1; : : : ; ng met verzamelingen Si. We gaan
een verzameling drietallen D en een universum T maken, z(cid:19)o dat als een deelverzameling van D exact
T (cid:2) T (cid:2) T overdekt, we uit die overdekking een deel van de verzamelingen Si kunnen selecteren dat
exact U overdekt. Allereerst de(cid:12)nieren we paren hi; ji, voor alle i en j waarvoor i in Sj zit. Al deze
paren vormen de verzameling T . Verder laten we (cid:11)(i) de minimale hi; ji zijn waarvoor er zo een paar
hi; ji bestaat. Tot slot hebben we nog een afbeelding (cid:25) nodig die voor vaste j steeds een cyclische
permutatie is van Sj. Dus als we een paar hi1; ji hebben, dan is (cid:25)(hi1; ji) het paar hi2; ji waarbij i2
het element in Sj is dat volgt op i1. De permutatie (cid:25) loopt zo de hele verzameling Sj door, todat
we weer bij i1 terug zijn. Nu de(cid:12)nieren we drietallen D = f((cid:11)(i);hi; ji;hi; ji)g[f((cid:12);hi; ji; (cid:25)(hi; ji) :
(cid:12) 2 T ^ (cid:12) 6= (cid:11)(hi; ji)g.
De bewering is nu dat er een deelverzameling van deze drietallen bestaat die T(cid:2)T(cid:2)T overdekt als
en alleen als er een deel van de Sj bestaat dat exact U overdekt. Dus laten we maar eens aannemen
dat er zo’n verzameling drietallen bestaat. Allereerst moeten de elementen (cid:11)(i), allemaal in de
eerste coordinaat van T (cid:2) T (cid:2) T geraakt worden, dus we moeten voldoende paren uit het eerste deel
van D kiezen. Die worden allemaal met (cid:19)e(cid:19)en of ander paar hi; ji in de tweede coordinaat en hetzelfde
paar hi; ji in de derde coordinaat gekozen. We beweren dat de verzameling van alle j’s die op deze
manier gekozen wordt zo is dat de Sj een exacte overdekking vormen van U . Het is duidelijk dat
de vereniging van de Sj de verzameling U overdekt, het is dus voldoende te bewijzen dat de zo
gekozen Sj een onderling lege doorsnede hebben. Stel dus maar dat we een paar hi; ji en een paar
hi0; j0i kiezen zo dat Sj \ Sj0 6= ;. Neem aan dat Sj \ Sj0 (cid:27) fkg. Het drietal ((cid:11)(k);hk; ‘i;hk; ‘i) kan
zo gekozen worden dat ‘ = j of ‘ = j0, maar niet allebei. Laten we aannemen dat hk; j0i gekozen
wordt. Aangezien k 2 Sj zal ook het paar hk; ji ergens in de eerste, tweede en derde coordinaat
moeten optreden. In het bijzonder is van belang dat het in de tweede coordinaat optreed. Als we
namelijk hk; ji in de tweede coordinaat ergens kiezen, dan moet de derde coordinaat van dit drietal
gelijk zijn aan (cid:25)(hk; ji). Immers we kunnen dit paar niet meer met (cid:11)(k) in de eerste coordinaat
kunnen kiezen. Dit is echter een paar hk0; ji waarbij k0 het element van Sj is dat volgt op k. Dit
betekent dat ook ((cid:11)(k0);hk0; ji;hk0; ji) niet in de overdekking met drietallen gekozen kan worden en
dus dat ook hk0; ji alleen in de tweede coordinaat door de overdekking kan worden geraakt door een

148

drietal ((cid:12);hk0; ji; (cid:25)(hk0; ji). Zo voortgaande schakelen we achtereenvolgens alle elementen van Sj
uit als kandidaat om op te treden in een drietal ((cid:11)(r);hr; ji;hr; ji), ofwel Sj is niet een verzameling
die in de overdekking is gekozen. Tegenspraak.
Als omgekeerd een overdekking van de Sj bestaat die U overdekt, dan kunnen we voor elke i
die in een Sj zit, het bijbehorende drietal ((cid:11)(i);hi; ji;hi; ji) kiezen. Het feit dat de gekozen Sj een
lege doorsnede hebben, maakt dat we de rest van T (cid:2) T (cid:2) T kunnen overdekken met drietallen van
de vorm (hi; ji;hi; ji; (cid:25)(hi; ji).

Laten we dit ingewikkelde verhaal toelichten aan de hand van een voorbeeld.

Voorbeeld 6.5.2: Stel dat het universum U = f1; : : : ; 5g en laten de verzamelingen Si als volgt
gegeven zijn.

S1 = f1; 4; 5g
S2 = f2; 3g
S3 = f1; 3; 5g
S4 = f2; 5g

Merk op dat S1 en S2 samen een exacte overdekking vormen. De paren (cid:11)(ui) voor i = 1; : : : ; 5 zijn
dan fh1; 1i;h2; 2i;h3; 2i;h4; 1i;h5; 1ig

De verzameling T bestaat uit de paren:

fh1; 1i;h1; 3i;h2; 2i;h2; 4i;h3; 2i;h3; 3i;h4; 1i;h5; 1i;h5; 3i;h5; 4ig

en dus hebben we de volgende verzameling drietallen:

f(h1; 1i;h1; 1i;h1; 1i);
(h2; 2i;h2; 4i;h2; 4i);
(h4; 1i;h4; 1i;h4; 1i);
(h5; 1i;h5; 4i;h5; 4i)g

(h1; 1i;h1; 3i;h1; 3i);
(h3; 2i;h3; 2i;h3; 2i);
(h5; 1i;h5; 1i;h5; 1i);

(h2; 2i;h2; 2i;h2; 2i);
(h3; 2i;h3; 3i;h3; 3i)
(h5; 1i;h5; 3i;h5; 3i);

en de drietallen

f((cid:12);h1; 1i;h4; 1i);
((cid:12);h2; 2i;h3; 2i);
((cid:12);h3; 3i;h5; 3i);
((cid:12);h5; 4i;h2; 4i)g

((cid:12);h4; 1i;h5; 1i);
((cid:12);h3; 2i;h2; 2i);
((cid:12);h5; 3i;h1; 3i);

((cid:12);h5; 1i;h1; 1i);
((cid:12);h1; 3i;h3; 3i);
((cid:12);h2; 4i;h5; 4i);

voor (cid:12) lopend over alle paren die niet (cid:11)(i) zijn. Een overdekking van T (cid:2) T (cid:2) T is nu

f(h1; 1i;h1; 1i;h1; 1i);
(h4; 1i;h4; 1i;h4; 1i);
(h2; 4i;h3; 3i;h5; 3i);
(h5; 4i;h5; 4i;h2; 4i)g

(h2; 2i;h2; 2i;h2; 2i);
(h5; 1i;h5; 1i;h5; 1i);
(h3; 3i;h5; 3i;h1; 3i);

(h3; 2i;h3; 2i;h3; 2i);
(h1; 3i;h1; 3i;h3; 3i);
(h5; 3i;h2; 4i;h5; 4i)

Het volgende probleem in deze serie is KNAPSACK. We hebben al eerder een variant van
KNAPSACK gezien die kon worden opgelost met behulp van een gulzige algoritme. Ook hebben
we gezien dat dynamisch programmeren helpt om de discrete variant van KNAPSACK op te lossen.
De grens die we vonden voor een dynamisch programmeren algoritme voor een KNAPSACK met

2

149

n objecten en grens b was n (cid:2) b. We merken op dat, hoewel deze algoritme voor begrensde b
een polynomiale tijd algoritme is, de gevonden grens toch exponentieel in de lengte van de invoer
kan zijn, omdat b nu eenmaal in log b bits in de invoer kan worden gepresenteerd. Het bewijs
dat KNAPSACK NP-volledig is, dat we hieronder geven, is dan ook niet in tegenspraak met onze
onwetendheid omtrent de relatie tussen P en NP.

naam: KNAPSACK
gegeven: Gegeven een verzameling gewichten w1; : : : ; wn en een grens b

gevraagd: Is er een indexverzameling I z(cid:19)o datP

i2I wi = b?

Sj zit en 0 anders. Voor elke Sj maken we nu het getal sj =P

Natuurlijk is KNAPSACK een probleem in NP. Immers gegeven een indexverzameling kunnen
we gemakkelijk controleren dat de som van de gewichten van de elementen in deze verzameling
precies b is. KNAPSACK is echter ook NP-volledig. We laten dit zien door een reductie van
EXACT COVER. Laat eens een universum U = f1; : : : ; ng gegeven zijn, en een stel verzamelingen
Sj. We de(cid:12)nieren uij = 1 , i 2 Sj. Als we b = n kiezen, dan zien we hier al dat wanneer er een
overdekking bestaat met de Sj die een onderling lege doorsnede hebben, de bijbehorende uij precies
tot n sommeren. We kunnen nu echter ook een stel verzamelingen kiezen zodat de bijbehorende uij
tot n sommeren zonder dat deze verzamelingen een overdekking vormen. We kunnen bijvoorbeeld
n keer de verzameling f1g kiezen. De oplossing wordt gevonden door te verhinderen dat optellingen
van elementen een carry tot gevolg hebben. Als het aantal deelverzamelingen m is, dan kunnen we
nooit meer dan m keer hetzelfde element kiezen. In plaats van uij = 1 kiezen we uij = mi als i in
i=1 mi. Als er een
stel sj bestaat dat tot b sommeert, dan betekent dat dat voor elke macht van m precies (cid:19)e(cid:19)en j in dit
stel is zo dat uij = mi, anders zien we in de som mi niet met co(cid:127)e(cid:14)cient 1 optreden. Dus als er een
oplossing voor het KNAPSACK probleem is, dan is er ook een exacte overdekking en omgekeerd.
Het laatste probleem in deze serie is boedelscheiding. Hier moet niet een verzameling gevonden
worden die precies een bepaald gewicht heeft, maar moet een gegeven verzameling in twee(cid:127)en gedeeld
worden zodat beide delen precies evenveel waarde hebben. In de praktijk is de taak van de verdeler
(rechter) natuurlijk om twee verzamelingen te vinden die in waarde zo weinig mogelijk van elkaar
verschillen, en wordt die keuze nog bemoeilijkt doordat hetzelfde object voor verschillende personen
verschillende (emotionele) waarde kan hebben, maar in onze ideale wereld van de wiskunde kunnen
we dit probleem als beslissingsprobleem stellen, als volgt.

i uij en b =Pn

naam: BOEDELSCHEIDING
gegeven: Gegeven een verzameling gewichten w1; : : : ; wn

gevraagd: Is er een indexverzameling I z(cid:19)o datP

i2I wi =P

i =2I wi?

Ook BOEDELSCHEIDING is een probleem in NP. Immers, gegeven een index verzameling
kunnen we gemakkelijk controleren dat de beide deelverzameling gelijke som hebben. BOEDEL-
SCHEIDING is ook NP-volledig. Om dit te bewijzen geven we een reductie van KNAPSACK.

Laat gegeven zijn een stel gewichten w1; : : : ; wn en een getal b. We maken een stel gewichten
w1; : : : ; wn; wn+1; wn+2 waarvoor een boedelscheiding bestaat dan en slechts dan als de KNAP-
SACK een oplossing heeft. De gewichten w1; : : : ; wn blijven gelijk. De nieuwe gewichten wn+1
en wn+2 maken we allereerst zo dat ze bij een boedelscheiding niet allebei aan dezelfde kant van
de indexverzameling terecht kunnen komen. Daarvoor maken we wn+1 gelijk aan b + 1 en wn+2

gelijk aanP wi (cid:0) b + 1. Als wn+1 en wn+2 nu allebei in I of juist niet in I zitten, dan kunnen de

overgebleven elementen nooit een zo grote som hebben dat dit kan worden gecompenseerd.

Veronderstel nu dat er een boedelscheiding mogelijk is. Dus dat er een indexverzameling I

bestaat, zodat

150

wn+2 +P
P
i(cid:20)n wi (cid:0) b + 1 +P
b + 1 +P
wn+1 +P

‘ =2I w‘ =
‘ =2I w‘

k2I wk =

k2I wk =

Dan is 2P

.

i2I wi = 2b, ofwelP

i2I wi = b

Kleuren

De laatste familie van problemen die we in deze tekst bespreken is de familie van de kleurenproble-
men. Het beroemdste lid van deze familie is misschien wel het vierkleurenprobleem voor planaire
grafen. Gegeven is een landkaart met landen die niet in (cid:19)e(cid:19)en punt aan elkaar grenzen. Gevraagd
is de landkaart met vier kleuren in te kleuren. Verrassend genoeg lukt dit altijd. Pas in de vorige
eeuw werd bewezen door Appel en Haken dat een planaire graaf (dat is een graaf die in het platte
vlak kan worden ingebed) met vier kleuren altijd zo kan worden gekleurd dat geen twee knopen
die aan dezelfde kant zitten dezelfde kleur krijgen. Dit noemen we een legale kleuring. Het bewijs
reduceerde eerst de oneindige verzameling van planaire grafen tot een eindig aantal typen (een paar
duizend) waarvan vervolgens met behulp van een computerprogramma kon worden aangetoond dat
ze allemaal vierkleurbaar zijn. Een inzichtelijk bewijs voor deze stelling ontbreekt echter altijd nog.
kan de graaf met K kleuren worden gekleurd"
"
dus een simpel probleem. Het antwoord is ja. Voor algemene grafen, en ook voor K = 3 is het
probleem NP-volledig, zoals we hieronder kunnen zien. Voor K = 2 is het probleem opnieuw simpel,
hoewel dan voor sommige grafen het antwoord ja en voor andere het antwoord nee is.

Voor planaire grafen en K (cid:21) 4 is het probleem

Het grafenkleurprobleem:

met hoeveel kleuren kan een graaf worden gekleurd?" is een uitbrei-
"
ding van het onafhankelijke verzameling probleem. Immers een graaf moet worden onderverdeeld
in een aantal onafhankleijke verzamelingen, en wat is het minimale aantal waarvoor dit mogelijk
is? Het probleem wordt CHROMATIC NUMBER genoemd in Engelse teksten. Hier zullen wij het
aanduiden met het KLEURGETAL van een graaf.

naam: KLEURGETAL
gegeven: Gegeven een graaf G en een getal K
gevraagd: Is er een legale kleuring van G met K kleuren?

Ook dit is een probleem in NP, want gegeven een oplossing kunnen we gemakkelijk controleren
dat de regels van kleurbaarheid niet overschreden zijn en dat slechts K kleuren gebruikt zijn. Om
aan te tonen dat het probleem ook NP-volledig is geven we een reductie van 3SAT.

Gegeven is dus een formule F (x1; : : : ; xn), en we gaan een graaf maken die met n + 1 kleuren
te kleuren is dan en slechts dan als de formule vervulbaar is. We nemen zonder beperking der
algemeenheid aan dat n (cid:21) 4. Allereerst maken we een complete graaf op n knopen, B, die ervoor
zorgt dat de meeste kleuren vergeven zijn. Om deze graaf te kleuren hebben we tenminste n kleuren
nodig. Vervolgens voeren we 2n knopen xi en xi in die we paarsgewijs met elkaar verbinden, zodat
ze niet dezelfde kleur kunnen krijgen. Deze knopen stellen de variabelen voor. Bovendien worden
de knopen uit elk paar met alle knopen behalve 1 uit B verbonden. Hoogstens (cid:19)e(cid:19)en van deze knopen
kan dus de kleur van deze ene knoop uit B krijgen. De andere knoop moet de enig overgebleven
n + 1e kleur krijgen, deze kleur zal de kleur \onwaar" voorstellen. We voeren m knopen cj in. Deze
knopen stellen de zinnen voor. Tenslotte zullen cj verbonden zijn met xi (xi) als xi (xi) niet in de
zin cj voorkomt.

151

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

Figuur 6.8: Gadget voor 3-Kleurbaarheid

We beweren nu dat de aldus geconstrueerde graaf gekleurd kan worden met n + 1 kleuren dan
en slechts dan als F vervulbaar is. Laten we eerst eens kijken hoe deze graaf gekleurd zou kunnen
worden. We hadden al gezien dat er n kleuren voor de deelgraaf B nodig zijn. Van de paren xi, xi
is er (cid:19)e(cid:19)en die de n + 1e kleur moet krijgen. Alle andere moeten (cid:19)e(cid:19)en van de n eerste kleuren krijgen.
Verder kan geen van xi, xi, xj, xj dezelfde kleur kan krijgen voor i 6= j. Omdat n (cid:21) 4, is elke
knoop cj wel verbonden met zowel xi als xi voor (cid:19)e(cid:19)en of andere i. Dus cj kan niet met kleur n + 1
gekleurd worden. In een legale kleuring kan cj dus alleen de kleur van een xi of een xi krijgen die
wel in de jde zin voorkomt en die niet de n + 1e kleur (onwaar) gekregen heeft. Dat betekent dus
dat als de graaf gekleurd kan worden, we in elke zin een xi of xi kunnen kiezen die waargemaakt
kan worden en dus dat F waargemaakt kan worden. Dit recept, in omgekeerde vorm, geeft tevens
bij iedere toewijzing die F waarmaakt een kleuring van de graaf.

naam: 3-KLEURBAARHEID
gegeven: Gegeven een graaf G
gevraagd: Is er een legale 3-kleuring van G?

Als het algemene kleuringsprobleem een probleem in NP is, geldt dat natuurlijk ook voor het
probleem als we het aantal kleuren tot drie beperken. Wat opmerkelijker is, is dat deze beperking
het probleem niet makkelijker maakt. Om dit te bewijzen geven we weer een reductie van 3SAT. In
dit geval hebben we, zoals in het geval van de reductie van VERTEX COVER naar HAMILTON
CIRCUIT kleine graafjes nodig met een bijzondere eigenschap, zogenoemde gadgets. Hier maken
we gebruik van de graafjes uit Figuur 6.8

Gegeven drie kleuren, bijvoorbeeld r, b en z heeft deze graaf de eigenschap dat als alle drie
de knopen aan de linkerkant dezelfde kleur krijgen, bijvoorbeeld z, dan wordt de meest rechtse
knoop ook met deze kleur gekleurd. Dit is een mooie karakterizatie voor 3-SAT. Als namelijk alle
optredens van variabelen in een zin van 3-SAT de waarde onwaar krijgen, dan krijgt de zin ook deze
waarde. Nu voeren we voor elke variabele xi twee knopen xi, en xi in, die we met elkaar verbinden,
zodat ze niet dezelfde kleur kunnen krijgen en we verbinden al deze knopen met een derde knoop R,
zodat er maar twee kleuren overblijven om xi en xi te kleuren. Voor elke zin in de formule nemen
we een graafje zoals in Figuur 6.8, en we verbinden alle rechterknopen van deze (cid:12)guurtjes met R
zodat de rechterkanten (cid:19)e(cid:19)en van de twee kleuren moeten krijgen die we voor xi en xi gebruiken. We
verbinden alle rechterkanten nog met een extra knoop F die zelf met R verbonden is, zodat er nog
maar (cid:19)e(cid:19)en kleur voor de rechterkanten overblijft. Nu krijgen alle linkerkanten van de (cid:12)guurtjes de
naam van het optreden van de variabele op die plaats in die zin (dus xi of xj) en we smelten alle
knopen die dezelfde naam hebben tot (cid:19)e(cid:19)en knoop.

152

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

Figuur 6.9: Crossover Component

Als nu de resulterende graaf gekleurd kan worden, dan hebben alle rechterkanten van de (cid:12)-
guurtjes dezelfde kleur, en deze kleur komt op minstens (cid:19)e(cid:19)en plaats aan de linkerkant voor. Dat
betekent, als we deze kleur even waar noemen, dat in elke zin een optreden van een variabele
gekozen kan worden die waargemaakt kan worden, en dat betekent weer dat F waargemaakt kan
worden. Omgekeerd geeft een toewijzing van waarheidswaarden die F waarmaakt met dit recept
een legale driekleuring van de graaf.

naam: PLANAIRE 3-KLEURBAARHEID
gegeven: Gegeven een planaire graaf G
gevraagd: Is er een legale 3-kleuring van G?

We hebben een nog specialer geval van een probleem in NP dus ook dit probleem is een probleem
in NP. Een gegeven oplossing kan gemakkelijk gecontroleerd worden. Zelfs planariteit maakt echter
het probleem niet makkelijker als het aantal kleuren beperkt wordt tot drie. Om dit te bewijzen
laten we zien dat we elk paar kanten die de graaf niet planair maken, omdat ze niet in twee dimensies
kunnen worden ingebed, kunnen worden vervangen door een component die wel planair is, zo dat
bewaren". We maken een graaf die de eigenschap heeft
de uiteinden van die component de kleur
"
dat hij planair en driekleurbaar is en dat de kleur van de meest linker knoop dezelfde moet zijn
als de kleur van de meest rechter knoop en dat de kleur van de bovenste knoop dezelfde moet zijn
als de kleur van de onderste knoop. Deze graaf wordt gegeven in Figuur 6.9. Als we een niet
planaire graaf hebben, dan kunnen we de paren kanten die in drie dimensies kruisen paar voor paar
vervangen door zo’n crossover component en we houden een platte graaf over. Elke driekleuring
van de oorspronkelijke graaf geeft een driekleuring van de nieuwe graaf en omgekeerd, vanwege de
eigenschap van deze crossover componenten.

6.5.2 Beslissen, Optimalisatie en Zelfreduceerbaarheid

NP-volledige problemen zoals we in hierboven hebben gezien komen in de praktijk vaak voor als
optimaliseringsproblemen. Er wordt niet gevraagd:
is er een overdekking waarbij de paarsgewijze
"
wat is de overdekking waarbij het totale aantal vaker voorkomende
doorsneden leeg zijn?", maar:
"
is er een boedelscheiding waarbij de ene verzameling precies
elementen zo klein mogelijk is?" Niet:
"

153

evenveel waard is als de andere?", maar:
bij welke boedelscheiding is het verschil zo klein moge-
"
lijk?", etc. etc. Ook willen we graag van een algoritme die een antwoord op ons probleem geeft
graag wat meer informatie dan alleen maar ja/nee. Als we een algoritme hebben die beslist of een
graaf op 500 knopen 32 kleurbaar is, dan is
ja" misschien niet een antwoord waar we erg gelukkig
"
van worden. We willen zo’n kleuring ook graag in handen hebben.

Tussen beslissen en optimaliseren is gelukkig een eenvoudig verband. Een snelle beslissingsalgo-
ritme geeft een snelle optimaliseringsalgoritme door tussenkomst van binair zoeken, en een snelle
optimaliseringsalgoritme geeft triviaal een snelle beslissingsalgoritme. Toch valt er nog iets meer
over te zeggen. Een algoritme voor het beslissen van VERTEX COVER geeft voor de paren G; k,
waarbij G een graaf is en k een aantal knopen het antwoord \ja" als er een vertex cover van grootte
hoogstens k in de graaf zit. Voor zo’n vertex cover bestaat een kort bewijs, bijvoorbeeld zo’n verza-
meling knopen. Het is echter helemaal niet duidelijk wat een kort bewijs zou zijn voor de uitspraak
G heeft geen vertex cover van grootte k. Het complement van het probleem VERTEX COVER
bestaant uit alle paren G; k waarvoor de kleinste vertex cover in G groter is dan k. Dit zou dus wel
eens wezenlijk moeilijker kunnen zijn dan VERTEX COVER zelf. Uiteraard is niet het geval wan-
neer er een deterministisch polynomiale tijd algoritme voor VERTEX COVER zou zijn. Problemen
die van de vorm zijn als in dit voorbeeld|de kleinste vertex cover in G heeft grootte k|vormen
een aparte klasse. Ze kunnen worden opgelost door een deterministisch polynomiale tijd machine
die toegang heeft tot vragen aan NP-volledige problemen. Deze klasse wordt (cid:1)P
2 genoemd. Ook
(cid:1)P
de lexicogra(cid:12)sch kleinste
"
vervulling van een formule is oneven".

2 heeft volledige problemen. Een bekend voorbeeld is ODDMINSAT,

Als we een algoritme voor een beslissingsprobleem hebben, dan willen we ook wel graag een
oplossing in handen hebben (dit wordt het
witness probleem" genoemd). Ook hier is er bij de
"
meeste NP-volledige problemen een eenvoudig verband aan te geven. De meeste NP-volledige
problemen zijn zelfreduceerbaar, dwz. terug te voeren op kleinere instanties van zichzelf. Uit zo’n
zelfreductie kunnen we een algoritme bouwen die ons een oplossing in handen geeft. We geven een
paar voorbeelden.

1. SATISFIABILITY. Stel we hebben een algoritme die een antwoord kan geven op de vraag
of een formule F (x1; x2; : : : ; xn) vervulbaar is. F is alleen vervulbaar als F (0; x2; : : : ; xn)
vervulbaar is of F (1; x2; : : : ; xn) vervulbaar is. Een hypothetische beslissingsalgoritme voor
SATISFIABILITY kan nu recursief gebruikt worden om een vervulling te vinden door de ver-
vulbaarheid van F (1; x2; : : : ; xn) en/of F (0; x2; : : : ; xn) te beslissen en het antwoord hierop te
gebruiken voor verdere recursieve aanroepen. De onderstaande algoritme vindt een vervulling
voor een vervulbare formule F (x1; : : : ; xn). Om de notatie eenvoudiger te maken nemen we
aan dat we in F een bitstring s kunnen invullen, en dat F (s) betekent F met xi gelijk aan het
ide bit van s. Verder is s0 de bitstring s met aan het einde een 0 geplakt en s1 de bitstring s
met aan het einde een 1 geplakt. De aanroep SAT(F;;); Het diepste niveau van de recursie
drukt een bitstring van lengte n af die een vervulling voorstelt.
1: function SAT(F , s)
2: if jsj < n then

3:
4:
5:

6:
7:

if F (s0) 2 SAT then

SAT(F ,s0);

else

end if

SAT(F ,s1);

154

8: else
9:
10: end if

print(s);

2. VERTEX COVER. Bij dit probleem merken we op dat van elk tweetal punten dat door een
kant verbonden wordt, tenminste (cid:19)e(cid:19)en in een VERTEX COVER zit. De recursieve aanroep
van de procedure kiest dus (cid:19)e(cid:19)en van die punten en vraagt of de graaf zonder dat punt een
VERTEX COVER heeft die (cid:19)e(cid:19)en punt minder bevat. In de onderstaande algoritme is G(cid:0)fvg
de graaf G waaruit het punt v en alle kanten die v als eindpunt hebben verwijderd zijn. De
algoritme vindt dan een verzameling van k punten die een vertex cover van G zijn, als we
beginnen met een G die inderdaad zo’n VERTEX COVER heeft.

1: procedure VC(G, k)
2: if G has edges then
3:
4:
5:
6:
7:
8: end if

Choose an edge (v; w) in G;
if (G (cid:0) fvg; k (cid:0) 1) 2 VERTEXCOVER then
print(v); VC(G (cid:0) fvg; k (cid:0) 1);
elseprint(w); VC(G (cid:0) fwg; k (cid:0) 1);
end if

3. HAMILTON CIRCUIT. Stel we kiezen een kant e in G. Ofwel de graaf G (cid:0) feg heeft nog
steeds een Hamilton circuit ofwel G (cid:0) feg heeft geen Hamilton circuit meer. In het tweede
geval (aangenomen dat G zelf wel een Hamilton circuit heeft, is e een kant in elk Hamilton
circuit en heeft G=feg|de graaf die ontstaat als we beide einpunten van e samentrekken
tot (cid:19)e(cid:19)en punt|weer wel een Hamilton circuit. Deze algoritme kunnen we gebruiken totdat
een graaf overblijft die klein genoeg is om het overgebleven Hamilton circuit te identi(cid:12)ceren
(bijvoorbeeld als G tot een driehoek gereduceerd is).

1: procedure HAM(G);
2: if G is bigger than a triangle then
3:
4:

Choose e in G
if G (cid:0) feg 2 HAMILTONCIRCUIT then

HAM(G (cid:0) feg);

print(e);
HAM(G=feg)

else

5:
6:
7:
8:
9:
10: else
11:
12: end if

end if

print(the edges in G);

Op deze wijze kunnen we voor vrijwel alle besproken problemen een recursieve algoritme vinden
die een certi(cid:12)caat produceert voor een instantie die tot het probleem behoort. In deze recursieve
algoritmen wordt echter telkens in een if statement het oplossen van een NP-volledig probleem
gevraagd. Omdat echter een certi(cid:12)caat wordt geproduceerd, kan deze if zelf echter weer vervangen
worden door een recursieve aanroep, waardoor een recursieve algoritme voor het beslissingsprobleem
zelf ontstaat. We nemen als voorbeeld VERTEX COVER. Nu is de aanroep VC(G; k) en de functie

155

VC geeft nu 0 of 1 terug als de ingevoerde graaf geen, resp. wel een Vertex Cover van grootte k
heeft.
1: function VC(G = (V; E); k)
2: if k (cid:21) jjEjj then return(1)
3: end if
4: if jjEjj > 0 then

5:
6:

Choose edge (v; w) in G
if VC(G (cid:0) fvg; k (cid:0) 1) then
else if VC(G (cid:0) fwg; k (cid:0) 1) then

return(1);

7:
8:
9:
10:
11:
12:
13: end if

else

end if

return(1);

return(0);

Een aldus verkregen recursieve algoritme voor een NP-volledig probleem moet altijd tenminste
twee recursieve aanroepen hebben, omdat anders het probleem in P terecht zou komen en we een
P=NP bewijs hebben. In sommige gevallen, zoals bijvoorbeeld in het geval van Traveling Sales Per-
son zien we zelfs meer dan (cid:19)e(cid:19)en recursieve aanroep. De meeste bekende NP-volledige problemen laten
op deze wijze een recursieve algoritme toe. De recursieve aanroepen zijn disjuncties. Als (cid:19)e(cid:19)en van
de recursieve aanroepen slaagt is het antwoord
ja". Bovendien kan het aantal aanroepen vaak tot
"
twee (maar niet tot minder) beperkt worden. We noemen deze speciale vorm van zelfreduceerbaar-
heid twee-disjunctieve zelfreduceerbaarheid. Het is helaas onbekend of misschien alle NP-volledige
problemen zelfreduceerbaar zijn. Omgekeerd is het wel bekend dat alle zelfreduceerbare problemen
in de grotere complexiteitsklasse PSPACE zitten.

6.5.3

Isomor(cid:12)e

De hierboven beschreven many-one reducties hebben vrijwel altijd de eigenschap dat ze 1-1 reducties
zijn. Dat wil zeggen dat (cid:19)e(cid:19)en instantie van het bronprobleem reduceert tot (cid:19)e(cid:19)en instantie van het
doelprobleem. Dat kunnen we eenvoudig inzien door te observeren dat we uit de geproduceerde
instantie gemakkelijk de instantie van het bronprobleem kunnen reproduceren (in feite kunnen we
zelfs meer, een certi(cid:12)caat voor het ene probleem leidt constructief tot een certi(cid:12)caat voor het andere
probleem; iets dat nodig is in het bewijs, maar niet noodzakelijk constructief hoeft te zijn). De
vraag, na het vinden van een groot aantal van deze problemen leidde al snel tot \Hebben we hier
niet steeds met hetzelfde probleem te maken?" BermanHartmanis78.

In feite merken we op dat er tussen alle hierboven behandelde NP-volledige problemen eenisomor(cid:12)e
bestaat. Doordat de problemen NP-volledig zijn, bestaan er al altijd reducties heen en weer, maar
we kunnen deze reducties uitbreiden tot isomor(cid:12)e(cid:127)en. Tot op de dag van vandaag is echter het
probleem of die isomor(cid:12)e(cid:127)en ook tussen alle NP-volledige problemen bestaan een open probleem.
Om dat in te zien beschouwen we het (eindige) probleem f1g. Neem een willekeurig probleem in
P. Gebruik de beslissingsroutine voor dat probleem en als het antwoord \ja" is, schrijf 1 en anders
0. We zien dat het probleem f1g volledig is voor P onder polynomiale reducties. Als het P = NP
is het dus ook volledig voor NP. SATISFIABILITY heeft oneindig veel instanties en kan dus nooit
isomorf zijn met f1g. Er volgt dat, als alle NP volledige problemen isomorf zijn, dat P 6= NP.

156

Cylinders

Natuurlijke problemen in NP hebben een polynomiale cylindri(cid:12)catie. Dat is het beeld van zo’n
probleem A gepaard aan de natuurlijke getallen onder een 1-1 inverteerbare afbeelding. Dat wil
zeggen een 1-1 inverteerbare afbeelding f : f0; 1g(cid:3) (cid:2) N 7! f0; 1g(cid:3) zodanig dat (8x)[x 2 A , 8n 2
Nf (x; n) 2 A].
voorbeeld voor SATISFIABILITY kun je hF (x1; : : : ; xn); mi afbeelden op

Er zijn voor cylindri(cid:12)catie (of cylinders) gemakkelijk verschillende voorbeelden te vinden. Bij-

F ^ (yn+1 _ yn+1) ^ yn+2 : : : ^ yn+m+1

met yi = xi als mi = 1 en yi = xi anders.

De heen en weer methode

Een hele oude methode om de isomor(cid:12)e tussen twee sets A en B aan te tonen is de heen-en-weer
methode van Cantor en Bernstein. Omdat die methode in de recursietheorie gebruikt is om de
isomor(cid:12)e van c.e. complete sets aan te tonen door Myhill, wordt deze methode ook wel de Cantor-
Bernstein-Myhill methode genoemd. Het idee is simpel. Neem aan dat er 1-1 inverteerbare functies
f en g bestaan tussen A en B gebruik dan f om A op f (A) af te beelden en g voor de rest B(cid:0) f (A).
Dat werkt natuurlijk niet meteen, want elke a 2 A heeft al een beeld in f (A) (cid:18) B, dus krijg je
verdubbeling. Daarom pas je f en g beurtelings toe, net zo lang tot je op een nog niet gebruikt
element van A of B terecht komt, en is de keten van f en g’s de afbeelding de A en B isomorf op
elkaar afbeeldt.

We zullen dat meer precies maken voor NP, maar daarvoor hebben we behalve 1-1 op nog (cid:19)e(cid:19)en
nieuw begrip nodig, de lengtevergrotende reductie. Een reductie f heet lengtevergrotend als voor
elke x geldt jf (x)j > jxj. Stel nu dat er tussen twee NP-volledige problemen lengtevergrotende 1-1
polynomiaal inverteerbare reducties f en g bestaan, dan kunnen we uit die reducties met de heen
en weer methode een isomor(cid:12)e constructeren als volgt. Voor (cid:19)e(cid:19)en of andere x is in principe f (x) het
beeld onder de isomor(cid:12)e, tenzij deze x nodig was omdat er een y bestaat zo dat x = g(cid:0)1(x) en y
zit niet in het beeld van f (wat blijkt uit het feit dat f(cid:0)1(y) niet bestaat, (cid:19)of uit het feit dat f(cid:0)1(y)
nodig was omdat een y0 niet in het beeld van f zat, en dus g(cid:0)1(f(cid:0)1(y)) gebruikt moet worden voor
de afbeelding van B naar A. Omdat f (cid:19)en g polynomiaal inverteerbaar en lengtevergrotend zijn,
is de keten van inversen die te berekenen is lengteverkleinend, en komt (dus) of op een gat, of bij
0 terecht. Een (eindige) aanvulling van de reducties die 0 aan beide kanten een beeld geeft is nu
genoeg om dit proces te doen eindigen.

isomor(cid:12)e en cylindri(cid:12)catie

Stel je voor dat we een NP-volledig probleem A en zijn cylinder C(A) hebben. Het beeld van het
probleem en zijn cylindri(cid:12)catie is een probleem in NP, en dus reduceerbaar naar een (ander) NP-
volledig probleem. Als de reductie tussen die problemen, polynomiaal inverteerbaar (en 1-1) is, dan
is die reductie \honest". Dat wil zeggen, voor zo’n reductie g geldt dat er een polynoom p is zodat
op elke invoer a geldt jaj (cid:20) p(jg(a)j), anders zou g niet polynomiaal inverteerbaar kunnen zijn. Nu
kunnen we een n 2 N nemen, die zo groot is dat voor elke a geldt jg(f (a))j > a en hebben we
door die samenstelling een lengtevergrotende inverteerbare reductie A 7! C(A) 7! B. Op dezelfde
manier kunnen we een lengtevergrotende inverteerbare reductie maken van B naar A en dus hebben
we de volgende stelling.

157

Alle NP-volledige problemen die een cylindri(cid:12)catie hebben, zijn isomorf.
De uitbreiding \Alle NP-volledige problemen zijn isomorf" is een conjecture, die bekend staat
onder de naam \Vermoeden van Berman en Hartmanis" en is tot op de dag van vandaag open voor
alle interessante complexiteitsklassen.

6.6 Sommen

1. Bewijs dat er deterministisch polynomiale tijd begrensde algoritmen bestaan voor

(a) 2-SAT. SATISFIABILITY van proposities in conjunctieve normaalvorm met hoogstens

twee optredens van variabelen per conjunctie.

(b) Graph 2-colorability. Is het mogelijk een graaf te kleuren met slechts twee verschillende

kleuren.

2. Bewijs de NP-volledigheid van de volgende problemen:

(a) naam: DUAL-SATISFIABILITY

gegeven: Een formule F (x1; : : : ; xn)
gevraagd: Zijn er minstens twee verschillende toewijzingen aan x1; : : : ; xn die F waar

maken?

(b) naam: DUAL-VERTEX COVER

gegeven: Een graaf G = (V; E) en een getal k
gevraagd: Zijn er tenminste twee verschilende verzamelingen V 0 (cid:18) V met jjV 0jj (cid:20) k

die allebei een vertex cover van G zijn?

(c) naam: HITTING SET

gegeven: Een stel verzamelingen getallen Si (cid:18) V en een getal k.
gevraagd: Is er een deelverzameling V 0 (cid:18) V met jjV jj (cid:20) k en jjV 0 \ Sijj (cid:21) 1 voor alle

i?

(d) naam: FEEDBACK VERTEX SET

gegeven: Een graaf G = (V; E) en een getal k.
gevraagd: Is er een deelverzameling V 0 (cid:18) V met jjV 0jj (cid:20) k zo dat elke cykel van G

tenminste (cid:19)e(cid:19)en knoop van V 0 raakt?

(e) naam: XXX

gegeven: Een collectie deelverzamelingen fSjgj van U = f1; : : : ; ng en twee getallen
gevraagd: Bestaat er een deelverzameling S = fui1; : : : ; uikg z(cid:19)o dat voor ‘ verschil-

k en ‘
lende j’s geldt Sj (cid:18) S?

(f) naam: YYY

gegeven: Een collectie deelverzamelingen fSjgj van U = f1; : : : ; ng en twee getallen
gevraagd: Bestaat er een deelverzameling S = fui1; : : : ; uikg z(cid:19)o dat alle j’s geldt

k en ‘
jjSj \ Sjj (cid:20) 1?

3. Van de onderstaande problemen zijn er drie in P en is er (cid:19)e(cid:19)en NP-volledig. Welke zijn dit?

(a) Gegeven een graaf G bestaat er een onafhankelijke verzameling van grootte 3?

158

(b) Gegeven een gerichte gewogen volledige graaf K = (V; A) en een getal k, is de som van

de gewichten der kanten in elk Hamilton circuit groter dan k?

(c) Gegeven een ongerichte graaf G = (V; E); bestaat er een V 0 (cid:26) V , z(cid:19)o dat alle kanten uit

E incident zijn met een knoop uit V 0?

(d) Gegeven een zoekboom horende bij een independent set probleem en een getal k; stelt
(cid:19)e(cid:19)en van de bladeren van de boom een onafhankelijke verzameling van meer dan k knopen
voor?

(e) Gegeven een graaf G = (V; E) en een getal k; bestaat de grootste onafhankelijke verza-

meling in G uit minder dan k knopen?

(f) Gegeven een collectie deelverzamelingen fSigi van U = fu1; : : : ; ung; bestaat er een

W (cid:18) U zo dat jjW \ Sijj = 1 voor alle i?

6.7 NP-problemen en de Praktijk

In de vorige sectie hebben we van een aantal problemen aangetoond dat ze NP-volledig zijn. Een
NP-volledigheidsbewijs voor een probleem wordt doorgaans gegeven om aan te geven dat een al-
goritmische aanpak van het probleem weinig zin heeft. In de praktijk echter kunnen we vaak niet
ervoor kiezen om een probleem maar te laten liggen als het algoritmisch moelijk blijkt te zijn. Een
NP-volledigheidsbewijs is dan ook veel meer een aanleiding om naar alternatieve oplossingen voor
het probleem te zoeken nu is gebleken dat zoeken naar een e(cid:14)ci(cid:127)ente algoritme voor het algemene
probleem waarschijnlijk hopeloos is. Een paar mogelijke uitwegen zijn.

1. Probeer een beperkte algoritme voor een speciaal geval van het probleem te vinden. Als
bijvoorbeeld het probleem het vinden van een kleuring is, en het probleem beperkt kan worden
tot planaire grafen, dan hoeft het probleem niet zo moeilijk te zijn.

2. Probeer een algoritme te vinden die in de meeste gevallen in polynomiale tijd werkt en al-
leen op een (zo klein mogelijk) deel van de mogelijke invoeren exhaustive search gebruikt (en
dus exponentieel is). Een bekend voorbeeld hiervan is de in de economie gebruikte simplex
algoritme voor lineair programmeren. Voor een lineaire functie in n variabelen zoekt men
een optimale waarde die voldoet aan een serie lineaire beperkingen. De lineaire beperkingen
kunnen in n dimensies gezien worden als een polytoop waarop de lineaire functie gede(cid:12)nieerd
is. Een extreme waarde wordt dan altijd aangenomen in (cid:19)e(cid:19)en van de hoekpunten van het poly-
toop. Een algoritme om het maximum te bepalen is dus van het ene naar het andere hoekpunt
lopen om te kijken waar het maximum wordt aangenomen. Dit is precies wat de simplexalgo-
ritme, met behup van een aantal lineaire transformaties, doet. De algoritme is eenvoudig te
implementeren en te begrijpen en voor kleine gevallen (niet teveel beperkingen) zelfs met de
hand makkelijk uit te voeren. Er zijn gevallen te construeren waarin de algoritme exponenti(cid:127)ele
looptijd heeft, maar deze komen in de praktijk niet voor. Daarom is deze methode, hoewel er
al lang een polynomiaal begrensde algoritme voor dit probleem bestaat [Kha80], nog steeds
in gebruik.

3. Probeer een algoritme te vinden die gebruik maakt van coin(cid:13)ips, z(cid:19)o dat die algoritme voor
alle inputs in de meeste gevallen in polynomiale tijd werkt. Sinds enige tijd is bekend dat
primaliteitstesten in polynomiale tijd kan [AKS04]. De algoritme hiervoor is echter nog niet

159

wijdverbreid ge(cid:127)(cid:16)mplementeerd, misschien ook omdat de snelste algoritmen hoewel polynomi-
aal nog steeds van vrij hoge graad zijn. Probabilistische algoritmen voor primaliteitstesten
als in deze tekst beschreven zijn wel wijdverbreid, gemakkelijk te implementeren en ruim
voorhanden. Daarom zijn deze, hoewel in principe exponentieel, nog steeds zeer in trek.

4. Probeer een algoritme te vinden die een suboptimale oplossing geeft. De problemen die we in
dit hoofdstuk besproken hebben zijn alle beslissingsproblemen. Bestaat er, is er etc. Nauw
verwant met deze problemen zijn de optimaliseringsproblemen. Wat is de kortste route door
een volledige gewogen graaf langs alle punten, wat is de verzameling objecten in de knapsack
die het grootste gewicht kleiner dan b geeft, wat is de kleinste verzameling knopen die een
vertex cover van de graaf geeft etc. Het is duidelijk dat als het optimaliseringsprobleem
polynomiale tijd begrensd is, dat dan ook het beslissingsprobleem polynomiale tijd begrensd
is en omgekeerd (via binary search). Echter als het beslissingsprobleem moelijk is, dan hoeft
het niet altijd zo te zijn dat het optimaliseringsprobleem ook moelijk is. Mits niet gevraagd
wordt naar de beste oplossing, maar bijvoorbeeld naar een acceptabele oplossing.

6.7.1 SAT, KNAPSACK, en VC

Soms bestaan er eenvoudige gulzige algoritmen die weliswaar niet een optimaal resultaat geven,
maar toch een resultaat in de buurt van een oplossing. We hebben al eerder gezien dat SAT met
twee variabelen per zin een probleem in P is geworden, net zoals bijvoorbeeld tweekleurbaarheid. De
NP-volledige variant van SAT, die met meer variabelen per zin, heeft weliswaar geen polynomiale
algoritme, maar met een eenvoudige deterministische algoritme kan toch een verrassend resultaat
behaald worden. Neem een SAT formule van m zinnen. Elke toewijzing van waarheidswaarden
vervult een fractie van die zinnen. Als de formule vervulbaar is, dan is er minstens (cid:19)e(cid:19)en toewijzing
die ze allemaal vervult. Er is een deterministische algoritme die tenminste de helft van het maximaal
aantal vervulbare zinnen vervult. Als volgt: Als x1 = 1 meer dan de helft van de zinnen waarin x1
voorkomt vervult, zet dan x1 = 1, anders zet x1 = 0. Schrap alle zinnen die aldus waargemaakt
zijn en ga door met x2.

Voor 3SAT is de situatie nog interessanter dan voor SAT. Als je maar 3 variabelen per zin hebt,
dan is er maar 1 van de 8 mogelijke toewijzingen van waarheidswaarden aan die variabelen, die
die zin onwaar maakt. Dat betekent dat de kans dat een random toewijzing de zin waarmaakt 7/8
is. Wegens het feit dat de verwachtingswaarde een lineaire functie is, maakt dit dat de verwach-
ting dat een willekeurige toewijzing van waarheidswaarden fractie waargemaakte zinnen door een
willekeurige toewijzing van waarheidswaarden 7/8 is.

Voor Vertex Cover bestaat ook simpele algoritme. Begin met een lege verzameling VC. Neem
een willekeurige kant, stop beide eindpunten in VC en schrap vervolgens deze kant en alle kanten die
in die eindpunten uitkomen. Ga verder totdat de graaf geen kanten meer heeft. De geproduceerde
verzameling VC bestaat uit een verzameling eindpunten van losse kanten, een matching. Omdat
elke vertex cover (ook de minimale) van elke kant tenminste (cid:19)e(cid:19)en eindpunt heeft, zit precies de helft
van alle punten in VC ook in de minimale vertex cover (maar mogelijk meer) VC is dus een vertex
cover die hoogstens twee keer zo groot is als de minimale.

Hoewel Vertex Cover en Independent Set heel gemakkelijk tot elkaar te reduceren zijn, kunnen
we een benaderingsalgoritme voor Vertex Cover niet gebruiken om een benadering van Independent
Set te verkrijgen. Stel dat we een VC kunnen krijgen die (cid:26) te slecht is, dus voor zekere (cid:26) > 1
krijgen we in een graaf met n knopen een vertex cover van (cid:26)K als er een vertex cover van K in
zit. Als in een graaf van n knopen een IS van groote M zit, dan zit er in die graaf een VC van

160

6

4

(cid:15)

3

1

(cid:15)

(cid:15)

3

1

(cid:15)

(cid:15)

3

1

6

(cid:15)

(cid:15)

2

(cid:15)

5

(cid:15)

2

(cid:15)

(cid:15)O

2

(cid:15)

Figuur 6.10: Van graaf naar TSP cykel

grootte n (cid:0) M . Een (cid:26) slechte benaderingsalgoritme zou dan een VC van grootte (cid:26)(n (cid:0) M ) geven,
die weer een IS van grootte n (cid:0) (cid:26)(n (cid:0) M ) zou geven. Hieraan zie je niet alleen dat M minstens
een ((cid:26) (cid:0) 1)=(cid:26)) fractie van n moet zijn om ueberhaupt een garantie van meer dan 0 knopen in de
independent set te krijgen, maar bovendien dat de verkregen benaderingsfractie afhangt van n. Er
kan worden bewezen, maar valt buiten deze tekst, dat voor independent set niet een dergelijke
benaderingsalgoritme kan bestaan, tenzij P=NP.

We hebben voor KNAPSACK al gezien dat, als b klein is, een polynomiale algoritme gemaakt
kan worden met behulp van dynamic programming. Deze zelfde algoritme kan gebruikt worden om
een benadering van de optimale waarde in polynomiale tijd te krijgen. We de(cid:12)nieren eenvoudig een
getal K = (cid:15)W=n waar W het maximale gewicht van alle objecten is, delen vervolgens alle waarden
in het probleem door K en voeren de dynamic programming algoritme uit. Deze levert een optimale
waarde O op die hoogstens een factor (cid:15) slechter is dan die van het oorspronkelijke probleem.

6.7.2 Een benadering voor TSP

Een probleem dat zowel onder de eerste als de laatste categorie hierboven valt is het handelsrei-
zigerprobleem. Het algemene geval van het handelsreizigerprobleem is moeilijk, NP-volledig. In
de praktijk hebben we echter vrijwel altijd te maken met een speciaal geval van het handelsreizi-
gerprobleem, namelijk het probleem dat zich afspeelt op een kaart, de Euclidische versie van het
probleem. Dit probleem heeft doorgaans de eigenschap dat de driehoeksongelijkheid geldt. De som
van de afstanden van A naar B en van B naar C is altijd groter dan of gelijk aan de afstand van A
naar C. Op een graaf waar de driehoeksongelijkheid geldt, kunnen we met behulp van een algoritme
voor een bekend probleem een polynomiale tijd algoritme geven voor het handelsreizigerprobleem
die nooit slechter is dan tweemaal de optimale route voor het echte probleem. De algoritme die we
gebruiken is (cid:19)e(cid:19)en van de algoritmen voor de opspannende boom van minimale kosten en gaat als
volgt.

1: input een volledige gewogen graaf K waarin de driehoeksongelijkheid geldt.
2: Bereken een opspannende boom van K.
3: Verdubbel alle kanten.
4: Begin een cykel in een kant en loop telkens naar de volgende knoop en markeer deze als \be-

zocht".

5: Sla in de cykel reeds bezochte knopen over door naar de volgende knoop te springen. Daarbij
verwijderen we de twee kanten in de opspannende boom en vervangen deze door (cid:19)e(cid:19)en kant uit
K. Zonodig wordt deze operatie herhaald uitgevoerd.
Figuur 6.10 geeft een voorbeeldje van de transformatie van graaf naar spanning tree naar cykel.

161

O
(cid:31)
(cid:31)
(cid:31)
(cid:31)
o
o
6.7.3 Branch en Bound

Het doorzoeken van alle mogelijke oplossingen voor een NP-volledig probleem komt vaak neer op
het doorzoeken van een exponentieel grote boom. Bijvoorbeeld het zoeken van een oplossing voor
SATISFIABILITY kunnen we opvatten als een boom doordat we zeggen dat we eerst voor de waarde
x1 = 0 alle mogelijke oplossingen voor x2; : : : ; xn proberen om vervolgens voor alle oplossingen bij
x1 = 1 alle oplossingen voor x2 t.e.m. xn proberen. We reduceren als het ware het oplossen
van het probleem SATISFIABILITY tot het oplossen van twee eenvoudiger problemen, dat wil
zeggen problemen met minder variabelen. Zulke problemen zijn onder de NP-volledige problemen
zeer talrijk. We noemen dit soort problemen zelf-reduceerbaar (zie 6.5.2). We kunnen ze oplossen
door het antwoord te zoeken op problemen van dezelfde soort maar van kleinere omvang. Dit
soort problemen leent zich uiteraard expliciet voor recursieve programma’s, al kost zo’n recursief
programma in het onderhavige geval natuurlijk wel exponenti(cid:127)ele tijd.

In het geval van optimaliseringsproblemen kunnen we misschien wat aan die exponenti(cid:127)ele tijd
doen, omdat we, althans in de meeste gevallen, niet de gehele zoekruimte hoeven te doorlopen.
Als voorbeeld nemen we weer het handelsreiziger probleem. Hoe is het handelsreizigerprobleem
zelfreduceerbaar? We bespreken twee methoden. Allereerst moeten we van elke stad naar een
andere stad totdat een rondje gemaakt is. Om een stad te bezoeken hebben we de keuze uit elk van
zijn buren. Kiezen we een buur, dan betekent dat dat we alle andere buren niet kiezen (behalve
op de terugweg natuurlijk). Als we kiezen voor b als buur van a dan betekent dat dat de minimaal
mogelijke tour met het gewicht van de kant (a; b) toeneemt. Als we zo een aantal kanten gekozen
hebben weten we dus dat de minimale tour langs die kanten groter dan of gelijk is aan de som van
de gewichten van die kanten. De branch heuristiek laat ons telkens kiezen de knoop in de zoekboom
verder te ontwikkelen waarvoor deze waarde minimaal is. Hebben we op deze manier eenmaal
n (cid:0) 2 knopen gekozen, dan ligt de laatste knoop in het rijtje vast en kunnen we de lengte van de
gekozen tour uitrekenen, de bound heuristiek zegt dan dat geen enkele knoop in de boom waarvan
de minimaal te verwachten waarde groter dan of gelijk is aan de waarde van zo’n complete tour
verder uitgewerkt moet worden. Op deze manier voorkomen we in veel gevallen dat we de complete
boom moeten doorzoeken. Aangezien alle mogelijke paden nog steeds in de boom voorkomen, is de
worst-case complexiteit van deze aanpak echter nog steeds n!.

Voorbeeld 6.7.1: Stel een afstandstabel tussen vijf steden is als volgt gegeven:

A B C D E
20
-
A
17
5
B
C 14
5
4
D 1
E
2
-

3
1
19
-
19

16
6
-
1
1

3
-
4
2
1

De branch & bound algoritme die we hierboven hebben beschreven produceert dan de volgende
zoekboom:

162

9

5

7

3

E

E

20

8

B

4

D

5

C

A

C

16

3

20

11

22

B

C

18

E

37

14

14

8

E

20

C

18

E

E

8

B

28

D

9

C

B

33

28

14

C

E

D

35

34

12

23

We behandelen aan de hand van dit voorbeeld nog een andere methode om branch & bound
te spelen met het handelsreizigerprobleem.
In plaats van dat we telkens een buur van een stad
kiezen kunnen we voor elke kant kiezen dat die wel of geen deel uitmaakt van een rondje. Dat
heeft voor- en nadelen. Aan de ene kant wordt de breedte van de zoekboom kleiner (er zijn twee
keuzemogelijkheden), aan de andere kant is de algoritme wat ingewikkelder. We nemen hetzelfde
voorbeeld. De wel/niet keuze voor de kanten laten we langs de rijen lopen (dus eerst kant (A,B),
dan (A,C) etc. De keuze voor kant (A,B) in het rondje sluit onmiddellijk de kanten (A,C), (A,D),
en (A,E) uit en maakt de minimaal te bereiken tour tenminste 3, de keuze tegen (A,B) sluit (A,B)
uit en maakt de minimaal te bereiken tour ook 3, maar nu omdat dat het minimum gewicht van
de kanten (A,C), (A,D), en (A,E) is. Als vier kanten zijn opgenomen is de vijfde verplicht en de
lengte van de tour bekend. De diepte van de boom kan nu echter groter zijn dan 4, omdat negatieve
keuzen zijn opgenomen. We laten steeds de linkertak de positieve keuze voor de kant zijn en de
rechtertak de negatieve keuze. We krijgen dan de volgende zoekboom:

AB

3

3

4

3

28

14

4

BC

9

CD

34

12

BD

DC

9

24

5

AC

16

BE

20

AD

3

AE

20

1

1

163

Ook hier zien we (gelukkig) dat de optimale route lengte 12 heeft en langs de kanten AB, BD,
DC (en CE, en EA) voert. Ook krijgen we hier een werkelijke verbetering van de worst-case com-
plexiteit. Als er n knopen in de graaf zijn, zijn er namelijk O(n2) kanten. Dat betekent dat onze

algoritme een worst-case complexiteit heeft van O(2n2
lijke verbetering ten opzichte van O(n!).

) nog steeds aanzienlijk, maar een opmerke-
2

De oplettende lezer zal hier opmerken dat de eerder besproken A(cid:3) algoritme (zie 3.2) niet veel

meer is dan het toepassen van het Branch & bound principe op kortste paden in grafen.

164

Deel III

Extra Onderwerpen

165

In dit deel van de tekst behandelen we een aantal onderwerpen die te maken hebben met
geheugencomplexiteit van problemen. Geheugencomplexiteit is een andere belangrijke maat voor
de complexiteit van algoritmen en problemen, maar de onderwerpen die de tijdcomplexiteit betre(cid:11)en
vullen doorgaans een inleidende cursus geheel. Als er tijd over is omdat bijvoorbeeld aan het begin
wat sneller gegaan kan worden als het publiek wat meer voorkennis heeft zouden deze onderwerpen
niettemin aan bod kunnen komen. Ook valt te denken aan het bestuderen van deze onderwerpen
achteraf in het kader van zelfstudie. In dit deel zijn vooralsnog geen sommen opgenomen.

167

168

Hoofdstuk 7

Meer Complexiteitsklassen

In dit hoofdstuk zullen we een aantal complexiteitsklassen bespreken die niet onmiddellijk onder-
werp zijn in een inleidende cursus Algoritmen en Complexiteit. Tijd is een belangrijke complexi-
teitsmaat, maar er is natuurlijk ook nog een aantal andere maten van complexiteit die we aan
algoritmen kunnen meten. Geheugencomplexiteit is daar (cid:19)e(cid:19)en van, maar ook de grootte van circuits
die nodig is om een probleem aan te pakken is een belangrijke complexiteitsmaat in het kader van
de afmetingen van special purpose hardware. De diepte van een circuit (langste pad in een graaf)
is een maat voor de parallelle complexiteit van een probleem, of de mate waarin een algoritme
voor een probleem wel of niet geparallelliseerd kan worden. In Hoofdstuk 6 hebben we gezien dat
we de moelijkheid van problemen kunnen aantonen door reductie van een NP-volledig probleem.
Voor parallellizeerbaarheid is een soortgelijk gereedschap voorhanden. We kunnen de inherente
sequentialiteit (ontmoediging voor het zoeken naar parallelle algoritmen) door een reductie van een
circuitprobleem te geven die dan niet in polynomiale tijd, maar in logarithmisch begrensd geheugen
is uit te voeren. Zo een reductie toont de P-volledigheid van een probleem aan. Veel van deze
reducties kunnen gevonden worden in het boek [GHR95]. Vooralsnog bespreken we dit onderwerp
niet in deze tekst.

7.1 Geheugenbegrensde Klassen

Als tegenhanger van Polynomiale tijd in het domein van de geheugenbegrensde theorie bekijken
we Polynomiaal geheugen, PSPACE. Het is duidelijk dat alles dat in polynomiaal begrensde tijd
kan ook in polynomiaal begrensd geheugen kan. Immers, een Turing machine kan in (cid:19)e(cid:19)en stap niet
meer dan (cid:19)e(cid:19)en nieuwe geheugencel aanspreken. Aan de bovenkant is polynomiaal begrensd geheugen
begrensd door exponenti(cid:127)ele tijd. Dit is in te zien door naar het Turing machinemodel te kijken. Een
standaard Turingmachine wordt op (cid:19)e(cid:19)en bepaald moment in de tijd geheel beschreven door de inhoud
van de band op dat moment, de toestand waarin de Turingmachine zich op dat moment bevindt,
en de plaats waar de tapekop op dat moment op de band staat. Laat het bandalfabet f0; 1g zijn,
het toestandsalfabet Q en het aantal cellen op de band begrensd door het polynoom p, d.w.z. voor
(cid:19)e(cid:19)en of andere n kunnen nooit meer dan p(n) cellen in gebruik zijn, dan volgt dat er niet meer dan
jjQjj (cid:2) p(n) (cid:2) 2p(n) van dit soort beschrijvingen bestaan. Een exponenti(cid:127)ele tijd begrensde machine
kan van de begincon(cid:12)guratie een voldoende aantal van deze con(cid:12)guraties doorrekenen om erachter
te komen of onderweg een accepterende toestand bereikt wordt. Na hoogstens jjQjj (cid:2) p(n) (cid:2) 2p(n)

169

moet zo’n toestand immmers bereikt worden, of de machine raakt in een (oneindige) loop.

7.2 PSPACE

De natuurlijke tegenhanger van P in het geheugenbegrensde domein is de klasse van problemen die
kunnen worden opgelost door Turingmachines waarbij het geheugengebruik begrensd wordt door
een polynoom in de lengte van de invoer. Deze klasse noemen we PSPACE. Zoals hierboven be-
argumenteerd geldt P (cid:18) PSPACE en PSPACE (cid:18) EXP, maar omdat ook geldt P 6= EXP (zie 6.1)
geldt niet \P = PSPACE en PSPACE = EXP". E(cid:19)en van de twee inclusies moet een ongelijkheid
zijn, maar welke van de twee is (cid:19)e(cid:19)en van de grote open problemen van onze tijd. Voor polynomiaal-
begrensde geheugencomplexiteit geldt echter wel invariantie onder nondeterminisme. Er is dus geen
P = NP? probleem in de geheugencomplexiteit, ofwel NPSPACE bestaat niet als aparte entiteit,
zoals de volgende stelling tot uitdrukking brengt.

Stelling 7.2.1 PSPACE = NPSPACE.

Om deze stelling te bewijzen merken we op, net zoals in het bewijs van PSPACE (cid:18) EXP dat
als een geheugenbegrensde Turing machine een accepterende berekening heeft, er een exponentieel
begrensde verzameling polynomiaal begrensde momentopnames van deze Turing machine moet
zijn die achter elkaar gezet zo’n accepterende berekening vormen. Anders is er een cykel en zal
de Turing machine niet accepteren. Voor een nondeterministische machine is dit argument een
fractie subtieler. Als er een accepterende berekening bestaat die langer is dan een vantevoren te
geven exponentieel aantal momentopnames, dan zit daar een cykel in, en is er dus ook een kortere
accepterende berekening (waar die cykel niet in zit). De kortste accepterende berekening zal geen
cyckel hebben en minder dan exponentieel veel momentopnames bevatten.

Stel dus er is een exponenti(cid:127)ele verzameling C1; : : : ; C2p(n) momentopnames ieder van lengte hoog-
stens p(n) die samen accepterende berekening van machine M op invoer x vormen. We beweren dat
het bestaan van zo’n verzameling kan worden berekend door een polynomiaal geheugenbegrensde de-
terministische machine M0, ofwel dat van elke nondeterministische polynomiaal geheugenbegrensde
machine M en invoer x door een deterministische polynomiaal geheugenbegrensde machine M0 kan
worden bepaald of M0 de invoer x kan accepteren.

Merk op dat een verzameling C1; : : : ; C2p(n) bestaat, als en alleen als er een C2p(n(cid:0)1) bestaat,
zo dat C1; : : : ; C2p(n(cid:0)1) een legitieme opeenvolging van momentopnames van M op invoer x is en
C2p(n(cid:0)1); : : : ; C2p(n) een legitieme opeenvolging van momentopnames van M op invoer x is. We
gebruiken deze observatie voor de de(cid:12)nitie van de volgende recursieve procedure.
1: Procedure Comp(C1,C2,n).
2: if n = 0 then
3:
4:
5:
6:
7:
8: else
9:
10: end if

return(Wf[Comp(C1; Ck; n (cid:0) 1) ^ Comp(Ck; C2; n (cid:0) 1)] : Ck a legal con(cid:12)guration of Mg)

if C2 is a legal successor of C1 according to M then

return(0);

return(1);

end if

else

170

Door deze routine aan te roepen met Comp(C0; Cacc; p(n)) kunnen we beslissen of er een accep-
terende berekening bestaatn van 2p(n) momentopnames. Vooropgesteld dat de recursieve boom in
deze algoritme verstandig doorlopen wordt, kan ze geheel in polynomiaal begrensd geheugen worden
uitgevoerd. Immers, elke Ck in regel 9 is slechts p(n) groot, en verder is de recursiediepte begrensd
door p(n), zodat de totale berekening kan worden uitgevoerd in O(p2(n)) begrensd geheugen.

7.2.1 Volledige Problemen

Ook voor PSPACE zijn er volledige problemen bekend. De meeste zijn zogenoemde two person
perfect information games. Een master probleem voor PSPACE is het acceptatieprobleem van
een lineair begrensde Turing machine, het model voor het herkennen van context sensitieve talen.
Het eerste, meest bekende, karakterizerende probleem voor PSPACE is echter dat van de logische
predikaten, quanti(cid:12)ed boolean formulae (QBF).

naam: QBF
gegeven: Een gekwanti(cid:12)ceerde logische formule P = Q1Q2 : : : QnF (x1; : : : ; xn), met Qi 2

f9;8g.

gevraagd: Is P waar?

De eerste stap is, is QBF een probleem in PSPACE? Dat is iets minder makkelijk dan de
vergelijkbare stap voor NP-volledige problemen, maar ook weer niet heel erg moeilijk.
Immers
wanneer is P = Q1Q2 : : : QnF (x1; : : : ; xn) waar? Dat hangt van Q1 af. Als Q1 = 8, dan is P waar
d.e.s.d.a. Q2; : : : ; QnF (0; x2; : : : ; xn) waar is en Q2; : : : ; QnF (0; x2; : : : ; xn) waar is, en als Q1 = 9
dan is P waar d.e.s.d.a. Q2; : : : ; QnF (0; x2; : : : ; xn) waar is of Q2; : : : ; QnF (0; x2; : : : ; xn) waar is.
De volgende procedure beslist dus of een predicaat waar is.
1: Procedure QBF(Q1 : : : QnF (x0; : : : ; xn))
2: if Q1 = 8 then
4: else if Q1 = 9 then

return(QBF(Q2 : : : Qn(F (0; x2; : : : ; xn) ^ Q2 : : : Qn(F (0; x2; : : : ; xn))
return(QBF(Q2 : : : Qn(F (0; x2; : : : ; xn) _ Q2 : : : Qn(F (0; x2; : : : ; xn))

3:

return(F (x1; : : : ; xn)) //no quanti(cid:12)ers left, all x have values.

5:
6: else
7:
8: end if

De recursiediepte is n, en elk element op de stapel van de aanroepen kan in polynomiaal geheugen

worden opgeslagen. Het geheugengebruik is dus ongeveer kwadratisch, en dus zeker polynomiaal.

Dat elk probleem dat door een Turing machine kan worden opgelost vertaald kan worden naar
een QBF die waar is als en alleen als de invoer geaccepteerd wordt zien we aan de hand van
het eerder gegeven bewijs voor PSPACE (cid:18) EXP. Een momentopname van een Turingmachine
kan worden vertaald naar een logische formule zoals we hebben gezien in 6.5. Twee con(cid:12)guraties
kunnen naar een logische formule vertaald worden die alleen een vervulling heeft als de twee con(cid:12)-
guraties legale opvolgers zijn van elkaar volgens het programma van de Turing machine. Laat Q0
een logische formule zijn die de begintoestand van M representeeert, en QF een logische formule
zijn die de eindtoestand representeerd. Laat verder S(F1(x1; : : : ; xn); F2(y1; : : : ; ym)) zo zijn dat
(9x1; : : : ; xn; y1 : : : ym)[S(F1(x1; : : : ; xn); F2(y1; : : : ; ym))] dan en slechts dan als F1(x1; : : : ; xn) en
F2(y1; : : : ; ym) voor deze x en y opeenvolgende of dezelfde momentopnames van M representeren.

171

We de(cid:12)nieren de formules Sk(P1; P2) voor predikaten met of zonder quantoren P1 en P2 als:

(cid:26)

Sk =

(9P3)[Sk(cid:0)1(P1; P3) ^ Sk(cid:0)1(P3; P2)]

S(P1; P2)

if k = 0
anders

De Turingmachine heeft een accepterende berekening van lengte 2n dan en slechts dan als
Sn(Q0; QF ). Helaas is dit nog niet een polynomiale tijd begrensde vertaling. Immers Sn is twee
keer zolang als Sn(cid:0)1 waardoor Sn lengte (cid:10)(2n) krijgt en dat mag niet in een polynomiaal begrensde
reductie. We merken echter op dat Sk(cid:0)1 twee keer gebruikt wordt, en dit kan worden beperkt tot
(cid:19)e(cid:19)en keer door een extra universele quantor te gebruiken als volgt.

(9P3)[(8P4P5)[Sk(cid:0)1(P4; P5) _ [(P4 6= P1 _ P5 6= P3) ^ (P4 6= P3 _ P5 6= P 2)]]

Als P1 = P4 en P3 = P5, dan moet Sk(cid:0)1(P4; P5) waar zijn, en dus ook Sk(cid:0)1(P1; P3). Hetzelfde
geldt voor P3 en P2. De reductie heeft nu nog maar (cid:19)e(cid:19)en optreden van de formule Sk(cid:0)1 en dus wordt
de uiteindelijke formule ook polynomiaal in lengte in de lengte van de invoer.

7.2.2 Andere PSPACE Volledige Problemen

Zoals we al hebben opgemerkt zijn veel van de bekende PSPACE volledige problemen varianten van
spelletjes, en wel de zogenoemde two person perfect information games. De intuitie hierbij is dat
deze spellen vaak de volgende vorm hebben. Er is een winnende strategie alleen als er een zet voor
speler 1 is, zodat voor elke zet van speler 2 er weer een zet voor speler 1 is zodat,... Kortom, deze
spelen hebben de structuur van QBF en het is dan ook niet verwonderlijk dat QBF vaak vertaald
kan worden naar de vraag

is er een winnende strategie" voor zo’n spel.
"

Het eerste spel dat we zullen bekijken wordt gespeeld op grafen en heet Generalized Geography.
Geography is een bekend spel dat vaak gespeeld wordt om de verveling te verdrijven gedurende
lange autoritten. De spelers mogen geogra(cid:12)sche namen (bijvoorbeeld steden) noemen die ergens
in de wereld voorkomen. Het gaat erom dat de volgende speler steeds een naam moet noemen die
begint met de letter waarmee de vorige naam ge(cid:127)eindigd is. De speler die geen nieuwe naam aan de
lijst kan toevoegen verliest.

We modeleren het spel met een gerichte graaf waarin de knopen alle stedennamen ter wereld
zijn, een kant gaat van stad A naar stad B als de naam van A eindigt met de letter waarmee de
naam van B begint. Een van de steden wordt als startpunt aangewezen. Er zijn twee spelers P1
en P2 en de vraag is heeft P1 een winnende strategie, d.w.z. kan zij voor elke strategie die P2 kan
hebben een verzameling knopen vinden zo dat P2 vastloopt. We geven een klein voorbeeld.

Voorbeeld 7.2.1:

172

Amsterdam

M uiden

M aastricht

N ijmegen

T egelen

N aarden

Voorbeeld van een mogelijk verloop van Geography.

2

Generalized Geography wordt gespeeld op een gerichte graaf met een speciale knoop start.
Speler 1 begint met het kiezen van een buur van start en om beurten kiezen spelers een buur van
een knoop die de vorige speler gekozen heeft. Als een speler gedwongen is een knoop met uitgraad
0 te kiezen, of een knoop die al eerder gekozen is, dan heeft zij verloren. Het probleem is nu.

naam: Generalized Geography
gegeven: Een gerichte graaf met startpunt s
gevraagd: Heeft Speler 1 een winnende strategie

We moeten eerst bewijzen dat GG in PSPACE zit. Daartoe geven we een simpele recursieve
algoritme die berekent of Speler 1 een winnende strategie heeft. Omdat elke knoop slechts (cid:19)e(cid:19)en keer
gekozen kan worden, en er eindig veel knopen in de graaf zitten heeft (cid:19)e(cid:19)en van beide spelers altijd
een winnende strategie. Een antwoord op de vraag dat een algoritme inhoudt is dus:
Speler 1 heeft
"
een winnende strategie, dan en slechts dan als Speler 2 dat niet heeft." We vertalen dit als volgt
naar een algoritme die de gegeven vraag onderzoekt op het bestaan van een winnende strategie.

1: GG(knoop)
2: if knoop has no outgoing edges then
3:
4: else if (8 neighbors n of knoop)GG(n)=reject then

return(reject)

return(accept)

return(reject)

5:
6: else
7:
8: end if

GG(start) onderzoekt of speler 1 vanuit de startknoop een winnende strategie heeft. Het is
duidelijk dat deze algoritme in polynomiale ruimte kan worden uitgevoerd en dus dat ons probleem
in PSPACE zit.

Vervolgens bewijzen we dat GG volledig is voor PSPACE. We doen dit door een reductie van
een spelvorm van QBF. Gegeven een formule met kwantoren Q1x1Q2x2 : : : QnxnF (x1; : : : ; xn) dan
maken we voor elke kwantor in de formule de volgende graaf.

173

(cid:15)
(cid:15)
’
’
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
o
o
w
w
Verder zijn er 2n knopen xi en xi voor de n variabelen en hun ontkenning, en m knopen voor
de zinnen. De zin knopen cj hebben uitgraad 3 en zijn verbonden met de variabele knopen of hun
ontkenning al naar gelang ze in de zin voorkomen. De zin cj knopen zijn via (cid:19)e(cid:19)en enkele enkele kant
verbonden met een keuzeknoop c. We geven weer een klein voorbeeld.
Voorbeeld 7.2.2: Laat gegeven zijn de formule (9x18x29x3)[(x1 _ x2 _ x3) ^ (x1 _ x2 _ x3)]. De
reductie hierboven gegeven vertaalt dit naar de volgende graaf.

s

c1

c2

c

x1

x1

x2

x1

x2

x3

174

(cid:127)
(cid:127)
(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:127)
(cid:127)
(cid:1)
(cid:1)
(cid:29)
(cid:29)
(cid:8)
(cid:8)
(cid:29)
(cid:29)
(cid:1)
(cid:1)
o
o
‘
‘
o
o
~
~
(cid:15)
(cid:15)
(cid:1)
(cid:1)
(cid:0)
(cid:0)
(cid:30)
(cid:30)
W
W
(cid:7)
(cid:7)
(cid:29)
(cid:29)
(cid:1)
(cid:1)
X
X
(cid:15)
(cid:15)
e
e
‘
‘
o
o
~
~
(cid:127)
(cid:127)
(cid:31)
(cid:31)
(cid:9)
(cid:9)
 
 
~
~
L
L
Eerst stellen we even vast dat het predicaat in dit voorbeeld waar is. Immers als je x3 waar kiest,
dan doet het er niet toe wat de andere twee variabelen voor waarde aannemen. Dus P1 moet een
winnende strategie hebben. De strategie is als volgt. P1 kiest in de deelgrafen die een existenti(cid:127)ele
kwantor vertegenwoordigen, de waarde van de variabele die zij waar wil maken om het predicaat
waar te krijgen. P2 kiest in de deelgrafen de waarde van de variabele die zij onwaar wil maken om
het predicaat onwaar te krijgen. P1 begint, door voor x1 linksaf te gaan (waar) of rechtsaf te gaan
(onwaar). In dit speciale geval doet dat er niet toe. Wat P2 bij de volgende deelgraaf doet, doet
er niet toe. P1 moet vervolgens bij de laatste deelgraaf wel linksaf slaan. P1 kiest gedwongen de
knoop c, en P2 kan nu (cid:19)e(cid:19)en van de zinnen kiezen door c1 of c2 te kiezen. Omdat de formule waar is,
doet het er in dit geval niet toe welke van de twee zij kiest. Als ze c1 kiest, dan moet vervolgens
Speler 1 een variabele kiezen die waar is. Als zij x1 waar gekozen heeft, dan kan zij knoop x1 kiezen,
als zij x1 echter onwaar gekozen heeft, dan kan zij de knoop x1 kiezen. In beide gevallen verliest
P2 omdat de volgende knoop reeds eerder gekozen is. Kiest P2 voor c2 dan kiest P1 vervolgens x3
2
en bereikt hetzelfde resultaat.

Een lange lijst van PSPACE volledige spelletjes bestaat. We noemen er een paar:

1. Amazons [Bur00, Hea05]

2. Go[LS80]

3. Hex [ET76]

4. Othello [IK94]

5. Rush Hour [FHN+03]

6. Shanghai [CFLS97]

7. Sokoban [Cul99]

De werkelijke lijst is nog veel langer. Behalve in de wereld van de spelletjes komen we PSPACE
volledigheid ook in de taalherkenning tegen. Naarmate een probleem meer uitdrukkingskracht
heeft wordt het computationeel ook moelijker. Programmeertalen worden vaak zoveel mogelijk
contextvrij gehouden omdat dat het compileren makkelijker maakt. Als voor de betekenis van een
statement niet de context uitvoerig hoeft te worden onderzocht kan worden volstaan met een one-
pass compiler of een interpreter. Natuurlijke talen zijn context-sensitief. Computationeel betekent
dit een sprong van polynomiaal beslisbaar voor contextvrije talen naar PSPACE-volledigheid voor
de context gevoelige talen.

Ook in de logica komen we PSPACE volledigheid op meer plaatsen tegen dan alleen in de
predicatenlogica. Veel van de logica’s die met modale of temporele kwantoren gede(cid:12)nieerd worden
zijn PSPACE volledig of soms nog complexer.

7.3 LOGSPACE

Zon beetje de kleinste klasse die we machinemodelonafhankelijk kunnen de(cid:12)ni(cid:127)eren is de klasse
van talen beslisbaar in (deterministische) logaritmische ruimte. Omdat de Stelling van Savitch,
hierboven, een O(n2) overhead heeft van deterministisch naar nondeterministisch, is er ook een

175

klasse NLOGSPACE van problemen beslisbaar in nondeterministisch logarithmische ruimte. Het
probleem NLOGSPACE ?= LOGSPACE is vooralsnog een open probleem, al zijn er deelresultaten
behaald [Rei05].

Wel is bekend dat NLOGSPACE gesloten is onder complementatie. Dat wil zeggen dat het
complement van elke context sensitieve taal zelf ook weer een context sensitieve taal is. Voor dit
probleem (dat 23 jaar open heeft gestaan) is in 1988 door N. Immerman [Imm88] en onafhanke-
lijk door R.Szelepscenyi [Sze87] een techniek ontwikkeld die sindsdien inductive counting genoemd
wordt. We geven hier een schets van het bewijs.

Stel we hebben gegeven van een nondeterministische machine M een momentopname (con(cid:12)-
guratie) c en we vragen ons af of een bepaalde con(cid:12)guratie d vanuit c bereikt kan worden. We
kunnen dan nondeterministisch een aantal tussencon(cid:12)guraties c1; c2; : : : ; ck met c1 = c, ck = d en
elke con(cid:12)guratie ci+1 is in (cid:19)e(cid:19)en stap vanuit ci te bereiken. Het aantal con(cid:12)guraties kan beperkt
blijven tot n als M een machine is die in LOGSPACE werkt. Stel dat we precies weten hoeveel con-
(cid:12)guraties vanuit c bereikt kunnen worden, en we willen bewijzen dat een con(cid:12)guratie d niet vanuit
c bereikt kan worden. Een nondeterministische machine kan dan het gegeven aantal verschillende
con(cid:12)guraties bepalen, bewijzen dat deze alle vanuit c bereikt kunnen worden en daarmee dus dat
d niet zo’n con(cid:12)guratie is.

Stel nu dat we willen bewijzen dat een invoer x niet geaccepteerd wordt door M in een
LOGSPACE begrensde berekening. We moeten dan bewijzen dat in LOGSPACE geen con(cid:12)guratie
met een accepterende toestand vanuit de begintoestand kan worden bereikt. We weten hoeveel
con(cid:12)guraties er vanuit de begintoestand in (cid:19)e(cid:19)en stap kunnen worden bereikt en we beweren (in-
ductie) dat we als we weten hoeveel verschillende con(cid:12)guraties uit de begintoestand in k stappen
bereikt kunnen worden, dat we dan ook weten hoeveel con(cid:12)guraties er in k + 1 stappen vanuit de
begintoestand bereikt kunnen worden.

Het bewijs voor deze bewering is de volgende methode. Gegeven dat er bijvoorbeeld i con(cid:12)gu-
raties in k stappen vanuit de begintoestand bereikt kunnen worden. Genereer achtereenvolgens al
deze con(cid:12)guraties en bewijs dat dit die con(cid:12)guraties zijn door voor elk van die con(cid:12)guraties k (cid:0) 1
tussencon(cid:12)guraties te raden, waartussen de overgang in (cid:19)e(cid:19)en stap kan gebeuren. Nu kunnen we voor
elk van die con(cid:12)guraties apart bepalen hoeveel opvolgers deze con(cid:12)guratie heeft, en daarmee dus
hoeveel con(cid:12)guraties in k + 1 stappen kunnen worden bereikt.

De machine die het complement van een gegeven machine M berekent, doet nu op invoer x het

volgende.

1: Bereken hoeveel mogelijke verschillende opvolgers de begincon(cid:12)guratie kan hebben in n stappen.
2: Genereer die con(cid:12)guraties (en bewijs dat het ze zijn)
3: if Geen van die con(cid:12)guraties accepterend is then
4:
5: else
6:
7: end if

Accepteer

Verwerp

7.3.1 Complete Problemen

Het generieke complete probleem voor nondeterministische logaritmische ruimte is het probleem
ST-connectivity.

naam: ST-CONNECTIVITY

176

gegeven: Een gerichte graaf met twee knopen S en T
gevraagd: Is er en pad van S naar T

Dit probleem kan in nondeterministisch logaritmische ruimte worden beslist. Immers, als de
graaf gegeven is, kan een Turingmachine beginnen met een 1 op de werkband en vervolgens een
getal S raden. Daarna controleert de machine dat S; i een kant is in de graaf. De ruimte ingenomen
door S kan vervolgens hergebruikt worden om een getal i2 te raden en te controleren dat i; i2 een
kant is in de graaf. Daarna kan de ruimte gebruikt voor i worden hergebruikt. Zo voortgaande kan
de nondeterministische machine uitkomen bij T als er een pad van S naar T bestaat en accpeteren.
Als zo’n pad niet bestaat, dan faalt deze aanpak uiteraard. Alle gebruikte getallen zijn kleiner
dan of gelijk aan het aantal knopen in de graaf, waardoor het gebruikte gegeugen begrensd is in
de logaritme van de afmetingen van de representatie van de graaf op de invoerband. Hiermee is
bewezen dat dit een probleem in LOGSPACE is.

Het probleem is echter ook LOGSPACE volledig. Om dit in te zien moeten we, gegeven een
nondeterministische logarithmisch geheugenbegrense machine M en een invoer x, een graaf G(M; x)
maken met twee knopen S en T , zodat T vanuit S bereikbaar is dan en slechts dan als M een
accepterende berekening heeft. Natuurlijk zijn de knopen van G(M; x) con(cid:12)guraties van M op
invoer x en is S de begincon(cid:12)guratie en T de eindcon(cid:12)guratie. Elke con(cid:12)guratie heeft maar een
paar mogelijke opvolgers, die door een deterministische logarithmisch geheugenbegrensde machine
kunnen worden berekend. We mogen echter niet de uitvoerband als geheugen gebruiken, omdat
deze groter dan logaritmisch wordt. Dit probleem kunnen we ondervangen door als representatie
van de output te kiezen voor de adjacency matrix. Elk van de getallen van 1 tot p(n) kan een legale
codering van een con(cid:12)guratie van M zijn (dat hoeft natuurlijk niet, maar dat is voor de berekening
van geen belang). De algoritme wordt:

1: for i = 1 to p(n) do
2:
3:

for j = 1 to p(n) do

if

i to j is a legal transition then
output 1;

else

4:
5:
6:
7:
8:
9: end for

end if

end for

output 0;

Deze algoritme output een serie 0en en 1en die een representatie van de adjacencymatrix van de
con(cid:12)guraties van M op invoer x is. Zonder beperking der algemeenheid kunnen we aannemen dat
hierin knoop 0 de begincon(cid:12)guratie van M voorstelt en knoop p(n) de eindcon(cid:12)guratie. De vraag
of M de invoer x accepteert is dan dezelfde als de vraag of vanuit knoop 0 knoop p(n) bereikt kan
worden. het geheugen dat nodig is, is slechts het geheugen voor de tellers i en j, dus zeker niet
meer dan logarithmisch begrensd geheugen.

7.4 Interactieve Bewijzen

De vraag wat een bewijs is, is een heel oude vraag in de (cid:12)loso(cid:12)e en misschien wel de reden waarom
de logica bedreven wordt. Kern van de zaak is dat de (cid:19)e(cid:19)en iets weet of denkt te weten, en dat zij de
ander daarvan probeert te overtuigen. Doorgaans is er sprake van regels om ervoor te zorgen dat
de bewijsvoering ordelijk verloopt. Een voorbeeld hiervan is elke willekeurige sport waar elk van

177

beide tegenstanders de ander (en mogelijk ook een publiek) ervan probeert te overtuigen sterker te
zijn. In sommige gevallen is er uiteraard ook geen sprake van regels, maar dan moeten achteraf de
regels van de samenleving worden toegepast, en de politie eraan te pas komen.

Onderdeel van de regels is doorgaans een stelsel van axioma’s. Dat zijn principes waarover
partijen vantevoren een akkoord sluiten om ervoor te zorgen dat er tenminste een basis voor een
gesprek is. Axioma’s zijn niet algemeen geldende principes, getuige bijvoorbeeld de axioma’s van
Euclides voor de meetkunde. Slechts voor het onderhavige bewijs (en misschien een heel stel
bewijzen) gelden ze als absoluut. Het spel bestaat eruit vanuit de axioma’s met gebruikmaking
van de regels te komen tot de uitspraak waarvan men de ander wil overtuigen. Dit spel heet dan
bewijzen" en het bewezene heet een stelling (of tautologie). Een groot probleem vormt het in
"
de hand houden van de bewijsdrift. Hoeveel bewijs moet geleverd worden om de tegenstander
te overtuigen? Vooral wanneer de stelling interessant is, dan kan de lengte van het bewijs nogal
uit de hand lopen. Tre(cid:11)ende voorbeelden hiervan zijn het bewijs van de vierkleurbaarheid van
planaire grafen van Appel en Haken [AH77a, AH77b], Het bewijs van Robertson en Seymour over
graaf minoren [RS83, RS04], en het bewijs van Wiles van de stelling van Fermat[CSS97]. Het
probleem is het vinden van een trade-o(cid:11) tussen de mate van overtuigd raken van de waarheid van
de tegenstander, en de inspanning die de tegenstander moet leveren bij het controleren van het
bewijs. Natuurlijk zijn ook hier omgevingsfactoren van invloed. Bij de controle van het bewijs van
de Stelling van Fermat is een schier onbegrensde inspanning ter controle gerechtvaardigd, maar bij
de pinautomaat geldt een gemakkelijk te dupliceren code van vier cijfers als bewijs van identiteit.
Van nature hebben bewijzen dus een interactief karakter. De meest eenvoudige vorm hiervan is
dat de ene partij het bewijs op het bord schrijft en de andere partij zegt
ja". Dit kan echter alleen
"
gedaan worden als het bewijs klein genoeg is om op een bord te schrijven. Anders worden delen van
het bewijs weggelaten en wordt het aan de andere partij gelaten over delen die zij niet begrijpt of
niet gelooft door te vragen. Als bewijzen klein genoeg zijn (in onze traditie polynomiaal van lengte)
dan geven we ze in (cid:19)e(cid:19)en keer. De hele actie van bewijs vinden en veri(cid:12)(cid:127)eren is dan een NP-proces
geworden. Als bewijzen langer (exponentieel langer) worden, dan moeten we teruggrijpen op het
presenteren van delen van het bewijs in een vraag antwoord spel. Zo’n bewijs is een echt interactief
bewijs.

7.5 Zero Knowledge

Een zeer bijzondere tak van sport wordt gevormd door de zogenoemde zero-knowledge bewijzen.
Het gaat er hierbij om een interactief bewijs te geven waarbij geen kennis over de aard van het
bewijs wordt overgedragen. Het protocol bestaat, zoals gebruikelijk in interactieve bewijzen uit een
serie uitdagingen en antwoorden, maar de antwoorden moeten altijd zo zijn dat de uitdager die
ook zelf had kunnen geven. De uitdager mag dus geen kennis kunnen ontlenen aan het gegeven
antwoord. Dat deze vorm van bewijzen van grote waarde is in het interactieve dataverkeer behoeft
nauwelijks betoog. Immers een afgeluisterde communicatie verschaft de a(cid:13)uisteraar bij dergelijke
protocollen per de(cid:12)nitie niet de informatie nodig om bij misleiding te gebruiken. Er zijn twee
soorten van deze zero knowledge protocollen. Er is de absolute zero-knowledge|ongeacht hoeveel
computing power de tegenpartij of a(cid:13)uisteraar heeft, zij zal nooit iets leren uit het protocol|en er
is de relatieve zero-knowledge|als we ervanuit gaan de dat de computing power van de tegenpartij
redelijk begrensd is, zij kan bijvoorbeeld geen NP-volledige problemen kraken, dan zal zij uit de

178

communicatie niets leren dat zij tot haar voordeel kan gebruiken.

Voorbeeld 7.5.1: Als voorbeeld geven we een voorbeeld van relatieve zero-knowledge, gebaseerd
op het HAMILTON CIRCUIT probleem. Zij gegeven een graaf G = (V; E). Speler 2 beweert dat
G een Hamilton circuit heeft en dat zij dat Hamilton circuit kent. Hoe zal zij speler 1 hiervan
overtuigen zonder het Hamilton circuit prijs te geven. Dit gaat als volgt. Speler 2 produceert een
random permutatie van G die zij vervolgens aan speler 1 stuurt. Deze heeft nu de keuze uit twee
uitdagingen waaruit zij random kiest (een andere strategie is alleen voordelig voor een leugenachtige
speler 2).

1. Uitdaging 1 is: produceer de permutatie die van G de graaf G0 maakt.
2. Uitdaging 2 is: geef een Hamilton circuit in graaf G0.

Als speler 2 inderdaad een Hamilton circuit kent, dan kan zij in daarvan een Hamilton circuit
in G0 construeren. Aangenomen dat speler 1 niet voldoende rekenkracht heeft om het, moeilijk
geachte, grafenisomor(cid:12)e probleem op te lossen, zal speler 1 niets leren over het Hamilton circuit
in G uit het antwoord op uitdaging 2. Uiteraard kan speler 1 ook niets leren uit het antwoord op
2
uitdaging 1. Een random permutatie van G had zij immers zelf ook kunnen maken.

Voorbeeld 7.5.2: Het in het vorige voorbeeld genoemde grafenisomor(cid:12)e probleem kan worden
gebruikt als identi(cid:12)catieprotocol als volgt. Speler 1 produceert een grote graaf G en een permutatie
van deze graaf G0. Aangezien grafenisomor(cid:12)e een moeilijk probleem is is het niet iedereen gegeven
de isomor(cid:12)e tussen G en G0 te berekenen, maar Speler 1 kent deze natuurlijk. Nu worden G en G0
tegenover Speler 2 gebruikt om Speler 1 te identi(cid:12)ceren als volgt. Speler 1 produceert een derde
graaf G00 die een permutatie van G of van G0 is (dat maakt voor beide spelers niets uit).

1. Uitdaging 1: Laat zien dat G00 isomorf is aan G.
2. Uitdaging 2: Laat zien dat G00 isomorf is aan G0.
Als Speler 1 inderdaad de isomor(cid:12)e tussen G en G0 kent, dan kan zij aan beide uitdagingen
voldoen. Als zij die niet kent, dan kan zij aan hoogstens (cid:19)e(cid:19)en van beide voldoen. Bij random
gekozen uitdagingen valt zij dus met kans 0:5 door de mand. Door herhaling van het protocol
kunnen we de kans op onontdekt bedrog zo klein maken als we maar willen.
Een geringe variatie op dit protocol geeft een alternatief voor het eerder besproken bit-commitment
probleem (zie 4.6.2). In dit geval is het Speler 2 die de grafen G en G0 maakt en Speler 1 produceert
een graaf G00 uit G als zij een 0 wil vastleggen en uit G0 als zij een 1 wil vastleggen. Deze G00 wordt
in handen van Speler 2 gegeven, die niet kan zien van welke de graaf afkomstig is. Immers G, G0 en
G00 zijn alle isomorf. Als de tijd komt om het bit te laten zien, kan Speler 2 de isomor(cid:12)e waarmee
G00 is verkregen prijsgeven.
2

7.6 IP=PSPACE

Lange tijd is de vraag open gebleven hoeveel computationele kracht er in een interactief bewijs kan
schuilen. Het is duidelijk dat voor alle problemen in NP korte interactieve bewijzen kunnen worden

179

gegeven; deze klasse is ongeveer zo gede(cid:12)nieerd. Aan de andere kant is PSPACE een bovengrens
voor de problemen waarvoor een interactief bewijs kan worden gegeven. Het standaardbewijs in de
literatuur maakt gebruik van een variant van backward inductie, maar er is een simpeler manier
om dit in te zien. Eerst geven we een nette de(cid:12)nitie van interactieve bewijzen.

Een bewijzer P (voor

prover"), mag elk berekenbaar of onberekenbaar mechanisme zijn, dat
"
een verzameling boodschappen produceert waarop een controleur V (voor
veri(cid:12)er") die polyno-
"
miale tijd begrensd is, maar wel gebruik mag maken van een random generator kan reageren met
boodschappen voor de bewijzer. Gegeven (cid:19)e(cid:19)en of andere invoer w (de te bewijzen stelling) bestaat
interactie tussen deze twee, P $ V , uit een serie boodschappen m1; m2; : : : ; mp(jwj) die als laatste
reject" heeft. In het eerste geval noteren we P $ V = 1, en in het tweede
boodschap
geval P $ V = 0. Omdat V gebruik maakt van een random generator, spreken we eerder van
"
P r(P $ V = 1), waarbij de waarschijnlijkheid uniform genomen wordt over alle random strings
met een lengte gelijk aan de lengte van de berekening van V op invoer w. De boodschappen met
even index zijn afkomstig van de controleur, die met oneven index zijn afkomstig van de bewijzer.
We zeggen dat een taal L een interactief bewijssysteem heeft, of tot de klasse IP hoort als en

accept" of
"

alleen als er een polynomiale tijd begrensde machine V bestaat zo dat geldt:

1. w 2 L $ (9P )[P r(P $ V = accept) > 2=3]
2. w =2 L , (8P )[P r(P $ V = 1) < 1=3].

7.6.1

IP (cid:18) PSPACE

Volgens de de(cid:12)nitie kan de vraag of w geaccepteerd wordt, worden vertaald in een vraag naar de
maximum waarschijnlijkheid genomen over alle mogelijke P . Als deze waarschijnlijkheid namelijk
groter is dan 2=3 dan geldt w 2 L, en als w =2 L, dan is deze waarschijnlijkheid gegarandeerd
kleiner dan 1=3. We laten zien dat gegeven w en V dit maximum door een PSPACE machine kan
worden berekend. Aangezien er geen enkele begrenzing is aan de rekenkracht van P , is elke volgorde
m1; m3; : : : ; mp(jwj)(cid:0)1 een legale bewijzer. Het valt op dat de bewijzer dus eigenlijk helemaal niet
naar het gezeur van de controleur hoeft te luisteren.

We moeten laten zien dat de vraag wat het maximum is over alle mogelijke bewijzers berekend
kan worden door een machine met polynomiaal begrensd geheugen. Hiertoe stellen wij ons een
berekeningsboom voor met knopen waarin de Bewijzer en de Controleur afwisselend aan de beurt
zijn.
In de bladeren van de boom is de Controleur aan de beurt en moet zij, op grond van de
conversatie die gevormd wordt door de uitgewisselde boodschappen op het pad dat in dit blad
eindigt het bewijs accepteren of verwerpen. Als zij het bewijs accepteert, dan krijgt deze knoop
de waarde 1, anders krijgt deze knoop de waarde 0. In alle andere knopen maken we de volgende
berekening. Als de Bewijzer aan de beurt is, dan moeten we een maximum nemen over alle mogelijke
boodschappen die de Bewijzer als antwoord op de conversatie op het bovenliggende pad kan geven,
we noteren dus hier het maximum van alle onderliggende knopen die een waarde hebben gekregen.
Als de Controleur aan de beurt is, dan moeten we een (gewogen) gemiddelde nemen over de waarden
in de onderliggende knopen.

Dat deze boom in PSPACE uit te rekenen is, hoeft weinig betoog. Er zijn slechts polynomiaal
veel boodschappen in een conversatie, en iedere boodschap heeft zelf slechts polynomiale lengte.
De recursiediepte van een opgebouwde boom is dus slechts polynomiaal. Verder hoeft nooit meer
dan (cid:19)e(cid:19)en enkel pad van de boom in zijn geheel gexpandeerd te worden, want zowel het nemen van
het maximum, als het nemen van een (gewogen) gemiddelde eist niet dat tussenresultaten worden

180

onthouden. De boom kan dus gewoon van links naar rechts recursief doorlopen worden, waarbij
telkens slechts (cid:19)e(cid:19)en pad in het geheugen is opgeslagen.

7.6.2 PSPACE (cid:18) IP

Voor dit deel van het bewijs laten we zien dat een bekend PSPACE-volledig probleem namelijk
Quanti(cid:12)ed Boolean Formulas een interactief bewijs heeft. We gebruiken hiervoor de arithmetische
versie van een formule.
De waarheidswaarden voor een logische variabele x, kunnen we vervangen door een waarde uit
f0; 1g waarbij 0 de rol van FALSE speelt, en 1 de rol van TRUE. Neem logische formules (cid:30) en   en
noem hun herleiding tot 0 en 1 door het invullen van de variabelen respectievelijk (cid:8) en (cid:9). Hoe dat
moet als (cid:30) en   uit individuele variabelen bestaan hebben we zojuist gezien. Inductief herleiden
we nu (cid:30) ^   en (cid:30) _   tot 0 en 1 door respectievelijk (cid:8) (cid:2) (cid:9) en (cid:8) + (cid:9) (cid:0) (cid:8) (cid:2) (cid:9) te nemen. Noem de
waarde die je krijgt uit een formule (cid:30) met (cid:19)e(cid:19)en variabele x die je krijgt door x = i in te vullen (cid:8)(i),
dan is 8x(cid:8)(x) hetzelfde als (cid:8)(0) (cid:2) (cid:8)(1) en 9x(cid:8)(x) hetzelfde asl (cid:8)(0) + (cid:8)(1) (cid:0) (cid:8)(0) (cid:2) (cid:8)(1).
We merken terloops op dat de term (cid:8)(0)(cid:2)(cid:8)(1) eigenlijk wel kan worden weggelaten. We krijgen

dan bij een ware formule een waarde groter dan 0 en bij een onware formule de waarde 0 krijgt.

Een quanti(cid:12)ed boolean formula kan nu op deze manier in zijn geheel vertaald worden naar een
getal dat groter dan 0 is dan en slechts dan als deze formule waar is. Neem eerst k een vast getal
en stel dat we een formule hebben met k variabelen, waarbij we de eerste variabele xk onbepaald
laten en we de overige variabelen invullen kortom, we nemen in plaats van de formule

De formule

P = QkxnQk(cid:0)1xk(cid:0)1 : : : Q1x1F (x1; : : : ; xk)

Qk(cid:0)1xk(cid:0)1 : : : Q1x1F (x1; : : : ; xk)

Met inductie en de vertaling hierboven zien we dat dit een polynoom pk is van de graad 2k.
Bovendien geldt in het geval Qk = 9 dat pk(0) + pk(1) > 0 $ P = true en in het geval Qk = 8 dat
pk(0) + pk(1) > 0 $ P = true

Twee verschillende polynomen van de graad 2k hebben

slechts" 2k punten gemeen. Stel er
"
geldt bijvoorbeeld niet pk(0) + pk(1) = 1, maar er is een ander polynoom q waarvoor wel geldt
dat q(0) + q(1) = 1 wanneer we een willekeurig getal r uit f1; : : : ; ng kiezen, dan is de kans dat
pk(r) = q(r) gelijk aan 2k=n. Het getal r zou namelijk precies de x van een snijpunt moeten zijn
om dit waar te maken.
De Bewijzer en de Controleur spelen nu het volgende spel|we nemen even +(cid:2) als operator die
een + is in geval van 9 en een (cid:2) in geval van 8. De bewijzer wordt steeds gevraagd een polynoom te
leveren dat overeenkomt met de quanti(cid:12)ed boolean formula als de volgende quantor van de formule
wordt afgehaald, noem het polynoom pk voor ronde k. In de eerste ronde controleert de controleur
alleen dat p1(0) +(cid:2) pk(1)

In volgende rondes is er een extra controle beschikbaar, doordat de controleur in elke ronde
In de volgende
een random getal rk kiest, dat doorgeeft aan de Bewijzer, die pk(rk) uitrekent.
ronde moet de bewijzer dan steeds een polynoom pk+i kiezen waarvoor geld pk+i(0) +(cid:2) pk+i(1) =
pk+i(cid:0)1(rk+i(cid:0)1.

Met dit protocol bereik je twee dingen. Als de waarde van de quanti(cid:12)ed boolean formula
werkelijk positief is (i.e., de formule is waar), dan kan de Bewijzer beginnen met het juiste polynoom
en daarbij blijven. Als alle kwantoren zijn geweest en alle waarden ingevuld, zijn Bewijzer en
Controleur het erover eens dat de waarde van het polynoom positief is (en dus de formule waar).

181

Als de waarde van het polynoom 0 is en de Bewijzer produceert in de eerste ronde een polynoom
dat een positieve waarde geeft bij het invullen van 0 en 1, dan moet ergens onderweg naar het echte
overgestapt". Dat betekent dat ergens de polynomen pi en pi+1 precies in ri
polynoom worden
"
moeten snijden. Als we de verzameling random getallen groot genoeg kiezen is de kans daarop
klein.
De graad van het polynoom is wat aan de hoge kant. Om de bewering PSPACE (cid:18) IP te
bewijzen, zouden we graag ongeveer n quantoren in de boolean formula willen hebben, waarmee de
graad van het polynoom op 2n uitkomt, anders kunnen we slechts formules met een beperkt aantal
quantoren aan [LFKN90]. Dat de graad van het polynoom beperkt kan worden (zelfs tot ongeveer
3) is een observatie die A. Shamir [Sha92] aan de theorie toevoegde. Dat betekent, gezien het feit
dat er exponentieel veel getallen zijn van polynomiale lengte dat de kans dat een liegende bewijzer
halverwege het bewijs zou kunnen overstappen op een snijdend polynoom exponentieel klein wordt.

Voorbeeld 7.6.1: Bekijk de (ware) quanti(cid:12)ed boolean formula

De uitdrukking

B = (8x1)[x1 _ (9x2)(8x3)[[x1 ^ x2] _ x3]]

Y

A =

z12f0;1g

X

Y

z22f0;1g

z32f0;1g

(z1:z2 + z3)

is de arithmetizering van B. De waarde van deze uitdrukking is 2. Als we de eerste quantor
weglaten, krijgen we de uitdrukking

A(z1) =

(z1:z2 + z3)

Hierbij hoort het polynoom q(z1) = z2
1 + 1. Als P dit polynoom produceert, dan kan V eerst
controleren dat inderdaad q(1) (cid:2) q(0) = 2, conform de bewering. Zouden we z1 = 3 invullen, dan
krijgen we

A(3) =

(3z2 + z3)

met waarde 10. V heeft alleen q dus V vult in q(3) = 9 + 1 = 10. Hieruit kan V a(cid:13)eiden dat de
uitdrukking

35

35

35 ;

24(1 (cid:0) z1) +
24(1 (cid:0) z1) +

24(1 (cid:0) 3) +
X

X

Y

z22f0;1g

z32f0;1g

X

Y

z22f0;1g

z32f0;1g

Y

z22f0;1g

z32f0;1g

Y

z32f0;1g

A(z2) =

(3z2 + z3)

q(z2) = 9z2

2 + 3z2:

182

de waarde 10 (cid:0) (1 (cid:0) 3) = 12 moet hebben, en aan P vragen het polynoom dat hoort bij

te genereren. Dit polynoom is

V controleert eerst dat q(0) + q(1) = 12 en kiest dan bijvoorbeeld z2 = 2. Er moet nu gelden dat

Y

z32f0;1g

A =

(6 + z3) = q(2) = 42

. Het polynoom dat P verstuurt is

q(z3) = z3 + 6;

en V kan zien dat q(0):q(1) = 6:7 = 42. Tenslotte kiest V voor z3 = 5 en controleert dat

A(z3 = 5) = (6 + 5) = 5 + 6 = q(5):

2

183

184

Bijlage A

Begrippenlijst

In dit deel herhalen we een aantal begrippen uit de tekst met hun betekenis in alfabetische volgorde.
Zo is het voor de lezer makkelijker om snel de betekenis van een begrip in de in de tekst gehanteerde
vorm terug te vinden. Voor de context kan dan gebruik gemaakt worden van de index.

adversary argument. Bewijsmethode die wordt gebruikt om een ondergrens voor een algoritme te
bewijzen. De uitvoering van de algoritme wordt gezien als een spel, waarbij een denkbeeldige
tegenstander zo ongunstig mogelijke zetten doet. Voorbeeld: het zoeken in een ongesor-
teerde rij. De elementen van de rij worden aan de zoekalgoritme gepresenteerd in willekeurige
volgorde, maar met het gezochte element als laatste in de rij. Zo wordt bewezen dat deze zoek-
methode altijd minstens alle elementen van de rij langs moet alvorens te kunnen constateren
dat het gezochte element niet aanwezig is.

amortized complexity. Uitgesmeerde complexiteit. De complexiteit van een ingewikkelde stap wordt

verdeeld over voorgaande stappen van mindere complexiteit.

articulatiepunt. Knoop in de graaf waardoor alle paden tussen twee andere knopen gaan. Als deze
knoop wordt verwijderd bestaat de resterende graaf uit tenminste twee verbonden componen-
ten. Slechte knopen om in een communicatienetwerk te hebben.

bankmethode. Een methode om uitgesmeerde complexiteit te] berekenen. Bij elke stap wordt zowel
de echte complexiteit als een \spaarbedrag" in rekening gebracht. Het spaarsaldo kan later
opgenomen worden om voor de duurdere stappen te betalen.

barometer. Spil van de berekening. Een instructie die minstens net zo vaak uitgevoerd wordt als
een willekeurige andere instructie. De complexiteit van de algoritme wordt uitgedrukt in het
aantal keren dat deze instructie wordt uitevoerd.

begrensde betegeling.

naam: BOUNDED TILING
gegeven: Een vierkant met kleuren langs de rand en een verzameling Tegeltypen
gevraagd: Is het mogelijk het vierkant te betegelen met de gegeven tegeltypen zo dat de

kleuren langs de randen van de tegels passen

NP-volledig probleem. Bewijs met Master reductie van Turing machine probleem.

185

beslissingsalgoritme. Algoritme die op elke invoer een ja of nee antwoord geeft.

beslissingsprobleem. Probleem dat vraagt om een ja of nee beslissing.

Bit Commitment . Probleem uit de Cryptogra(cid:12)e. De ene partij stuurt naar de andere partij (cid:19)e(cid:19)en
bit informatie. Hoewel de andere partij zonder extra informatie er niet achter kan komen of
dit bit 0 of 1 is, kan de zendende partij niet achteraf het bit dat verstuurd is veranderen.

blow(cid:12)sh. Cryptoalgoritme.

boedelscheiding.

naam: PARTITION
gegeven: Een verzameling van n getallen fx1; : : : ; xng

gevraagd: Is er een indexverzameling I zodatP

i2I xi =P

i =2I xi

NP-volledig probleem. Reductie van KNAPSACK.

branch & bound . Methode om de explosieve groei van een zoekboom te beperken. In elke knoop
van de gedeeltelijk ontwikkelde zoekboom wordt een waarde uitgerekend die het optimum
voorstelt dat in de subboom van die knoop nog te bereiken is. De knoop met de beste waarde
wordt gesplitst (branch). Als een pad geheel ontwikkeld is, hoeft geen enkele knoop die een
slechter optimum voorspelt dan de gevonden waarde verder te worden ontwikkeld (bound).

breadth (cid:12)rst search. Manier om een zoekboom te doorlopen waarbij van elke knoop eerst alle kno-

pen op gelijke diepte worden bezocht voordat verder in de boom gegaan wordt.

Catalaans getal . Groot getal dat in veel combinatorische problemen opduikt. Het is vernoemd naar
de Belgische wiskundige Eug(cid:18)ene Charles Catalan (1814{1894) en kan geschreven worden als

(cid:18)2n

(cid:19)

:

1

Cn =

n + 1

n

chromatic number Aantal kleuren dat minimaal nodig is om een graaf te kleuren, zodat geen twee
knopen die aan dezelfde kant zitten dezelfde kleur krijgen. NP-volledig probleem. Reductie
van satis(cid:12)ability.

circuit. Gerichte Acyclische Graaf waarin elke knoop een poort (en, of, niet) voorstelt.

Circuit Value Problem . Probleem om gegeven een invoer, de waarden van de knopen met ingraad 0
in een circuit, de uitvoer, de waarden van de knopen met uitgraad 0 te berekenen. LOGSPACE
volledig voor P , reductie van Turingmachineprobleem.

Clique

naam: Clique
gegeven: Een graaf G = (V; E) en een getal K
gevraagd: Is er een V 0 (cid:18) V met jjV 0jj (cid:21) K, zodat V 0 (cid:2) V 0 (cid:18) E

complexiteitsanalyse. Analyse van de complexiteit van een algoritme of een probleem.

complexiteitsklasse Verzameling problemen van ongeveer dezelfde complexiteit.

186

complexiteitsmaat. Maat voor de complexiteit van een algoritme of een probleem. De meestge-
bruikte maten zijn tijd en geheugen. Er zijn echter aftelbaar veel verschillende complexiteits-
maten.

component, verbonden. Ondergraaf van een graaf G waarin tussen elk tweetal knopen een pad is.

connectivity. Mate van verbondenheid van een graaf, minimaal aantal knopen (node connectivity)

of kanten (edge connectivity) om van de graaf tenminste twee componenten te maken.

cut, min. Minimale doorsnijding van een graaf (met capaciteitsfunctie).

naam: MINCUT
gegeven: Een graaf G = (V; E) met een capaciteitsfunctie c : E 7! R.

gevraagd: Verzameling knopen V 0 zo dat P

e2V 0(cid:2)V (cid:0)V 0 c(e) minimaal is. In stroompro-
blemen geldt dat de waarde van de minimale doorsnijding gelijk is aan de maximale
stroom.

cyckel . Rij punten in een graaf zodat tussen twee opeenvolgende punten een kant aanwezig is, tevens
is er een kant tussen de laatste in de eerste knoop in de rij. Als de cykel geen subcykels|deelrij
die ook een cykel is|heeft, noemen we de cykel enkelvoudig

deelgraaf . ondergraaf. Deelverzameling van de verzameling knopen met alle kanten die tussen deze

knopen aanwezig zijn.

depth (cid:12)rst search. Methode om een zoekboom te doorlopen die in een knoop eerst de uitgaande
kanten uit die knoop kiest. Als dat geen nieuwe knopen meer oplevert wordt met bactracking
de rest van de graaf op dezelfde manier doorlopen.

DES . Data Encryption Standard. Versleutelingsalgoritme van het private key type. Veelgebruikte

methode waar uitwisseling van sleutels relatief goedkoop is.

descriptieve complexiteit. Beschrijvende complexiteit, of complexiteit van de beschrijving. Hoeveel
informatie is nodig om een bepaald object te produceren. Meestgebruikt voorbeeld: Kol-
mogorov complexiteit, grootte van het kleinste Turingmachine programma dat het object
produceert.

diagonalisatie. Bewijsmethode langs \de diagonaal". Twee aftelbare verzamelingen, bijvoorbeeld
programma’s en invoeren worden langs de horizontale, resp. verticale as uitgezet. Een bewijs
tegen het bestaan van element van de ene verzameling wordt op de diagonaal verkregen, door
op coordinaat (i; i) steeds het tegenovergestelde gedrag neer te schrijven. Het vooronderstelde
element kan dan op geen plaats op de horizontale lijn staan. Voorbeelden:

1. Overaftelbaarheid van de re(cid:127)ele getallen. Schrijf een vooronderstelde aftelling van de re(cid:127)ele
getallen tussen 0 en 1 als decimale ontwikkelingen langs de horizontale as, waarbij de
decimalen langs de verticale as gezet worden. Op de diagonaal komt telkens een ander
cijfer dan het cijfer in het desbetre(cid:11)ende getal. Het resultaat is een oneindige decimale
ontwikkeling die niet in de rij staat.

2. Onbeslisbaarheid van het Halting probleem. Schrijf langs de horizontale as alle Turing-
machine programmas en langs de verticale as mogelijke invoeren. Op de diagonaal staat
een 0 als machine i op invoer i stopt, en een 1 als machine i niet op invoer i stopt. De

187

machine die niet in de rij kan voorkomen is de machine die niet op invoer i stopt als er
een 0 op plaats (i; i) staat en wel stopt als er een 1 op plaats (i; i) staat.

discrete Fourier transformatie. Methode om een gegeven polynoom van graad n te vertalen in de m
waarden die dit polynoom aanneemt in de m-de machts (cid:19)e(cid:19)enheidswortels fe2(cid:25)ij=mgj=0;:::m(cid:0)1.

dubbelverbonden component. Component van een gerichte graaf waarbij tussen elk tweetal punten

a en b zowel een pad van a naar b als een pad van b naar a is.

dynamisch programmeren. Algoritmeontwerp voor optimaliseringsproblemen dat gebruik maakt
van tabellen waarin optimale oplossingen voor deelproblemen staan. Deze optimale oplos-
singen kunnen worden samengevoegd tot oplossingen voor grotere deelproblemen, zodat uit-
eindelijk de optimale oplossing voor het hele probleem gevonden kan worden.

EDIT RAM . Random Access Machine die teksten bewerkt. In (cid:19)e(cid:19)en operatie kan een EDIT RAM
een stuk tekst (die in het programma staat of in een register is opgeborgen) vervangen door
een ander stuk tekst in de hele invoer. Deze eigenschap maakt de EDIT RAM lid van de
tweede machine klasse. Alles wat een Turing machine in polynomiaal geheugen kan doen, kan
de EDIT RAM in polynomiale tijd en omgekeerd.

extented gcd . Vorm van de Euclidische algoritme waarbij als de gcd van de ingevoerde getallen a
en b gelijk aan 1 is, de algoritme ook een c teruggeeft, zodat ac mod b = 1. Het getal c is de
multiplicatieve inverse van a.

ELEMENTARY . Eerste subrecursieve tijdbegrensde klasse die bekend gesloten is onder nondeter-

|{z}
minisme. Op invoer van lengte n geldt een tijdgrens van 222(cid:1)(cid:1)(cid:1)

.

n

entscheidungsprobleem. De vraag of er een algoritme bestaat om de universele geldigheid van eerste

orde uitspraken te beslissen. Turing gaf hier een negatief antwoord op.

Euler path. Pad in een graaf dat elke kant precies (cid:19)e(cid:19)en keer bevat. Elke graaf waarin elke knoop een

even graad heeft heeft zo’n pad, en alleen deze grafen hebben zo’n pad.

EXACTE OVERDEKKING.

naam: EXACT COVER
gegeven: Een universum U = f1; : : : ; ng met deelverzamelingen Sj
gevraagd: Bestaat er een selectie deelverzamelingen die samen nog steeds een overdekking

zijn, maar paarsgewijs een lege doorsnede hebben?

Het probleem of een collectie deelverzamelingen een exacte overdekking hebben is NP-volledig.
Reductie van Begrensde Betegelingen.

EXP. Klasse van problemen waarvoor een deterministische exponenti(cid:127)ele tijd begrensde algoritme

bestaat.

Feedback vertex set.

naam: FEEDBACK VERTEX SET
gegeven: Een graaf G = (V; E) en een getal K

188

gevraagd: Bestaat er een V 0 met jjV 0jj (cid:20) K zodat elke cykel in G tenminste (cid:19)e(cid:19)en knoop uit

V 0 heeft. NP-volledig probleem. Reductie van VERTEX COVER

Ford-Fulkerson algoritme. Methode om een maximale stroom in een netwerk te vinden die gebruik
maakt van het herhaald identi(cid:12)ceren van stroomvergrotende paden. De algoritme is correct,
maar convergeert niet altijd.

geheugencomplexiteit. Complexiteitsmaat die de hoeveelheid geheugen begrenst. De eenheid van
geheugen verschilt van model tot model. Voor een Turingmachine is dat (cid:19)e(cid:19)en bandcel, voor
een Random Access machine (cid:19)e(cid:19)en register. De sequential computation thesis eist dat redelijke
machinemodellen elkaar in constante factor overhead in geheugen simuleren. Dit vergt soms
een andere manier om geheugengebruik toe te rekenen.

geography, generalized . Spel waarbij de spelers om beurten een knoop mogen selecteren van een
gerichte graaf en die in hun verzameling op te nemen. De geselecteerde knoop moet altijd
een opvolger zijn van de door de andere speler gekozen knopen. De vraag is of de beginnende
speler een winnende strategie heeft in een gegeven graaf. NP-volledig probleem. Reductie van
QBF.

graaf . Verzameling knopen en kanten. De kanten zijn ongeordende paren knopen. De knopen
worden ook wel punten genoemd. De kanten worden in gerichte grafen ook wel bogen genoemd.
In gerichte grafen zijn de bogen geordende paren punten.

greedy algorithm (hier gulizge algoritme). Optimaliseringsalgoritme waarbij in elke stap een zo gun-
stig mogelijke keuze gemaakt wordt. Op een keuze wordt nooit teruggekomen. De problemen
waarvoor met gulzige algoritmen een optimale oplossing gevonden kan worden zijn van een
speciale soort. Bekend voorbeeld is de kortste pad algoritme van Dijkstra.

HALT . Het Halting probleem voor Turing machines. Gegeven een paar x; y waarbij x een Tu-
ringmachineprogramma is en y een invoer. Zal x op invoer y stoppen. Het probleem is
onbeslisbaar. Dwz er is geen Turingmachineprogramma dat voor elk paar x; y stopt en ja zegt
als x op y stopt en nee anders.

Hamilton circuit.

naam: HAMILTON CIRCUIT
gegeven: Een graaf G.
gevraagd: Vormt een deel van de kanten van G een enkelvoudige cykel langs alle knopen?

NP-volledig. Reductie van VERTEX COVER.

handelsreiziger probleem.

naam: TSP
gegeven: Een volledige gerichte graaf G met een gewichtsfunctie op de kanten en een grens

gevraagd: Bestaat er een enkelvoudige cykel in G waarvan het totale gewicht kleiner is

b.

dan b?

NP-volledig. Reductie van HAMILTON CIRCUIT.

189

hashtabel . Database met natuurlijke getallen als index. De plaats van een record in de database
wordt bepaald door een zogenoemde hashfunctie die op grond van een veld in het record een
waarde berekend. Doorgaans is deze functie cyclish en berekent hij niet een unieke waarde
voor elk record. Als twee records hetzelfde adres wordt toegewezen ontstaat een collision die
op verschillende manieren kan worden opgelost (collision resolution).

heuristiek . Op natte vingerwerk gebaseerde methode om keuzen te maken in optimaliseringspro-
blemen. Vaak dient een|niet werkende|greedy algoritme als heuristiek voor een optimali-
seringsprobleem waarna suboptimale oplossingen worden verbeterd door bactracking of local
search.

HITTING SET .

naam: HITTING SET
gegeven: Een verzameling deelverzamelingen fSjgj van U = f1; : : : ; ng en een getal k
gevraagd: Is er een deelverzameling V (cid:18) U met jjV jj (cid:20) k, zodat voor alle j geldt xj\V 6= ;?
NP-volledig, reductie van VERTEX COVER

INDEPENDENT SET .

naam: INDEPENDENT SET
gegeven: Een graaf G = (V; E) en een getal K
gevraagd: Is er een deelverzameling V 0 (cid:18) V met jjV 0jj (cid:20) K zdd V 0 (cid:2) V 0 \ E = ;?

inproduct Getal dat verkregen wordt door van twee vectoren v en w, beide van dimensie n, over-
eenkomstige coordinaten met elkaar te vermenigvuldigen en het resultaat van de vermenig-
vuldigingen bij elkaar op te tellen. Als het inproduct van v en w gelijk is aan 0, dan staan v
en w loodrecht op elkaar.

integraalkenmerk van d’Alembert Kenmerk dat gebruikt wordt om de som van een reeks af te
schatten. De som is altijd kleiner of groter dan de integraal van de functie, afhankelijk van
welke grenzen worden genomen.

Khacian’s algoritme. Algoritme voor lineaire programmeren. De meest gebruikte algoritme, de
simplex algoritme is in sommige gevallen exponentieel. Khacian’s algoritme, ook wel ellipsoide
algoritme genoemd, is altijd polynomiaal.

kleurbaarheid . De vraag of een graaf zodanig met een gegeven aantal kleuren te kleuren is dat geen
twee punten die door een kant verbonden zijn dezelfde kleur krijgen. 2-kleurbaarheid is po-
lynomiaal, 3-kleurbaarheid is NP-volledig (reductie van 3SAT). 4-kleurbaarheid van planaire
grafen is triviaal. 3-kleurbaarheid is ook voor planaire grafen NP-volledig.

kleurgetal . Minimale aantal kleuren dat nodig is om een gegeven graaf te kleuren. Ook wel CHRO-

MATIC NUMBER genoemd.

KNAPSACK .

naam: KNAPSACK
gegeven: Een verzameling objecten o1; : : : ; on met gewichten w1; : : : ; wn en waarden v1; : : : ; vn

gevraagd: Bestaat er een verzameling I, zo datP

en twee getallen b en v.

i2I wi (cid:20) b, terwijlP

i2I vi (cid:21) v?

190

knoopoverdekking, VERTEX COVER.

naam: VERTEX COVER
gegeven: Een graaf G = (V; E) en een getal K.
gevraagd: Bestaat er een V 0 (cid:18) V met jjV 0jj (cid:20) K zdd (8e 2 E)[e \ V 0 6= ;]?

knowledge, zero. Type protocol waarbij de Veri(cid:12)er overtuigd raakt van de juistheid van de stelling

terwijl niets wordt geleerd over het bewijs.

Kruskal, algoritme van. Methode om een mincost spanning tree te berekenen in een gewogen graaf.
Bij deze algoritme worden een aantal bomen gevormd die samengroeien totdat er nog (cid:19)e(cid:19)en
boom over is.

LOGSPACE . Klasse van talen die kan worden herkend door een Turing machine waarvan het

geheugengebruik wordt begrensd door de logaritme van de lengte van de invoer.

machtreeks. Reeks waarbij de termen machten van een grondtal zijn.

masterprobleem. Probleem dat volledig wordt bewezen in een klasse door een reductieschema te

geven waarbij een Turing machine, een grens en een invoer de parameters zijn.

masterreductie. Reductieschema voor het volledig bewijzen van een masterprobleem.

matching, perfect Selectie van een aantal kanten van een graaf waarbij de graaf beperkt tot deze

kanten twee (of meer) delig wordt.

matrixvermenigvuldigingsexponenent. Exponent van het polynoom dat de grens is voor de meest

e(cid:14)ciente matrixverminigvuldigingsalgoritme.

minor . Ondergraaf die uit een graaf G kan worden verkregen door een kant weg te laten of samen

te trekken.

MRAM . Multiplication RAM. Random Access machine waarbij de kosten van een vermenigvuldi-

ging van willekeurig grote operanden op 1 wordt gesteld.

NP Klasse van problemen herkenbaar door nondeterministische Turingmachines in polynomiale
tijd. Equivalent: de klasse van problemen waarvoor een gegeven oplossing in polynomiale tijd
kan worden gecontroleerd.

ODDMINSAT . naam: ODDMINSAT

gegeven: Een formule F = F (x1; : : : ; xn).
gevraagd: Is het laatste bit van de lexicogra(cid:12)sch kleinste vervulling, gelezen als bitstring,

gelijk aan 1?

Volledig voor PNP, het eerste Delta level van de polynomiale hierarchie [Sto76].

ondergraaf . Graaf die verkregen wordt uit een graaf G door een aantal punten met de bijbehorende

incidente kanten weg te laten.

ondergrens. Minimaal benodigde looptijd voor een algoritme op invoeren van lengte n, waarbij over

alle invoeren van lengt n het maximum genomen mag worden.

opspannende boom. Deel van de kanten van een graaf dat een boom vormt waarin alle punten zijn

opgenomen.

191

optimalisatiealgoritme. Algoritme die de optimale oplossing vindt voor een probleem.

optimaliseringsprobleem. Probleem waarbij naar een optimum gezocht wordt. Zie ook: beslissings-

probleem.

bevatten.

Turing machine.

overdekking. Selectie van deelverzamelingen die samen alle elementen van een gegeven verzameling

overdekkingsprobleem. Probleem dat het vinden van een overdekking stelt.

P. Klasse van problemen die zijn op te lossen met een deterministische polynomiale tijd begrensde

padding lemma Lemma uit de recursietheorie. Bij elke codering van Turingmachines als natuurlijke

getallen, komt elke Turingmachine die een bepaalde functie berekent oneindig vaak voor.

parallellisme, onbegrensd . Machinemodel waarbij verschillende processoren tegelijkertijd werken.
Met onbegrensd parallelle machines kunnen PSPACE volledige problemen in polynomiale tijd
worden opgelost.

perebor . Russisch woord dat de inherente hardheid van combinatorische problemen karakterizeert.

potentiaalmethode. Methode om de uitgesmeerde complexiteit van een algoritme te bepalen.

PRAM . Parallelle Random Access Machine. Machinemodel met onbegrensd parallellisme, ook wel

SIMD RAM genoemd.

priemfactoren. Factoren waardoor een getal deelbaar is die zelf alleen deelbaar zijn door 1 en

priemgetal . Getal dat alleen deelbaar is door 1 en zichzelf.

zichzelf.

primaliteitstest

naam: PRIMALITY
gegeven: Een getal p
gevraagd: Is p priem

. Probleem in P . Bewijs door Agrawal, Kayal en Saxena [AKS04]. Lange tijd heeft men
gedacht dat dit een probleem in NP \ Co (cid:0) NP was dat niet in P zat, hoewel er goede ran-
domized algoritmen bestaan die de primaliteit van een getal kunnen testen. Deze algoritmen
worden in de praktijk nog steeds gebruikt.

Prim, algoritme van. Methode om een mincost spanning tree te berekenen in een gewogen graaf.
Bij deze algoritme is er steeds (cid:19)e(cid:19)en deel van een opspannende boom die langzaam groeit totdat
alle punten er deel van uitmaken.

primaliteitstest. Test om te bepalen of een getal een priemgetal is.
primitieve n-de machts (cid:19)e(cid:19)enheidswortel . Oplossing van de vergelijking xn (cid:0) 1 = 0.

probabilistische algoritmen Algoritmen die gebruik mogen maken van coin(cid:13)ips.

192

PSPACE. Klasse van problemen oplosbaar door Turingmachines die in geheugen begrensd zijn door

een polynoom in de lengte van de invoer.

quanti(cid:12)ed boolean formulae. Predicaatlogische formules.

quantum computing. Berekeningen gebaseerd op principes van de quantummechanica. De invoer
is een quantum state, meestal een superpositie van toestanden die ontwikkelt door middel
van unitaire afbeeldingen. Gedurende berekeningen wordt de toestand een aantal malen
geobserveerd, waardoor een gehele of gedeeltelijke collapse van de superpositie plaatsvindt.

quicksort Sorteermethode volgens het verdeel-en-heersprincipe. In een rij van n elementen wordt
een spil gekozen, waarna alle elementen kleiner dan de spil links van de spil geplaatst worden,
terwijl alle andere elementen rechts van de spil geplaatst worden. De twee deelrijen worden
recursief op dezelfde wijze gesorteerd.

radix sort. Methode van sorteren gebaseerd op het achtereenvolgens sorteren van getallen op basis

van de in die getallen voorkomende cijfers.

RAM . Random Access Machine. Machinemodel bestaande uit een CPU die een programma uit-
voert dat uit een genummerde lijst van instructies bestaat. Het geheugen van de machine is
een onbegrensd aantal registers die elk een natuurlijk getal kunnen bevatten.

recurrente betrekking. Vergelijking die de verhouding weergeeft van ge(cid:127)(cid:16)ndexeerde variabelen.

In
deze tekst worden recurrente betrekkingen vooral gebruikt voor de complexiteitsanalyse van
recursieve algoritmen.

reductie. Bewerking de de relatieve complexiteit van problemen bepaalt.

RSA. Public key cryptosysteem vernoemd naar de uitvinders: Rivest, Shamir en Adleman.

simplexalgoritme Methode om lineair programmeren problemen op te lossen. De afbeeldingen lopen
van hoekpunt naar hoekpunt op een polytoop om het optimum van de lineaire functie op dat
polytoop te vinden.

spil . Zie barometer.

sleutel . Onderdeel van een versleutelingsalgoritme. Met de sleutel is codering en decodering een-

voudig. Zonder sleutel is het moeilijk.

Strassen, algoritme van. Recursieve manier om vierkante matrices met elkaar te vermenigvuldigen.

In plaats van O(n3) heeft deze algoritme een complexiteit O(n

2 log 7.

stroomvergrotende paden Paden in een netwerk waarlangs de capaciteit niet is uitgeput. Langs deze
paden is het vergroten van de stroom nog mogelijk. Essentieel onderdeel in de Algoritme van
Ford en Fulkerson.

Turing machine. Machinemodel bestaande uit een centrale verwerkingseenheid en een band. De Tu-
ringmachine werkt doordat in elke stap een symbool van de band gelezen wordt, een symbool
op de band geschreven wordt en de machine van de ene toestand uit een eindige verzameling
toestanden naar een andere toestand overgaat. Tenslotte beweegt de leeskop op de band naar
links of naar rechts.

193

toestandsovergangsfunctie Functie (soms relatie) die op invoer een toestand en een symbool, de
volgende toestand(en) geeft en het symbool of de symbolen die het gelezen symbool gaan
vervangen, alsmede de beweging van de leeskop.

versleutelingsalgoritme Algoritme die gegeven een sleutel een boodschap codeert.

vierkleurenprobleem Is het mogelijk een gegeven planaire graaf met vier kleuren te kleuren, zodat
geen twee met elkaar verbonden knopen dezelfde kleur krijgen. Antwoord: ja. Bewijs gevon-
den met behulp van een computer door Appel en Haken. Naar een inzichtelijk bewijs voor
deze stelling wordt nog steeds druk gezocht.

waarheidswaarden True en False of 1 en 0. Waarden die aan variabelen in een propositie kunnen

worden toegekend.

zelfreduceerbaarheid Eigenschap van bepaalde problemen. Het antwoord op een zelfreduceerbaar
probleem kan worden gevonden door een aantal kleinere instanties van hetzelfde probleem op
te lossen. Zelfreduceerbare problemen zijn typisch problemen die met recursieve algoritmen
kunnen worden aangepakt.

zoekboom Boom die door een zoekalgoritme wordt doorlopen. Typisch voorbeeld is een access

structuur in een database.

zoekruimte. Totaal van alle mogelijke elementen die door een zoekalgoritme zouden kunnen worden
gevonden. De afmetingen van de zoekruimte zijn van groot belang voor de complexiteit van
een zoekalgoritme.

194

Bibliogra(cid:12)e

[AB98]

[AH77a]

[AH77b]

[AKS04]

[BB96]

[Bur00]

M. Akra and L. Bazzi. On the solution of linear recurrence equations. Computational
Optimization and Applications, 10:195{210, 1998.

K. Appel and W. Haken. Every planar map is four colorable. part i. discharging.
Illinois J. Math., 21:429{490, 1977.

K. Appel and W. Haken. Every planar map is four colorable. part ii. reducibility.
Illinois J. Math., 21:491{567, 1977.

Manindra Agrawal, Neeraj Kayal, and Nitin Saxena. Primes is in P. Annals of
Mathematics, 160(2):781{793, 2004.

G. Brassard and P. Bratley. Fundamentals of Algorithmics. Prentice Hall International
Editions, 1996.

M. Buro. Simple amazons endgames and their connection to hamilton circuits in cubic
subgrid graphs. In Proc. 2nd Int. Conf. Computers and Games, 2000.

[CDRH+96] J. Cowie, B. Dodson, R.Elkenbracht-Huizing, A.K. Lenstra, P.L. Montgomery, and
J. Zayer. A world wide number (cid:12)eld sieve factoring record: on to 512 bits. In Advances
in Cryptology{ASIACRYPT6, pages 382{394, 1996.

[CFLS97]

A. Condon, J. Feigenbaum, C. Lund, and P. Shor. Random debaters and the hardness
of approximating stochastic functions. SIAM Journal on Computing, 26(2):369{400,
1997.

[CLR90]

[CSS97]

[Cul99]

[DH76]

[ET75]

T.H. Cormen, C.E. Leiserson, and R.L. Rivest. Introduction to Algorithms. MIT Press,
1990.

G. Cornell, J.H. Silverman, and G. Stevens, editors. Modular Forms and Fermat’s
Last Theorem. Springer-Verlag, 1997.

J. Culberson. Sokoban is pspace-complete. In Int. Conf. Fun with Algorithms, Pro-
ceedings in Informatics 4, pages 65{76, 1999.

W. Di(cid:14)e and M. E. Hellman. New directions in cryptography. IEEE Transactions on
Information Theory, IT-22:644{654, November 1976.

S. Even and R.E. Tarjan. Network (cid:13)ow and testing graph connectivity. SIAM Journal
on Computing, 4:507{518, 1975.

195

[ET76]

[FF56]

S. Even and R. E. Tarjan. A combinatorial problem which is complete in polynomial
space. In Proc. 7th ACM Symp. Theory of Computing, pages 710{719, 1976.

L.R. Ford and D.R. Fulkerson. Maximum (cid:13)ow through a network. Canadian Journal
of Mathematics, 8:399{404, 1956.

[FHN+03] Henning Fernau, Torben Hagerup, Naomi Nishimura, Prabhakar Ragde, and Klaus
Reinhardt. On the parameterized complexity of the generalized rush hour puzzle. In
Proc. 15th Canad. Conf. Comput. Geom., pages 6{9, 2003.

[GHR95]

R. Greenlaw, H.J. Hoover, and W.L. Ruzzo. Limits to Parallel Computation: P-
Completeness Theory. Oxford University Press, 1995.

[GJ79]

M.R. Garey and D.S. Johnson. Computing and Intractability, A Guide to the Theory
of NP-Completeness. W.H. Freeman and Company, New York, 1979.

[GT02]

M.T. Goodrich and R. Tamassia. Algorithm Design. Wiley, 2002.

[Har92]

D. Harel. Algorithmics, the Spirit of Computing. Addison Wesley, 1992.

[Hea05]

Robert A. Hearn. Amazons is pspace-complete, 2005.

[HNR68]

P.E. Hart, N.J Nilsson, and B. Raphael. A formal basis for the heuristic determination
of minimum cost paths.
IEEE Transactions on Systems Science and Cybernetics,
4(2):100{107, 1968.

[HS76]

[IK94]

Juris Hartmanis and Janos Simon. On the structure of feasible computations. Advances
in Computers, 14:1{43, 1976.
S. Iwata and T. Kasai. The othello game on an n(cid:2)n board is pspace-complete. Theo-
retical Computer Science, 123:329{340, 1994.

[Imm88]

N. Immerman. Nondeterministic space is closed under complementation. SIAM J.
Comput., 17:935{938, 1988.

[JS04]

R. Johnsonbaugh and M. Schaefer. Algorithms. Pearson, 2004.

[Kha80]

L.G. Khacian. Polynomial algorithms in linear programming. Zh. vychisl. Mat. mat.
Fiz, 20(1):51{68, 1980.

[Knu73]

D.E. Knuth. The Art of Computer Programming, volume 3. Addison Wesley, 1973.

[LFKN90] C. Lund, L. Fortnow, H. Karlo(cid:11), and N. Nisan. Algebraic methods for interactive
proof systems. In Proc. 31st Symposium on Foundations of Computer Science, pages
2{90, New York, 1990. IEEE.

[LS80]

[Meh85]

D. Lichtenstein and M. Sipser. Go is polynomial-space hard. Journal of the ACM,
27:393{401, 1980.

K. Mehlhorn. Graph Algorithms and NP-Completeness. EATCS Monographs on The-
oretical Computer Science. Springer-Verlag, 1985.

196

[MKM78]

Vishv M. Malhotra, M. Pramodh Kumar, and S. N. Maheshwari. An o(|v|) al-
gorithm for (cid:12)nding maximum (cid:13)ows in networks.
Inf. Process. Lett., 7(6):277{278,
1978.

[Par99]

[Pom96]

[Rei05]

[RS83]

[RS04]

R. Parkinson. Cracking Codes, the Rosetta Stone, and Decipherment. University of
California Press, 1999.

C. Pommerance. A tale of two sieves. Notices of the American Mathematical Society,
43(12):1473{1485, 1996.

O. Reingold. Undirected ST-connectivity in LOGSPACE. In Proceedings 37th Annual
ACM Symposium on Theory of Computing, pages 376{385, 2005.

N. Robertson and P.D. Seymour. Graph minors. i. excluding a forest. Journal of
Combinatorial Theory Series B, 35(1):39{61, 1983.

N. Robertson and P.D. Seymour. Graph minors. xx. wagner’s conjecture. Journal of
Combinatorial Theory Series B, 92(2):325{357, 2004.

[RSA78]

R.L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital signatures
and public-key cryptosystems. Communications of the ACM, 21(2):120{126, 1978.

[Sha92]

A. Shamir. IP=PSPACE. Journal of the ACM, 4:869{877, October 1992.

[Ski98]

S. Skienna. The Algorithm Design Manual. Springer Verlag, 1998.

[Sto76]

[Str69]

[Sze87]

[Tur36]

L. Stockmeyer. The polynomial-time hierarchy. Theoretical Computer Science, 3:1{22,
1976.

V. Strassen. Gaussian elimination is not optimal. Numerische Mathematik, 13:354{
356, 1969.

R. Szeleps(cid:19)enyi. The method of forcing for nondeterministic automata. Bulletin of the
EATCS, 33:96{100, 1987.

A. M. Turing. On computable numbers, with an application to the Entscheidungspro-
blem. Proceedings of the London Mathmatical Society, 42(2):230{265, 1936.

[Wil86]

H.S. Wilf. Algorithms and Complexity. Prentice-Hall International Editions, 1986.

197

Index

O, 26
(cid:10), 27

!, 27(cid:24), 27

Adleman, 101
Akra, 32
Alembert

algoritme

(cid:18), 27
o, 27
3-KLEURBAARHEID, 152
3SAT, 138

integraalkenmerk van d’-, 190

- van Kruskal, 191
- van Prim, 192
- van Strassen, 193
beslissings-, 186
Euclidische -, 83
exponenti(cid:127)ele tijd begrensde -, 129
Ford-Fulkerson, 75
Ford-Fulkerson -, 189
gulzige -, 39, 189
Khacian’s -, 190
optimalisatie -, 39
optimaliserings -, 192
probabilistische -, 192
simplex-, 193
Uitgebreide Euclidische -, 83
versleutelings-, 194

analyse

complexiteits-, 186

argument

adversary -, 185

Aristoteles, 83
articulatiepunt, 185
axioma, 178

barometer, 185
Bazzi, 32
BEGRENSDE BETEGELING, 146
beslissingsalgoritme, 186
beslissingsprobleem, 186
betegeling

begrensde -, 185

betrekking

eerstegraads recurrente -, 31
recurrente -, 31, 193

blow(cid:12)sh, 186
BOEDELSCHEIDING, 150
boedelscheiding, 186
boom

opspannende -, 43, 191

BOUNDED TILING, 131, 185
bovengrens

exponenti(cid:127)ele -, 75

bovengrenzen, 26
branch & bound, 186
Branch en Bound, 162
breadth (cid:12)rst search, 186

Cantor, G., 13
capaciteit, 73
rest-, 74

CHROMATIC NUMBER, 151
circuit, 186

Hamilton -, 189

circuit value problem, 186
CLIQUE, 131, 141
clique, 186
Cnidus

Eudoxus van -, 83

commitment

bit -, 186

complexiteit

198

descriptieve -, 187
geheugen -, 189
uitgesmeerde -, 185
uitgesmeerde - mbv bankmethode, 185

EULER CYCLE, 142
EXACT COVER, 188
EXACTE OVERDEKKING, 147
EXP, 123

complexiteitsklasses, 186
complexiteitsmaat, 187
complexity

amortized -, 185

component

dubbelverbonden -, 188
verbonden -, 187

computing

quantum -, 193

connectivity, 187
Cooley, 88
Cormen, 32
counting

inductive -, 176
cryptogra(cid:12)e, 86, 99
cryptosysteem

block cypher, 100
private key -, 99
Public key -, 86, 101
public key -, 99

cut

min -, 187

cykel, 187

deelgraaf, 187
deler

grootste gemene -, 83

Depth First Search, 67
DES, 187
diagonalisatie, 187
Di(cid:14)e, 100
Dijkstra

algoritme van -, 42

doorsnijding, 75

capaciteit van -, 73
minimale capaciteit, 73

ELEMENTARY, 133, 188
entscheidungsproblem, 188
Euclides

algoritme van -, 83
Uitgebreide -ische Algoritme, 188

Euler, 142

FEEDBACK VERTEX SET, 188
Feistel, H., 100
Fermat

stelling van, 103

FFT, 88
Ford, 75
Fourier

discrete - transformatie, 188
Fast - Transform, 88
inverse - transformatie, 93

Fulkerson, 75
functie

capaciteits-, 73
capactietis-, 73
stroom-, 73

GENERALIZED GEOGRAPHY, 189
getal

Catalaans -, 186

graaf, 76, 189

HALT, 189
HAMILTON CIRCUIT, 142
HAMILTONIAN CIRCUIT, 189
HANDELSREIZIGER, 145
hashtabel, 190
Helman, 100
heuristiek, 190
Hilbert, D., 13
HITTING SET, 190

INDEPENDENT SET, 131, 141, 190
inproduct, 190
instantie, 130

kant

klasse

capaciteit, 74

complexiteits-, 186

kleurbaarheid, 190
KLEURGETAL, 151
kleurgetal, 190

199

KNAPSACK, 186, 190
knapsack, 41

0-1, 58
fractionele -, 41

knoopoverdekking, 191
knowledge

zero - protocol, 191

Kruskal

algoritme van -, 191
algoritme van -, 43

Leiserson, 32
lemma

padding -, 192

LOGSPACE, 191

maat

machine

complexiteits, 187

geklokte Turing {, 126
nondeterministische Turing -, 123
nondeterministische Turing -, 132
Turing -, 193
unviversele Turing -, 124, 125

machinemodel

random access -, 112
redelijk -, 111
Turing -, 113

machtreeks, 191
masterprobleem, 191
masterreductie, 138, 191
matching

perfect -, 79, 191

matrix, 51
matrixvermenigvuldigingsexponent, 191
Merkle

key exchange van -, 100

Merkle, P., 100
methode

192

minor, 191
MRAM, 120, 191

netwerk, 73, 76

doorsnijding, 73
Feistel -, 100

potentiaal - voor uitgesmeerde complexiteit,

gelaagd, 76, 77
gelaagd -, 76

NP, 191

number

volledig probleem, 135

chromatic -, 186

ODDMINSAT, 191
ondergraaf, 191
ondergrens, 191
oplosbaarheid

optimaliseringsalgoritme, 192
optimaliseringsprobleem, 192
overdekking, 192
exacte -, 188
knoop-, 191

overdekkingsprobleem, 192

E(cid:14)cient Oplosbaar Probleem, 25

P, 123, 192
pad

Euler -, 188
one time -, 99
stroomvergrotend -, 75
stroomvergrotend -, 74{76, 193
strooomvergrotend -, 77

padding, 127
parallellisme

onbegrensd -, 192
PARTITION, 150, 186
perebor, 130, 192
PLANAIRE 3-KLEURBAARHEID, 153
Pommerance, 101
potentiaalmethode, 192
PRAM, 119, 192
priem

relatief -, 83
priemfactor, 192
priemgetal, 192
Prim

algoritme van -, 192
algoritme van -, 43

primaliteit

test, 192

primaliteitstest, 192
probleem

begrensde betegelings-, 131

200

beslissings-, 186
boedelscheiding, 131
bron-, 134
cricuit value -, 186
doel-, 134
exacte overdekkings -

praktisch voorbeeld van een -, 132

exacte overdekkings-, 131
handelsreiziger-, 189
instantie van een -, 130
kleurbaarheids-, 131

praktisch voorbeeld van -, 131

knapsack-, 131
knoopoverdekkings-, 131

praktisch voorbeeld van een -, 132

master-, 191
NP-volledig, 142
NP-volledig -, 135
onafhankelijke verzameling -, 131
optimaliserings -, 192
overdekkings-, 192
traveling salesperson -, 130
verdeel-, 146
vervulbaarheids-, 131
vervulbarheids -, 135
vierkleuren-, 194
volledige ondergraaf, 131

processor, 112
programma

Turing machine -, 127

programmeren

dynamisch -, 188

PSPACE, 193
Pythagoras, 83

QBF, 193
quicksort, 193

radix sort, 193
RAM, 118

EDIT -, 188
multiplication, 120
multiplication -, 191
parallel, 119

ram, 193
redelijkheidsaanname, 111
reductie, 134, 138, 193

-schema, 138
master-, 138, 191

reductieschema, 138
register, 112
Rivest, 32, 101
RSA, 101, 193

SATISFIABILITY, 131, 135
scheduling, 45

- met deadlines, 46

search

breadth (cid:12)rst -, 186
exhaustive, 123
exhaustive -, 129, 130

Shamir, 101
sleutel, 99, 193

sorteren

uitwisselen van de -, 100

mergesort, 55
ondergrens voor -, 56
quicksort, 54, 193
radix sort, 193

spil, 185, 193
Standard

stelling

Strassen, 51

stroom, 73

Data Encryption -, 187

max-cut-min-(cid:13)ow, 75

algoritme van -, 193

blokkerende -, 77
maximale -, 73
maximale-, 73

stroomfunctie, 73

thesis

tijd

sequential computation -, 111

Polynomiale -, 25

toestandsovergangsfunctie, 194
tree

mincost spanning -, 43

TSP, 189
Tukey, 88
Turing

- machine, 193

Turingmachine

201

halfoneindige band -, 116
meerbands -, 116
meerkops -, 116
meertracks -, 115
tweedimensionale band -, 118
variaties op het -model, 115

versleuteling, 99

asymmetrische -, 99
symmetrische -, 99

versleutelingsalgoritme, 194
VERTEX COVER, 140, 189, 191
vierkleurenprobleem, 194
volledig

NP, 135

waarheidswaarden, 194
wisselen

geld -, gulzige algoritme, 40

zelfreduceerbaarheid, 194
zoekboom, 194
zoekruimte, 194

202

